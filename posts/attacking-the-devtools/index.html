<!DOCTYPE html><html lang="en" > <!-- The Head v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="twitter:image" content="https://microsoftedge.github.io/edgevr/assets/img/edge-logo-128x128.png"><title>Guest Blog Post - Attacking the DevTools | Microsoft Browser Vulnerability Research</title><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Guest Blog Post - Attacking the DevTools" /><meta name="author" content="David Erceg" /><meta property="og:locale" content="en_US" /><meta name="description" content="In this post, we’ve invited David Erceg, one of the participants in the Edge bug bounty program, to talk about interesting bugs he found in Edge. By sharing this information, we hope more security researchers are motivated to work with us to improve the security of Edge and Chromium as a whole. Introduction Within Chromium and its derivatives, the DevTools is an interesting attack surface. That’s because the DevTools itself is fairly highly privileged, especially if it’s attached to a page as part of a debugging session. Therefore, bugs within the DevTools can allow a malicious extension to escalate its privileges. That’s because an extension may have the ability to load DevTools URLs and once an extension can do that, it can potentially take advantage of any bugs that are present. The post here will examine how an extension could, in previous versions of Chrome/Edge, run code within the context of the DevTools and how the ability to do that could allow the extension to run code outside of the browser’s sandbox. Running code within the DevTools There have been at least several past issues that would allow an extension to run code within the context of the DevTools. Using the remoteBase query parameter One issue in Edge involved the use of the remoteBase query parameter. That parameter can be used to indicate that a resource should be loaded from a particular external location. However, it’s important that the parameter is validated. A simple example that illustrates why that’s so important is something like the following URL: devtools://devtools/bundled/inspector.html?remoteBase=javascript:... If the remoteBase parameter is used to add an iframe to inspector.html, then in the case above, the iframe will point to a javascript: URL and will be same-origin with its parent. That, essentially, is the issue that was present in the DevTools within Edge. The first step to finding this issue was to note the following URL showed up when opening the DevTools while logging requests passed through the webRequest API: https://devtools.azureedge.net/serve_file/@3bb5c9989b78b4fcfd356345ac1b4c0d626baefa/third_party/webhint/worker_frame.html On a side note, this can be a very useful technique to find requests that are improperly visible from privileged pages. If you create an extension that logs all requests passed to chrome.webRequest.onBeforeRequest, then load a privileged page, you might find instances where a privileged page is loading an unprivileged page in a frame. Using the webRequest API you could then redirect those requests to a page you control. If there are any issues with message passing between the frame and its privileged parent, you might then be able to run code within the context of the parent. The next step after noting that the DevTools was loading the above URL was to try and track down precisely how that was done. It’s simple enough to debug a DevTools window. If, for example, you have a DevTools window opened on a tab, you can first undock that instance, then press Ctrl + Shift + I to debug that instance of the DevTools. That allows you to browse and debug the JavaScript code associated with the DevTools. An issue at this point is that the JavaScript code is minified. If you’re examining the DevTools in Chrome, it’s simple enough to look at the original source via https://source.chromium.org. On Edge, that’s not possible, but you can still debug through the code to get an idea of what’s happening. In the case above, debugging through the code fairly quickly lead to the insight that the URL above was being constructed directly from the remoteBase parameter without any validation. Performing a quick test with the following URL confirmed that that was the case: devtools://devtools/bundled/inspector.html?remoteBase=javascript:console.log(&#39;Frame content set by query parameter&#39;)// Note that the javascript: portion of the URL here ends in a comment, since the DevTools will append “third_party/webhint/worker_frame.html” onto the end of the base URL that’s set. One thing to note is that this general issue has also affected Chromium in the past. For example, a very similar problem was first reported in issue 571121. The fix made there was then shown to be insufficient in issue 619414. Using a devtools_page entry The devtools_page manifest entry refers to an extension page that’s loaded in an iframe within the DevTools and has access to the three chrome.devtools APIs (chrome.devtools.inspectedWindow, chrome.devtools.network and chrome.devtools.panels). As in the case above, where the remoteBase query parameter wasn’t being validated, it used to be the case in Chromium that the devtools_page entry wasn’t being validated either. This meant that if you set the devtools_page entry to a javascript: URL, Chromium would load that URL in an iframe within the DevTools. That frame would then have the ability to script the parent DevTools instance. Using a devtools_page entry and the debugger permission The devtools_page manifest entry and debugger permission make a powerful combination. For context, the debugger permission allows an extension to use the Chrome DevTools Protocol to debug a page. This protocol is also what’s used internally by the DevTools, though an extension doesn’t have access to the full set of methods (e.g. Browser.setDownloadBehavior is restricted). The reason these two features are so powerful together is that an extension with the debugger permission can dispatch input events, including browser shortcuts and, more specifically, the browser shortcut to open the DevTools. That means that an extension with the debugger permission can open the DevTools and the extension’s DevTools page can then script the target page, potentially in cases where the page isn’t accessible via the debugger permission. Previously, there were no restrictions on when an extension page could script the target page (by using, for example, chrome.devtools.inspectedWindow.eval). This meant that if the DevTools was opened on a tab and the tab was navigated to a privileged page, any extension page that was loaded within the DevTools would be able to script that privileged page. Since an extension with the debugger permission can open the DevTools, it could then run code on any privileged page, including a DevTools page, using a devtools_page entry. Sending a series of crafted messages from an extension’s DevTools page Internally, the DevTools relies on the channel messaging API to provide the functionality available in the chrome.devtools API. This is something that’s markedly different from every other extension API, where the implementation is written in C++ and run within the browser process. Since the chrome.devtools API relies on channel messaging between two JavaScript contexts (the extension page context and the DevTools context), that provides a unique opportunity for potential issues. For example, if the DevTools doesn’t properly validate the messages it receives from an extension page, there’s the potential for privilege escalation. That is, the extension page might be able to run arbitrary code within the DevTools. Issue 1064519 describes a case in which that was possible. That particular issue took a while to fully develop. While it was clear after reading through some of the JavaScript code used by the DevTools that values could be overwritten, it wasn’t immediately clear how to fully take advantage of that. A central problem is that you can really only pass data over a MessageChannel, not code. So while you might be able to overwrite a value in a target context, if that context isn’t properly validating messages it receives, you can’t directly invoke any code. However, one thing an extension page can do is use chrome.devtools.panels.create to create a panel. That panel will be created within the DevTools and will contain the page that’s specified by the extension in an iframe. Crucially, the full path to the page is constructed by appending the page’s path to the extension’s origin and the origin is something that’s stored in JavaScript by the DevTools. Because of how the origin was being stored, it could be overwritten by sending a specially crafted channel message. By setting the origin to a javascript: URL, an extension could then cause the DevTools to create an iframe with that URL set as its source, allowing the extension to script the DevTools. Privileges granted to the DevTools Once an extension can run code within the context of the DevTools, the next natural step is to determine precisely what that allows. Read local files To begin with, the DevTools can read local files. The method to do that is documented in several different Chromium issues. For reference, the following code, when run within the context of the DevTools, will log the contents of file:///c:/: 1 2 3 4 5 6 7 8 9 10 11 let data = &quot;&quot;; DevToolsAPI.streamWrite = function (id, chunk) { data += chunk; }; DevToolsAPI.sendMessageToEmbedder(&quot;loadNetworkResource&quot;, [&quot;file:///c:/&quot;, &quot;&quot;, 0], function (result) { console.log(data); } ); Script extensions and arbitrary sites In addition to the Chrome Devtools Protocol, the DevTools also has access to a set of custom API methods. One of those methods is registerExtensionsAPI. As the name of the method suggests, this particular method is used to setup extension pages (i.e. the devtools_page entries) within the DevTools. As discussed above, the chrome.devtools API is implemented using the channel messaging API. That means that the DevTools contains code to process messages it receives. However, when you call the chrome.devtools API from an extension’s DevTools page, you won’t need to use the channel messaging API at all. The reason for that is that the DevTools injects a script into an extension frame on every navigation of that frame. That script is what then uses channel messaging behind the scenes. Looking at how registerExtensionsAPI is called: 1 2 3 setInjectedScriptForOrigin(origin, script) { DevToolsAPI.sendMessageToEmbedder(&#39;registerExtensionsAPI&#39;, [origin, script], null); } it can be seen that it takes two arguments: an origin and a script. As an example, if you make the following call in a DevTools context: 1 InspectorFrontendHost.setInjectedScriptForOrigin(&quot;https://en.wikipedia.org&quot;, &quot;console.log(&#39;Script run in &#39; + location.href)//&quot;); Note that the script argument here ends in a comment, since the code that’s injected into the frame will have (“…guid…”) added onto the end of it. Without the comment, this would result in: console.log(...)(&quot;...guid...&quot;), which isn’t valid. and then load the appropriate iframe: 1 2 3 let iframe = document.createElement(&quot;iframe&quot;); iframe.src = &quot;https://en.wikipedia.org/wiki/Main_Page&quot;; document.body.appendChild(iframe); you should expect to see the following message in the console once the frame has loaded: 1 Script run in https://en.wikipedia.org/wiki/Main_Page Therefore, if you can run code within the context of the DevTools, you can script any site you can load in an iframe. This includes any http/https website (provided the particular page you’re attempting to load isn’t blocked by the frame-ancestors content security policy directive). It also includes any extension page, even those not listed under web_accessible_resources. The reason for that is that the DevTools has the ability to load any extension resource. One reason that’s important is that without that exception, the page listed under devtools_page would have to be web accessible for the DevTools to load it. Being able to script any extension is potentially very useful, as it means you can also script builtin extensions and those extensions typically have access to private APIs, giving you further options to escalate privileges (such a case is also described further below). The Chrome DevTools Protocol As mentioned above, the Chrome DevTools Protocol is what powers the DevTools functionality internally. The DevTools frontend is essentially a UI built on top of the Chrome DevTools Protocol and the DevTools relies on this protocol to implement the bulk of its functionality. If you can run code within the context of a DevTools instance, while that instance is attached to a page, you can then script any page, no matter how privileged. Unlike an extension using the debugger API, which will be detached when the target page is navigated to a privileged location, the DevTools has the ability to debug any page. Not only can you script any page, you also have full access to the Chrome DevTools Protocol. That means that you can call methods that extensions can’t - such as Browser.setDownloadBehavior. There’s a distinction here between being attached to a page and not being attached. When you open the DevTools in a tab (e.g. using Ctrl + Shift + I or F12), the DevTools is attached, via a debugging session, to the page loaded within that tab. On the other hand, if you load a DevTools URL within the browser directly, that DevTools instance won’t be attached to anything, so you won’t be able to make use of the Chrome DevTools Protocol. Escaping the sandbox Given all of the above, there are at least two ways you can escape the browser’s sandbox: By targeting an extension The first would be to use the fact that the DevTools can script any extension to attack a higher privileged extension. In the case of Edge, the Edge Feedback App has access to a chrome.edgeFeedbackPrivate API. Previously, this API had a method named saveBytesToFile. Because that method didn’t validate paths it received, it was possible to write a file to an arbitrary location using it. That could be used, for example, to save an executable into the user’s startup folder, which would then be run on the next login. That specific issue in the Edge Feedback App is now fixed, and further more, it’s no longer possible to load App pages in regular tabs either. In terms of finding potentially vulnerable extensions, chrome://extensions-internals is very useful. It contains a list of all extensions currently loaded in the browser. You can use it to see which component (builtin) extensions are loaded, which isn’t something that’s shown on chrome://extensions. Once you’ve identified a particular extension you’d like to investigate, you can load a page from that extension, then check what APIs are available to it. By using the Chrome DevTools Protocol Since the Chrome DevTools Protocol is only available if the DevTools is actually attached to a page, there are only two feasible ways of making use of that functionality: The user would need to open the DevTools manually, or The extension would need to open the DevTools - for example, by sending the F12 key event using the Input.dispatchKeyEvent DevTools Protocol method. This would require that the extension have the debugger permission. A relatively simple way of escaping the sandbox once you can run code within a DevTools context and have the ability to open an attached DevTools instance is to go through the following steps: Add a console pin within the DevTools. This can be done easily using the following code: 1 2 let pin = &quot;...&quot;; // Contains the code to run localStorage.consolePins = JSON.stringify([pin]); This doesn’t depend at all on having a DevTools instance that’s attached to a page. So provided that you can script the DevTools, you can immediately add a console pin. Note there is a slight difference in terminology here. While the localStorage key is called consolePins, a console pin is referred to as a “live expression” in the DevTools UI. Open an attached DevTools instance, through one of the two ways described above. Navigate the page being debugged to chrome://downloads. The downloads page is an interesting case, as it’s one of the very few places in the browser where a local file can be legitimately opened. That means that it’s an ideal end-stage attack target. To actually open a file, you’ll need to call the OpenFileRequiringGesture mojo method that’s available to that page. As the name of that method suggests, a recent user gesture is required to successfully invoke the method. More specifically, a user gesture needs to have been received within the last five seconds. This can be accomplished by sending a key event using Input.dispatchKeyEvent, which you’ll need to do anyway if you open the DevTools using an extension with the debugger permission. The console pin added in step 1 will be regularly re-evaluated on the target page. This means that any code you add to the pin will be run within the context of chrome://downloads, since that’s what the target page was navigated to in step 3. The pin can then call OpenFileRequiringGesture to open an executable that’s been downloaded. This is essentially an indirect use of the Chrome DevTools Protocol, since the console pins functionality internally uses Runtime.evaluate to evaluate the code for any pins within the context of the target page. Conclusion This hopefully provides an overview of some of the attack surface present within the DevTools and how it might be exploited. The DevTools itself is fairly complex and contains a lot of functionality, which creates the opportunity for exploitable issues. Several example issues are given above that allowed an extension to run code within the context of the DevTools. As is shown, being able to do this may allow an extension to read local files, script other extensions and ultimately escape the sandbox. Finally, in terms of reward amounts, the issue with the Edge Feedback App was assessed as being a moderate severity issue and therefore wasn’t eligible for a reward (at present, only higher severity issues are rewarded under the Microsoft Edge Bounty Program). The remoteBase issue described above was rewarded $30,000 USD by Microsoft. With the addition of the other two Chromium issues I filed and described above (issue 1059577 and issue 1064519), the total amount rewarded was $36,000 USD. Which shows that finding and reporting these sorts of issues definitely has value. Source code references One of the main difficulties with trying to understand this sort of functionality within Chromium is trying to find the relevant source code. Due to the size of the Chromium codebase, this can be non-trivial at times. To make it easier to get a foothold in this area, here are some links to relevant source code: The DevTools frontend: https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/ This contains the TypeScript code used for the DevTools frontend. If you’re investigating functionality provided by the frontend, this is where you’ll want to look. ExtensionServer.ts: https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/models/extensions/ExtensionServer.ts;drc=d662bdf64b7d5168e7746f0cecf74598ec2ed445 This is the code that handles messages sent from an extension’s DevTools page, in order to implement the chrome.devtools functionality. ExtensionAPI.ts: https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/models/extensions/ExtensionAPI.ts;drc=d662bdf64b7d5168e7746f0cecf74598ec2ed445 This is the client-side implementation of ExtensionServer.ts. In other words, the code in this file is loaded within an extension’s DevTools page and is what’s responsible for sending channel messages to the DevTools. The browser-side DevTools functionality implementation: https://source.chromium.org/chromium/chromium/src/+/main:chrome/browser/devtools/ This directory contains C++ code that implements various DevTools functionality on the browser-side. For example, DevToolsWindow::Create is what creates a browser window for a DevTools instance. The Chrome DevTools Protocol documentation: https://chromedevtools.github.io/devtools-protocol/ Contains a listing of all methods available within the Chrome DevTools Protocol, though an extension won’t necessarily be able to call all of the methods. The bulk of the browser-side implementation of the Chrome DevTools Protocol: https://source.chromium.org/chromium/chromium/src/+/main:content/browser/devtools/protocol/ Note that not all of the Chrome DevTools Protocol is implemented here. For example, some methods are implemented renderer-side. Reading through the implementation for a DevTools Protocol method can be very useful, both to determine exactly what the DevTools is doing, as well as to determine what an extension with the debugger permission can do." /><meta property="og:description" content="In this post, we’ve invited David Erceg, one of the participants in the Edge bug bounty program, to talk about interesting bugs he found in Edge. By sharing this information, we hope more security researchers are motivated to work with us to improve the security of Edge and Chromium as a whole. Introduction Within Chromium and its derivatives, the DevTools is an interesting attack surface. That’s because the DevTools itself is fairly highly privileged, especially if it’s attached to a page as part of a debugging session. Therefore, bugs within the DevTools can allow a malicious extension to escalate its privileges. That’s because an extension may have the ability to load DevTools URLs and once an extension can do that, it can potentially take advantage of any bugs that are present. The post here will examine how an extension could, in previous versions of Chrome/Edge, run code within the context of the DevTools and how the ability to do that could allow the extension to run code outside of the browser’s sandbox. Running code within the DevTools There have been at least several past issues that would allow an extension to run code within the context of the DevTools. Using the remoteBase query parameter One issue in Edge involved the use of the remoteBase query parameter. That parameter can be used to indicate that a resource should be loaded from a particular external location. However, it’s important that the parameter is validated. A simple example that illustrates why that’s so important is something like the following URL: devtools://devtools/bundled/inspector.html?remoteBase=javascript:... If the remoteBase parameter is used to add an iframe to inspector.html, then in the case above, the iframe will point to a javascript: URL and will be same-origin with its parent. That, essentially, is the issue that was present in the DevTools within Edge. The first step to finding this issue was to note the following URL showed up when opening the DevTools while logging requests passed through the webRequest API: https://devtools.azureedge.net/serve_file/@3bb5c9989b78b4fcfd356345ac1b4c0d626baefa/third_party/webhint/worker_frame.html On a side note, this can be a very useful technique to find requests that are improperly visible from privileged pages. If you create an extension that logs all requests passed to chrome.webRequest.onBeforeRequest, then load a privileged page, you might find instances where a privileged page is loading an unprivileged page in a frame. Using the webRequest API you could then redirect those requests to a page you control. If there are any issues with message passing between the frame and its privileged parent, you might then be able to run code within the context of the parent. The next step after noting that the DevTools was loading the above URL was to try and track down precisely how that was done. It’s simple enough to debug a DevTools window. If, for example, you have a DevTools window opened on a tab, you can first undock that instance, then press Ctrl + Shift + I to debug that instance of the DevTools. That allows you to browse and debug the JavaScript code associated with the DevTools. An issue at this point is that the JavaScript code is minified. If you’re examining the DevTools in Chrome, it’s simple enough to look at the original source via https://source.chromium.org. On Edge, that’s not possible, but you can still debug through the code to get an idea of what’s happening. In the case above, debugging through the code fairly quickly lead to the insight that the URL above was being constructed directly from the remoteBase parameter without any validation. Performing a quick test with the following URL confirmed that that was the case: devtools://devtools/bundled/inspector.html?remoteBase=javascript:console.log(&#39;Frame content set by query parameter&#39;)// Note that the javascript: portion of the URL here ends in a comment, since the DevTools will append “third_party/webhint/worker_frame.html” onto the end of the base URL that’s set. One thing to note is that this general issue has also affected Chromium in the past. For example, a very similar problem was first reported in issue 571121. The fix made there was then shown to be insufficient in issue 619414. Using a devtools_page entry The devtools_page manifest entry refers to an extension page that’s loaded in an iframe within the DevTools and has access to the three chrome.devtools APIs (chrome.devtools.inspectedWindow, chrome.devtools.network and chrome.devtools.panels). As in the case above, where the remoteBase query parameter wasn’t being validated, it used to be the case in Chromium that the devtools_page entry wasn’t being validated either. This meant that if you set the devtools_page entry to a javascript: URL, Chromium would load that URL in an iframe within the DevTools. That frame would then have the ability to script the parent DevTools instance. Using a devtools_page entry and the debugger permission The devtools_page manifest entry and debugger permission make a powerful combination. For context, the debugger permission allows an extension to use the Chrome DevTools Protocol to debug a page. This protocol is also what’s used internally by the DevTools, though an extension doesn’t have access to the full set of methods (e.g. Browser.setDownloadBehavior is restricted). The reason these two features are so powerful together is that an extension with the debugger permission can dispatch input events, including browser shortcuts and, more specifically, the browser shortcut to open the DevTools. That means that an extension with the debugger permission can open the DevTools and the extension’s DevTools page can then script the target page, potentially in cases where the page isn’t accessible via the debugger permission. Previously, there were no restrictions on when an extension page could script the target page (by using, for example, chrome.devtools.inspectedWindow.eval). This meant that if the DevTools was opened on a tab and the tab was navigated to a privileged page, any extension page that was loaded within the DevTools would be able to script that privileged page. Since an extension with the debugger permission can open the DevTools, it could then run code on any privileged page, including a DevTools page, using a devtools_page entry. Sending a series of crafted messages from an extension’s DevTools page Internally, the DevTools relies on the channel messaging API to provide the functionality available in the chrome.devtools API. This is something that’s markedly different from every other extension API, where the implementation is written in C++ and run within the browser process. Since the chrome.devtools API relies on channel messaging between two JavaScript contexts (the extension page context and the DevTools context), that provides a unique opportunity for potential issues. For example, if the DevTools doesn’t properly validate the messages it receives from an extension page, there’s the potential for privilege escalation. That is, the extension page might be able to run arbitrary code within the DevTools. Issue 1064519 describes a case in which that was possible. That particular issue took a while to fully develop. While it was clear after reading through some of the JavaScript code used by the DevTools that values could be overwritten, it wasn’t immediately clear how to fully take advantage of that. A central problem is that you can really only pass data over a MessageChannel, not code. So while you might be able to overwrite a value in a target context, if that context isn’t properly validating messages it receives, you can’t directly invoke any code. However, one thing an extension page can do is use chrome.devtools.panels.create to create a panel. That panel will be created within the DevTools and will contain the page that’s specified by the extension in an iframe. Crucially, the full path to the page is constructed by appending the page’s path to the extension’s origin and the origin is something that’s stored in JavaScript by the DevTools. Because of how the origin was being stored, it could be overwritten by sending a specially crafted channel message. By setting the origin to a javascript: URL, an extension could then cause the DevTools to create an iframe with that URL set as its source, allowing the extension to script the DevTools. Privileges granted to the DevTools Once an extension can run code within the context of the DevTools, the next natural step is to determine precisely what that allows. Read local files To begin with, the DevTools can read local files. The method to do that is documented in several different Chromium issues. For reference, the following code, when run within the context of the DevTools, will log the contents of file:///c:/: 1 2 3 4 5 6 7 8 9 10 11 let data = &quot;&quot;; DevToolsAPI.streamWrite = function (id, chunk) { data += chunk; }; DevToolsAPI.sendMessageToEmbedder(&quot;loadNetworkResource&quot;, [&quot;file:///c:/&quot;, &quot;&quot;, 0], function (result) { console.log(data); } ); Script extensions and arbitrary sites In addition to the Chrome Devtools Protocol, the DevTools also has access to a set of custom API methods. One of those methods is registerExtensionsAPI. As the name of the method suggests, this particular method is used to setup extension pages (i.e. the devtools_page entries) within the DevTools. As discussed above, the chrome.devtools API is implemented using the channel messaging API. That means that the DevTools contains code to process messages it receives. However, when you call the chrome.devtools API from an extension’s DevTools page, you won’t need to use the channel messaging API at all. The reason for that is that the DevTools injects a script into an extension frame on every navigation of that frame. That script is what then uses channel messaging behind the scenes. Looking at how registerExtensionsAPI is called: 1 2 3 setInjectedScriptForOrigin(origin, script) { DevToolsAPI.sendMessageToEmbedder(&#39;registerExtensionsAPI&#39;, [origin, script], null); } it can be seen that it takes two arguments: an origin and a script. As an example, if you make the following call in a DevTools context: 1 InspectorFrontendHost.setInjectedScriptForOrigin(&quot;https://en.wikipedia.org&quot;, &quot;console.log(&#39;Script run in &#39; + location.href)//&quot;); Note that the script argument here ends in a comment, since the code that’s injected into the frame will have (“…guid…”) added onto the end of it. Without the comment, this would result in: console.log(...)(&quot;...guid...&quot;), which isn’t valid. and then load the appropriate iframe: 1 2 3 let iframe = document.createElement(&quot;iframe&quot;); iframe.src = &quot;https://en.wikipedia.org/wiki/Main_Page&quot;; document.body.appendChild(iframe); you should expect to see the following message in the console once the frame has loaded: 1 Script run in https://en.wikipedia.org/wiki/Main_Page Therefore, if you can run code within the context of the DevTools, you can script any site you can load in an iframe. This includes any http/https website (provided the particular page you’re attempting to load isn’t blocked by the frame-ancestors content security policy directive). It also includes any extension page, even those not listed under web_accessible_resources. The reason for that is that the DevTools has the ability to load any extension resource. One reason that’s important is that without that exception, the page listed under devtools_page would have to be web accessible for the DevTools to load it. Being able to script any extension is potentially very useful, as it means you can also script builtin extensions and those extensions typically have access to private APIs, giving you further options to escalate privileges (such a case is also described further below). The Chrome DevTools Protocol As mentioned above, the Chrome DevTools Protocol is what powers the DevTools functionality internally. The DevTools frontend is essentially a UI built on top of the Chrome DevTools Protocol and the DevTools relies on this protocol to implement the bulk of its functionality. If you can run code within the context of a DevTools instance, while that instance is attached to a page, you can then script any page, no matter how privileged. Unlike an extension using the debugger API, which will be detached when the target page is navigated to a privileged location, the DevTools has the ability to debug any page. Not only can you script any page, you also have full access to the Chrome DevTools Protocol. That means that you can call methods that extensions can’t - such as Browser.setDownloadBehavior. There’s a distinction here between being attached to a page and not being attached. When you open the DevTools in a tab (e.g. using Ctrl + Shift + I or F12), the DevTools is attached, via a debugging session, to the page loaded within that tab. On the other hand, if you load a DevTools URL within the browser directly, that DevTools instance won’t be attached to anything, so you won’t be able to make use of the Chrome DevTools Protocol. Escaping the sandbox Given all of the above, there are at least two ways you can escape the browser’s sandbox: By targeting an extension The first would be to use the fact that the DevTools can script any extension to attack a higher privileged extension. In the case of Edge, the Edge Feedback App has access to a chrome.edgeFeedbackPrivate API. Previously, this API had a method named saveBytesToFile. Because that method didn’t validate paths it received, it was possible to write a file to an arbitrary location using it. That could be used, for example, to save an executable into the user’s startup folder, which would then be run on the next login. That specific issue in the Edge Feedback App is now fixed, and further more, it’s no longer possible to load App pages in regular tabs either. In terms of finding potentially vulnerable extensions, chrome://extensions-internals is very useful. It contains a list of all extensions currently loaded in the browser. You can use it to see which component (builtin) extensions are loaded, which isn’t something that’s shown on chrome://extensions. Once you’ve identified a particular extension you’d like to investigate, you can load a page from that extension, then check what APIs are available to it. By using the Chrome DevTools Protocol Since the Chrome DevTools Protocol is only available if the DevTools is actually attached to a page, there are only two feasible ways of making use of that functionality: The user would need to open the DevTools manually, or The extension would need to open the DevTools - for example, by sending the F12 key event using the Input.dispatchKeyEvent DevTools Protocol method. This would require that the extension have the debugger permission. A relatively simple way of escaping the sandbox once you can run code within a DevTools context and have the ability to open an attached DevTools instance is to go through the following steps: Add a console pin within the DevTools. This can be done easily using the following code: 1 2 let pin = &quot;...&quot;; // Contains the code to run localStorage.consolePins = JSON.stringify([pin]); This doesn’t depend at all on having a DevTools instance that’s attached to a page. So provided that you can script the DevTools, you can immediately add a console pin. Note there is a slight difference in terminology here. While the localStorage key is called consolePins, a console pin is referred to as a “live expression” in the DevTools UI. Open an attached DevTools instance, through one of the two ways described above. Navigate the page being debugged to chrome://downloads. The downloads page is an interesting case, as it’s one of the very few places in the browser where a local file can be legitimately opened. That means that it’s an ideal end-stage attack target. To actually open a file, you’ll need to call the OpenFileRequiringGesture mojo method that’s available to that page. As the name of that method suggests, a recent user gesture is required to successfully invoke the method. More specifically, a user gesture needs to have been received within the last five seconds. This can be accomplished by sending a key event using Input.dispatchKeyEvent, which you’ll need to do anyway if you open the DevTools using an extension with the debugger permission. The console pin added in step 1 will be regularly re-evaluated on the target page. This means that any code you add to the pin will be run within the context of chrome://downloads, since that’s what the target page was navigated to in step 3. The pin can then call OpenFileRequiringGesture to open an executable that’s been downloaded. This is essentially an indirect use of the Chrome DevTools Protocol, since the console pins functionality internally uses Runtime.evaluate to evaluate the code for any pins within the context of the target page. Conclusion This hopefully provides an overview of some of the attack surface present within the DevTools and how it might be exploited. The DevTools itself is fairly complex and contains a lot of functionality, which creates the opportunity for exploitable issues. Several example issues are given above that allowed an extension to run code within the context of the DevTools. As is shown, being able to do this may allow an extension to read local files, script other extensions and ultimately escape the sandbox. Finally, in terms of reward amounts, the issue with the Edge Feedback App was assessed as being a moderate severity issue and therefore wasn’t eligible for a reward (at present, only higher severity issues are rewarded under the Microsoft Edge Bounty Program). The remoteBase issue described above was rewarded $30,000 USD by Microsoft. With the addition of the other two Chromium issues I filed and described above (issue 1059577 and issue 1064519), the total amount rewarded was $36,000 USD. Which shows that finding and reporting these sorts of issues definitely has value. Source code references One of the main difficulties with trying to understand this sort of functionality within Chromium is trying to find the relevant source code. Due to the size of the Chromium codebase, this can be non-trivial at times. To make it easier to get a foothold in this area, here are some links to relevant source code: The DevTools frontend: https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/ This contains the TypeScript code used for the DevTools frontend. If you’re investigating functionality provided by the frontend, this is where you’ll want to look. ExtensionServer.ts: https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/models/extensions/ExtensionServer.ts;drc=d662bdf64b7d5168e7746f0cecf74598ec2ed445 This is the code that handles messages sent from an extension’s DevTools page, in order to implement the chrome.devtools functionality. ExtensionAPI.ts: https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/models/extensions/ExtensionAPI.ts;drc=d662bdf64b7d5168e7746f0cecf74598ec2ed445 This is the client-side implementation of ExtensionServer.ts. In other words, the code in this file is loaded within an extension’s DevTools page and is what’s responsible for sending channel messages to the DevTools. The browser-side DevTools functionality implementation: https://source.chromium.org/chromium/chromium/src/+/main:chrome/browser/devtools/ This directory contains C++ code that implements various DevTools functionality on the browser-side. For example, DevToolsWindow::Create is what creates a browser window for a DevTools instance. The Chrome DevTools Protocol documentation: https://chromedevtools.github.io/devtools-protocol/ Contains a listing of all methods available within the Chrome DevTools Protocol, though an extension won’t necessarily be able to call all of the methods. The bulk of the browser-side implementation of the Chrome DevTools Protocol: https://source.chromium.org/chromium/chromium/src/+/main:content/browser/devtools/protocol/ Note that not all of the Chrome DevTools Protocol is implemented here. For example, some methods are implemented renderer-side. Reading through the implementation for a DevTools Protocol method can be very useful, both to determine exactly what the DevTools is doing, as well as to determine what an extension with the debugger permission can do." /><link rel="canonical" href="https://microsoftedge.github.io/edgevr/posts/attacking-the-devtools/" /><meta property="og:url" content="https://microsoftedge.github.io/edgevr/posts/attacking-the-devtools/" /><meta property="og:site_name" content="Microsoft Browser Vulnerability Research" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-07-21T09:00:00-07:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Guest Blog Post - Attacking the DevTools" /><meta name="twitter:site" content="@MSEdgeDev" /><meta name="twitter:creator" content="@David Erceg" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"David Erceg"},"description":"In this post, we’ve invited David Erceg, one of the participants in the Edge bug bounty program, to talk about interesting bugs he found in Edge. By sharing this information, we hope more security researchers are motivated to work with us to improve the security of Edge and Chromium as a whole. Introduction Within Chromium and its derivatives, the DevTools is an interesting attack surface. That’s because the DevTools itself is fairly highly privileged, especially if it’s attached to a page as part of a debugging session. Therefore, bugs within the DevTools can allow a malicious extension to escalate its privileges. That’s because an extension may have the ability to load DevTools URLs and once an extension can do that, it can potentially take advantage of any bugs that are present. The post here will examine how an extension could, in previous versions of Chrome/Edge, run code within the context of the DevTools and how the ability to do that could allow the extension to run code outside of the browser’s sandbox. Running code within the DevTools There have been at least several past issues that would allow an extension to run code within the context of the DevTools. Using the remoteBase query parameter One issue in Edge involved the use of the remoteBase query parameter. That parameter can be used to indicate that a resource should be loaded from a particular external location. However, it’s important that the parameter is validated. A simple example that illustrates why that’s so important is something like the following URL: devtools://devtools/bundled/inspector.html?remoteBase=javascript:... If the remoteBase parameter is used to add an iframe to inspector.html, then in the case above, the iframe will point to a javascript: URL and will be same-origin with its parent. That, essentially, is the issue that was present in the DevTools within Edge. The first step to finding this issue was to note the following URL showed up when opening the DevTools while logging requests passed through the webRequest API: https://devtools.azureedge.net/serve_file/@3bb5c9989b78b4fcfd356345ac1b4c0d626baefa/third_party/webhint/worker_frame.html On a side note, this can be a very useful technique to find requests that are improperly visible from privileged pages. If you create an extension that logs all requests passed to chrome.webRequest.onBeforeRequest, then load a privileged page, you might find instances where a privileged page is loading an unprivileged page in a frame. Using the webRequest API you could then redirect those requests to a page you control. If there are any issues with message passing between the frame and its privileged parent, you might then be able to run code within the context of the parent. The next step after noting that the DevTools was loading the above URL was to try and track down precisely how that was done. It’s simple enough to debug a DevTools window. If, for example, you have a DevTools window opened on a tab, you can first undock that instance, then press Ctrl + Shift + I to debug that instance of the DevTools. That allows you to browse and debug the JavaScript code associated with the DevTools. An issue at this point is that the JavaScript code is minified. If you’re examining the DevTools in Chrome, it’s simple enough to look at the original source via https://source.chromium.org. On Edge, that’s not possible, but you can still debug through the code to get an idea of what’s happening. In the case above, debugging through the code fairly quickly lead to the insight that the URL above was being constructed directly from the remoteBase parameter without any validation. Performing a quick test with the following URL confirmed that that was the case: devtools://devtools/bundled/inspector.html?remoteBase=javascript:console.log(&#39;Frame content set by query parameter&#39;)// Note that the javascript: portion of the URL here ends in a comment, since the DevTools will append “third_party/webhint/worker_frame.html” onto the end of the base URL that’s set. One thing to note is that this general issue has also affected Chromium in the past. For example, a very similar problem was first reported in issue 571121. The fix made there was then shown to be insufficient in issue 619414. Using a devtools_page entry The devtools_page manifest entry refers to an extension page that’s loaded in an iframe within the DevTools and has access to the three chrome.devtools APIs (chrome.devtools.inspectedWindow, chrome.devtools.network and chrome.devtools.panels). As in the case above, where the remoteBase query parameter wasn’t being validated, it used to be the case in Chromium that the devtools_page entry wasn’t being validated either. This meant that if you set the devtools_page entry to a javascript: URL, Chromium would load that URL in an iframe within the DevTools. That frame would then have the ability to script the parent DevTools instance. Using a devtools_page entry and the debugger permission The devtools_page manifest entry and debugger permission make a powerful combination. For context, the debugger permission allows an extension to use the Chrome DevTools Protocol to debug a page. This protocol is also what’s used internally by the DevTools, though an extension doesn’t have access to the full set of methods (e.g. Browser.setDownloadBehavior is restricted). The reason these two features are so powerful together is that an extension with the debugger permission can dispatch input events, including browser shortcuts and, more specifically, the browser shortcut to open the DevTools. That means that an extension with the debugger permission can open the DevTools and the extension’s DevTools page can then script the target page, potentially in cases where the page isn’t accessible via the debugger permission. Previously, there were no restrictions on when an extension page could script the target page (by using, for example, chrome.devtools.inspectedWindow.eval). This meant that if the DevTools was opened on a tab and the tab was navigated to a privileged page, any extension page that was loaded within the DevTools would be able to script that privileged page. Since an extension with the debugger permission can open the DevTools, it could then run code on any privileged page, including a DevTools page, using a devtools_page entry. Sending a series of crafted messages from an extension’s DevTools page Internally, the DevTools relies on the channel messaging API to provide the functionality available in the chrome.devtools API. This is something that’s markedly different from every other extension API, where the implementation is written in C++ and run within the browser process. Since the chrome.devtools API relies on channel messaging between two JavaScript contexts (the extension page context and the DevTools context), that provides a unique opportunity for potential issues. For example, if the DevTools doesn’t properly validate the messages it receives from an extension page, there’s the potential for privilege escalation. That is, the extension page might be able to run arbitrary code within the DevTools. Issue 1064519 describes a case in which that was possible. That particular issue took a while to fully develop. While it was clear after reading through some of the JavaScript code used by the DevTools that values could be overwritten, it wasn’t immediately clear how to fully take advantage of that. A central problem is that you can really only pass data over a MessageChannel, not code. So while you might be able to overwrite a value in a target context, if that context isn’t properly validating messages it receives, you can’t directly invoke any code. However, one thing an extension page can do is use chrome.devtools.panels.create to create a panel. That panel will be created within the DevTools and will contain the page that’s specified by the extension in an iframe. Crucially, the full path to the page is constructed by appending the page’s path to the extension’s origin and the origin is something that’s stored in JavaScript by the DevTools. Because of how the origin was being stored, it could be overwritten by sending a specially crafted channel message. By setting the origin to a javascript: URL, an extension could then cause the DevTools to create an iframe with that URL set as its source, allowing the extension to script the DevTools. Privileges granted to the DevTools Once an extension can run code within the context of the DevTools, the next natural step is to determine precisely what that allows. Read local files To begin with, the DevTools can read local files. The method to do that is documented in several different Chromium issues. For reference, the following code, when run within the context of the DevTools, will log the contents of file:///c:/: 1 2 3 4 5 6 7 8 9 10 11 let data = &quot;&quot;; DevToolsAPI.streamWrite = function (id, chunk) { data += chunk; }; DevToolsAPI.sendMessageToEmbedder(&quot;loadNetworkResource&quot;, [&quot;file:///c:/&quot;, &quot;&quot;, 0], function (result) { console.log(data); } ); Script extensions and arbitrary sites In addition to the Chrome Devtools Protocol, the DevTools also has access to a set of custom API methods. One of those methods is registerExtensionsAPI. As the name of the method suggests, this particular method is used to setup extension pages (i.e. the devtools_page entries) within the DevTools. As discussed above, the chrome.devtools API is implemented using the channel messaging API. That means that the DevTools contains code to process messages it receives. However, when you call the chrome.devtools API from an extension’s DevTools page, you won’t need to use the channel messaging API at all. The reason for that is that the DevTools injects a script into an extension frame on every navigation of that frame. That script is what then uses channel messaging behind the scenes. Looking at how registerExtensionsAPI is called: 1 2 3 setInjectedScriptForOrigin(origin, script) { DevToolsAPI.sendMessageToEmbedder(&#39;registerExtensionsAPI&#39;, [origin, script], null); } it can be seen that it takes two arguments: an origin and a script. As an example, if you make the following call in a DevTools context: 1 InspectorFrontendHost.setInjectedScriptForOrigin(&quot;https://en.wikipedia.org&quot;, &quot;console.log(&#39;Script run in &#39; + location.href)//&quot;); Note that the script argument here ends in a comment, since the code that’s injected into the frame will have (“…guid…”) added onto the end of it. Without the comment, this would result in: console.log(...)(&quot;...guid...&quot;), which isn’t valid. and then load the appropriate iframe: 1 2 3 let iframe = document.createElement(&quot;iframe&quot;); iframe.src = &quot;https://en.wikipedia.org/wiki/Main_Page&quot;; document.body.appendChild(iframe); you should expect to see the following message in the console once the frame has loaded: 1 Script run in https://en.wikipedia.org/wiki/Main_Page Therefore, if you can run code within the context of the DevTools, you can script any site you can load in an iframe. This includes any http/https website (provided the particular page you’re attempting to load isn’t blocked by the frame-ancestors content security policy directive). It also includes any extension page, even those not listed under web_accessible_resources. The reason for that is that the DevTools has the ability to load any extension resource. One reason that’s important is that without that exception, the page listed under devtools_page would have to be web accessible for the DevTools to load it. Being able to script any extension is potentially very useful, as it means you can also script builtin extensions and those extensions typically have access to private APIs, giving you further options to escalate privileges (such a case is also described further below). The Chrome DevTools Protocol As mentioned above, the Chrome DevTools Protocol is what powers the DevTools functionality internally. The DevTools frontend is essentially a UI built on top of the Chrome DevTools Protocol and the DevTools relies on this protocol to implement the bulk of its functionality. If you can run code within the context of a DevTools instance, while that instance is attached to a page, you can then script any page, no matter how privileged. Unlike an extension using the debugger API, which will be detached when the target page is navigated to a privileged location, the DevTools has the ability to debug any page. Not only can you script any page, you also have full access to the Chrome DevTools Protocol. That means that you can call methods that extensions can’t - such as Browser.setDownloadBehavior. There’s a distinction here between being attached to a page and not being attached. When you open the DevTools in a tab (e.g. using Ctrl + Shift + I or F12), the DevTools is attached, via a debugging session, to the page loaded within that tab. On the other hand, if you load a DevTools URL within the browser directly, that DevTools instance won’t be attached to anything, so you won’t be able to make use of the Chrome DevTools Protocol. Escaping the sandbox Given all of the above, there are at least two ways you can escape the browser’s sandbox: By targeting an extension The first would be to use the fact that the DevTools can script any extension to attack a higher privileged extension. In the case of Edge, the Edge Feedback App has access to a chrome.edgeFeedbackPrivate API. Previously, this API had a method named saveBytesToFile. Because that method didn’t validate paths it received, it was possible to write a file to an arbitrary location using it. That could be used, for example, to save an executable into the user’s startup folder, which would then be run on the next login. That specific issue in the Edge Feedback App is now fixed, and further more, it’s no longer possible to load App pages in regular tabs either. In terms of finding potentially vulnerable extensions, chrome://extensions-internals is very useful. It contains a list of all extensions currently loaded in the browser. You can use it to see which component (builtin) extensions are loaded, which isn’t something that’s shown on chrome://extensions. Once you’ve identified a particular extension you’d like to investigate, you can load a page from that extension, then check what APIs are available to it. By using the Chrome DevTools Protocol Since the Chrome DevTools Protocol is only available if the DevTools is actually attached to a page, there are only two feasible ways of making use of that functionality: The user would need to open the DevTools manually, or The extension would need to open the DevTools - for example, by sending the F12 key event using the Input.dispatchKeyEvent DevTools Protocol method. This would require that the extension have the debugger permission. A relatively simple way of escaping the sandbox once you can run code within a DevTools context and have the ability to open an attached DevTools instance is to go through the following steps: Add a console pin within the DevTools. This can be done easily using the following code: 1 2 let pin = &quot;...&quot;; // Contains the code to run localStorage.consolePins = JSON.stringify([pin]); This doesn’t depend at all on having a DevTools instance that’s attached to a page. So provided that you can script the DevTools, you can immediately add a console pin. Note there is a slight difference in terminology here. While the localStorage key is called consolePins, a console pin is referred to as a “live expression” in the DevTools UI. Open an attached DevTools instance, through one of the two ways described above. Navigate the page being debugged to chrome://downloads. The downloads page is an interesting case, as it’s one of the very few places in the browser where a local file can be legitimately opened. That means that it’s an ideal end-stage attack target. To actually open a file, you’ll need to call the OpenFileRequiringGesture mojo method that’s available to that page. As the name of that method suggests, a recent user gesture is required to successfully invoke the method. More specifically, a user gesture needs to have been received within the last five seconds. This can be accomplished by sending a key event using Input.dispatchKeyEvent, which you’ll need to do anyway if you open the DevTools using an extension with the debugger permission. The console pin added in step 1 will be regularly re-evaluated on the target page. This means that any code you add to the pin will be run within the context of chrome://downloads, since that’s what the target page was navigated to in step 3. The pin can then call OpenFileRequiringGesture to open an executable that’s been downloaded. This is essentially an indirect use of the Chrome DevTools Protocol, since the console pins functionality internally uses Runtime.evaluate to evaluate the code for any pins within the context of the target page. Conclusion This hopefully provides an overview of some of the attack surface present within the DevTools and how it might be exploited. The DevTools itself is fairly complex and contains a lot of functionality, which creates the opportunity for exploitable issues. Several example issues are given above that allowed an extension to run code within the context of the DevTools. As is shown, being able to do this may allow an extension to read local files, script other extensions and ultimately escape the sandbox. Finally, in terms of reward amounts, the issue with the Edge Feedback App was assessed as being a moderate severity issue and therefore wasn’t eligible for a reward (at present, only higher severity issues are rewarded under the Microsoft Edge Bounty Program). The remoteBase issue described above was rewarded $30,000 USD by Microsoft. With the addition of the other two Chromium issues I filed and described above (issue 1059577 and issue 1064519), the total amount rewarded was $36,000 USD. Which shows that finding and reporting these sorts of issues definitely has value. Source code references One of the main difficulties with trying to understand this sort of functionality within Chromium is trying to find the relevant source code. Due to the size of the Chromium codebase, this can be non-trivial at times. To make it easier to get a foothold in this area, here are some links to relevant source code: The DevTools frontend: https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/ This contains the TypeScript code used for the DevTools frontend. If you’re investigating functionality provided by the frontend, this is where you’ll want to look. ExtensionServer.ts: https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/models/extensions/ExtensionServer.ts;drc=d662bdf64b7d5168e7746f0cecf74598ec2ed445 This is the code that handles messages sent from an extension’s DevTools page, in order to implement the chrome.devtools functionality. ExtensionAPI.ts: https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/models/extensions/ExtensionAPI.ts;drc=d662bdf64b7d5168e7746f0cecf74598ec2ed445 This is the client-side implementation of ExtensionServer.ts. In other words, the code in this file is loaded within an extension’s DevTools page and is what’s responsible for sending channel messages to the DevTools. The browser-side DevTools functionality implementation: https://source.chromium.org/chromium/chromium/src/+/main:chrome/browser/devtools/ This directory contains C++ code that implements various DevTools functionality on the browser-side. For example, DevToolsWindow::Create is what creates a browser window for a DevTools instance. The Chrome DevTools Protocol documentation: https://chromedevtools.github.io/devtools-protocol/ Contains a listing of all methods available within the Chrome DevTools Protocol, though an extension won’t necessarily be able to call all of the methods. The bulk of the browser-side implementation of the Chrome DevTools Protocol: https://source.chromium.org/chromium/chromium/src/+/main:content/browser/devtools/protocol/ Note that not all of the Chrome DevTools Protocol is implemented here. For example, some methods are implemented renderer-side. Reading through the implementation for a DevTools Protocol method can be very useful, both to determine exactly what the DevTools is doing, as well as to determine what an extension with the debugger permission can do.","url":"https://microsoftedge.github.io/edgevr/posts/attacking-the-devtools/","@type":"BlogPosting","headline":"Guest Blog Post - Attacking the DevTools","dateModified":"2021-07-21T09:00:00-07:00","datePublished":"2021-07-21T09:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://microsoftedge.github.io/edgevr/posts/attacking-the-devtools/"},"@context":"https://schema.org"}</script> <!-- The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps Generated by: https://www.favicon-generator.org/ v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT license --><link rel="shortcut icon" href="/edgevr/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/edgevr/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/edgevr/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/edgevr/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/edgevr/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/edgevr/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/edgevr/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/edgevr/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/edgevr/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/edgevr/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/edgevr/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/edgevr/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/edgevr/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/edgevr/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/edgevr/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/edgevr/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/edgevr/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/edgevr/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/edgevr/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/edgevr/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"> <!-- CSS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --><link rel="preload" as="style" href="/edgevr/assets/css/post.css"><link rel="stylesheet" href="/edgevr/assets/css/post.css"><link rel="preload" as="style" href="/edgevr/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/edgevr/assets/css/lib/bootstrap-toc.min.css" /><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" async></script> <script type="text/javascript"> (function(c,l,a,r,i,t,y){ c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)}; t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i; y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y); })(window, document, "clarity", "script", "4xpt5cebre"); </script> <!-- JS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --> <script src="/edgevr/assets/js/post.min.js" async></script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script> <script src="/edgevr/app.js" defer></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"> <!-- The Side Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="/edgevr/" alt="avatar"> <img src="/edgevr/assets/img/edge-logo-128x128.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/edgevr/">Microsoft Browser <b>Vulnerability Research</b></a></div><div class="site-subtitle font-italic">News from the lab</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/edgevr/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/edgevr/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/edgevr/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/edgevr/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></li></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper" style="margin-right: 9px;"> <!-- Switch the mode between dark and light. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightkMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightkMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border" style="display:none;"></span> <a href="https://github.com/MicrosoftEdge" target="_blank"> <i class="fab fa-github-alt"></i> </a> <a href="/edgevr/feed.xml" > <i class="fas fa-rss"></i> </a></div></div><!-- The Top Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/edgevr/"> Posts </a> </span> <span>Guest Blog Post - Attacking the DevTools</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"> <!-- Fixed kramdown code highlight rendering: https://github.com/penibelst/jekyll-compress-html/issues/101 https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901 --><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Guest Blog Post - Attacking the DevTools</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jul 21, 2021, 9:00 AM -0700" > Jul 21, 2021 <i class="unloaded">2021-07-21T09:00:00-07:00</i> </span> by <span class="author"> David Erceg <a href="https://twitter.com/david_erceg" title="Author's Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> </span></div><div> Updated <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Jul 21, 2021, 9:12 AM -0700" > Jul 21, 2021 <i class="unloaded">2021-07-21T09:12:49-07:00</i> </span></div></div><div class="post-content"><p><em>In this post, we’ve invited <a href="https://twitter.com/david_erceg">David Erceg</a>, one of the participants in the <a href="https://www.microsoft.com/en-us/msrc/bounty-new-edge">Edge bug bounty program</a>, to talk about interesting bugs he found in Edge.</em></p><p><em>By sharing this information, we hope more security researchers are motivated to work with us to improve the security of Edge and Chromium as a whole.</em></p><h1 id="introduction">Introduction</h1><p>Within Chromium and its derivatives, the DevTools is an interesting attack surface. That’s because the DevTools itself is fairly highly privileged, especially if it’s attached to a page as part of a debugging session.</p><p>Therefore, bugs within the DevTools can allow a malicious extension to escalate its privileges. That’s because an extension may have the ability to load DevTools URLs and once an extension can do that, it can potentially take advantage of any bugs that are present.</p><p>The post here will examine how an extension could, in previous versions of Chrome/Edge, run code within the context of the DevTools and how the ability to do that could allow the extension to run code outside of the browser’s sandbox.</p><h1 id="running-code-within-the-devtools">Running code within the DevTools</h1><p>There have been at least several past issues that would allow an extension to run code within the context of the DevTools.</p><h2 id="using-the-remotebase-query-parameter">Using the remoteBase query parameter</h2><p>One issue in Edge involved the use of the <code class="language-plaintext highlighter-rouge">remoteBase</code> query parameter. That parameter can be used to indicate that a resource should be loaded from a particular external location. However, it’s important that the parameter is validated. A simple example that illustrates why that’s so important is something like the following URL:</p><p><code class="language-plaintext highlighter-rouge">devtools://devtools/bundled/inspector.html?remoteBase=javascript:...</code></p><p>If the <code class="language-plaintext highlighter-rouge">remoteBase</code> parameter is used to add an iframe to inspector.html, then in the case above, the iframe will point to a <code class="language-plaintext highlighter-rouge">javascript:</code> URL and will be same-origin with its parent.</p><p>That, essentially, is the issue that was present in the DevTools within Edge.</p><p>The first step to finding this issue was to note the following URL showed up when opening the DevTools while logging requests passed through the webRequest API:</p><p><code class="language-plaintext highlighter-rouge">https://devtools.azureedge.net/serve_file/@3bb5c9989b78b4fcfd356345ac1b4c0d626baefa/third_party/webhint/worker_frame.html</code></p><blockquote><p>On a side note, this can be a very useful technique to find requests that are improperly visible from privileged pages. If you create an extension that logs all requests passed to <code class="language-plaintext highlighter-rouge">chrome.webRequest.onBeforeRequest</code>, then load a privileged page, you might find instances where a privileged page is loading an unprivileged page in a frame. Using the webRequest API you could then redirect those requests to a page you control. If there are any issues with message passing between the frame and its privileged parent, you might then be able to run code within the context of the parent.</p></blockquote><p>The next step after noting that the DevTools was loading the above URL was to try and track down precisely how that was done.</p><p>It’s simple enough to debug a DevTools window. If, for example, you have a DevTools window opened on a tab, you can first undock that instance, then press <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>I</kbd> to debug that instance of the DevTools. That allows you to browse and debug the JavaScript code associated with the DevTools.</p><p>An issue at this point is that the JavaScript code is minified. If you’re examining the DevTools in Chrome, it’s simple enough to look at the original source via <a href="https://source.chromium.org">https://source.chromium.org</a>. On Edge, that’s not possible, but you can still debug through the code to get an idea of what’s happening.</p><p>In the case above, debugging through the code fairly quickly lead to the insight that the URL above was being constructed directly from the <code class="language-plaintext highlighter-rouge">remoteBase</code> parameter without any validation. Performing a quick test with the following URL confirmed that that was the case:</p><p><code class="language-plaintext highlighter-rouge">devtools://devtools/bundled/inspector.html?remoteBase=javascript:console.log('Frame content set by query parameter')//</code></p><blockquote><p>Note that the <code class="language-plaintext highlighter-rouge">javascript:</code> portion of the URL here ends in a comment, since the DevTools will append “third_party/webhint/worker_frame.html” onto the end of the base URL that’s set.</p></blockquote><p>One thing to note is that this general issue has also affected Chromium in the past. For example, a very similar problem was first reported in issue <a href="https://crbug.com/571121">571121</a>. The fix made there was then shown to be insufficient in issue <a href="https://crbug.com/619414">619414</a>.</p><h2 id="using-a-devtools_page-entry">Using a devtools_page entry</h2><p>The <code class="language-plaintext highlighter-rouge">devtools_page</code> <a href="https://developer.chrome.com/docs/extensions/mv3/devtools/#devtools-page">manifest entry</a> refers to an extension page that’s loaded in an iframe within the DevTools and has access to the three <code class="language-plaintext highlighter-rouge">chrome.devtools</code> APIs (<a href="https://developer.chrome.com/docs/extensions/reference/devtools_inspectedWindow/">chrome.devtools.inspectedWindow</a>, <a href="https://developer.chrome.com/docs/extensions/reference/devtools_network/">chrome.devtools.network</a> and <a href="https://developer.chrome.com/docs/extensions/reference/devtools_panels/">chrome.devtools.panels</a>).</p><p>As in the case above, where the <code class="language-plaintext highlighter-rouge">remoteBase</code> query parameter wasn’t being validated, it used to be the case in Chromium that the <code class="language-plaintext highlighter-rouge">devtools_page</code> entry wasn’t being <a href="https://crbug.com/1059577">validated either</a>. This meant that if you set the <code class="language-plaintext highlighter-rouge">devtools_page</code> entry to a <code class="language-plaintext highlighter-rouge">javascript:</code> URL, Chromium would load that URL in an iframe within the DevTools. That frame would then have the ability to script the parent DevTools instance.</p><h2 id="using-a-devtools_page-entry-and-the-debugger-permission">Using a devtools_page entry and the debugger permission</h2><p>The <code class="language-plaintext highlighter-rouge">devtools_page</code> manifest entry and debugger permission make a powerful combination. For context, the debugger permission allows an extension to use the <a href="https://chromedevtools.github.io/devtools-protocol/">Chrome DevTools Protocol</a> to debug a page. This protocol is also what’s used internally by the DevTools, though an extension doesn’t have access to the full set of methods (e.g. <code class="language-plaintext highlighter-rouge">Browser.setDownloadBehavior</code> is <a href="https://crbug.com/866426">restricted</a>).</p><p>The reason these two features are so powerful together is that an extension with the debugger permission can dispatch input events, including browser shortcuts and, more specifically, the browser shortcut to open the DevTools. That means that an extension with the debugger permission can open the DevTools and the extension’s DevTools page can then script the target page, potentially in cases where the page isn’t accessible via the debugger permission.</p><p>Previously, there were <a href="https://crbug.com/1059577">no</a> <a href="https://crbug.com/795595">restrictions</a> on when an extension page could script the target page (by using, for example, <a href="https://developer.chrome.com/docs/extensions/reference/devtools_inspectedWindow/#method-eval">chrome.devtools.inspectedWindow.eval</a>). This meant that if the DevTools was opened on a tab and the tab was navigated to a privileged page, any extension page that was loaded within the DevTools would be able to script that privileged page. Since an extension with the debugger permission can open the DevTools, it could then run code on any privileged page, including a DevTools page, using a <code class="language-plaintext highlighter-rouge">devtools_page</code> entry.</p><h2 id="sending-a-series-of-crafted-messages-from-an-extensions-devtools-page">Sending a series of crafted messages from an extension’s DevTools page</h2><p>Internally, the DevTools <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/models/extensions/ExtensionAPI.ts;l=947;drc=d662bdf64b7d5168e7746f0cecf74598ec2ed445">relies</a> on the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Channel_Messaging_API">channel messaging API</a> to provide the functionality available in the <code class="language-plaintext highlighter-rouge">chrome.devtools</code> API. This is something that’s markedly different from every other extension API, where the implementation is written in <a href="https://source.chromium.org/chromium/chromium/src/+/main:chrome/browser/extensions/api/">C++</a> and run within the browser process.</p><p>Since the <code class="language-plaintext highlighter-rouge">chrome.devtools</code> API relies on channel messaging between two JavaScript contexts (the extension page context and the DevTools context), that provides a unique opportunity for potential issues. For example, if the DevTools doesn’t properly validate the messages it receives from an extension page, there’s the potential for privilege escalation. That is, the extension page might be able to run arbitrary code within the DevTools.</p><p>Issue <a href="https://crbug.com/1064519">1064519</a> describes a case in which that was possible.</p><p>That particular issue took a while to fully develop. While it was clear after reading through some of the JavaScript code used by the DevTools that values could be overwritten, it wasn’t immediately clear how to fully take advantage of that.</p><p>A central problem is that you can really only pass data over a <code class="language-plaintext highlighter-rouge">MessageChannel</code>, not code. So while you might be able to overwrite a value in a target context, if that context isn’t properly validating messages it receives, you can’t directly invoke any code.</p><p>However, one thing an extension page can do is use <a href="https://developer.chrome.com/docs/extensions/reference/devtools_panels/#method-create">chrome.devtools.panels.create</a> to create a panel. That panel will be created within the DevTools and will contain the page that’s specified by the extension in an iframe.</p><p>Crucially, the full path to the page is constructed by appending the page’s path to the extension’s origin and the origin is something that’s stored in JavaScript by the DevTools. Because of how the origin was being stored, it could be overwritten by sending a specially crafted channel message. By setting the origin to a <code class="language-plaintext highlighter-rouge">javascript:</code> URL, an extension could then cause the DevTools to create an iframe with that URL set as its source, allowing the extension to script the DevTools.</p><h1 id="privileges-granted-to-the-devtools">Privileges granted to the DevTools</h1><p>Once an extension can run code within the context of the DevTools, the next natural step is to determine precisely what that allows.</p><h2 id="read-local-files">Read local files</h2><p>To begin with, the DevTools can read local files. The method to do that is documented in several <a href="https://crbug.com/653134">different</a> <a href="https://crbug.com/662859">Chromium</a> <a href="https://crbug.com/607939">issues</a>. For reference, the following code, when run within the context of the DevTools, will log the contents of <code class="language-plaintext highlighter-rouge">file:///c:/</code>:</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>

<span class="nx">DevToolsAPI</span><span class="p">.</span><span class="nx">streamWrite</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">chunk</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">data</span> <span class="o">+=</span> <span class="nx">chunk</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">DevToolsAPI</span><span class="p">.</span><span class="nx">sendMessageToEmbedder</span><span class="p">(</span><span class="dl">"</span><span class="s2">loadNetworkResource</span><span class="dl">"</span><span class="p">,</span> <span class="p">[</span><span class="dl">"</span><span class="s2">file:///c:/</span><span class="dl">"</span><span class="p">,</span> <span class="dl">""</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="kd">function</span> <span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">);</span>
</pre></table></code></div></div><h2 id="script-extensions-and-arbitrary-sites">Script extensions and arbitrary sites</h2><p>In addition to the Chrome Devtools Protocol, the DevTools also has access to a set of <a href="https://source.chromium.org/chromium/chromium/src/+/main:chrome/browser/devtools/devtools_embedder_message_dispatcher.cc;l=182;drc=a1545e183728a7ee376fd50fcd35de618bbb4b78">custom API methods</a>. One of those methods is <code class="language-plaintext highlighter-rouge">registerExtensionsAPI</code>.</p><p>As the name of the method suggests, this particular method is used to setup extension pages (i.e. the <code class="language-plaintext highlighter-rouge">devtools_page</code> entries) within the DevTools. As discussed above, the <code class="language-plaintext highlighter-rouge">chrome.devtools</code> API is implemented using the channel messaging API. That means that the DevTools contains <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/models/extensions/ExtensionServer.ts;l=876;drc=d662bdf64b7d5168e7746f0cecf74598ec2ed445">code</a> to process messages it receives.</p><p>However, when you call the <code class="language-plaintext highlighter-rouge">chrome.devtools</code> API from an extension’s DevTools page, you won’t need to use the channel messaging API at all. The reason for that is that the DevTools <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/models/extensions/ExtensionServer.ts;l=840;drc=d662bdf64b7d5168e7746f0cecf74598ec2ed445">injects</a> a <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/models/extensions/ExtensionAPI.ts;l=213;drc=d662bdf64b7d5168e7746f0cecf74598ec2ed445">script</a> into an extension frame on every navigation of that frame. That script is what then <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/models/extensions/ExtensionAPI.ts;l=947;drc=d662bdf64b7d5168e7746f0cecf74598ec2ed445">uses</a> channel messaging behind the scenes.</p><p>Looking at how <code class="language-plaintext highlighter-rouge">registerExtensionsAPI</code> is <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/devtools_compatibility.js;l=547;drc=8fc6f1b872679c83b99796bf37b2ec185b8e9332">called</a>:</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nx">setInjectedScriptForOrigin</span><span class="p">(</span><span class="nx">origin</span><span class="p">,</span> <span class="nx">script</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">DevToolsAPI</span><span class="p">.</span><span class="nx">sendMessageToEmbedder</span><span class="p">(</span><span class="dl">'</span><span class="s1">registerExtensionsAPI</span><span class="dl">'</span><span class="p">,</span> <span class="p">[</span><span class="nx">origin</span><span class="p">,</span> <span class="nx">script</span><span class="p">],</span> <span class="kc">null</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>it can be seen that it takes two arguments: an origin and a script.</p><p>As an example, if you make the following call in a DevTools context:</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nx">InspectorFrontendHost</span><span class="p">.</span><span class="nx">setInjectedScriptForOrigin</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://en.wikipedia.org</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">console.log('Script run in ' + location.href)//</span><span class="dl">"</span><span class="p">);</span>
</pre></table></code></div></div><blockquote><p>Note that the script argument here ends in a comment, since the code that’s injected into the frame will have (“…guid…”) <a href="https://source.chromium.org/chromium/chromium/src/+/main:chrome/browser/devtools/devtools_ui_bindings.cc;l=1694-1695;drc=05e487e9af854db7cb73111d92d45df0899325c4">added</a> onto the end of it. Without the comment, this would result in: <code class="language-plaintext highlighter-rouge">console.log(...)("...guid...")</code>, which isn’t valid.</p></blockquote><p>and then load the appropriate iframe:</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">iframe</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">iframe</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">iframe</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">https://en.wikipedia.org/wiki/Main_Page</span><span class="dl">"</span><span class="p">;</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">iframe</span><span class="p">);</span>
</pre></table></code></div></div><p>you should expect to see the following message in the console once the frame has loaded:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>Script run in https://en.wikipedia.org/wiki/Main_Page
</pre></table></code></div></div><p>Therefore, if you can run code within the context of the DevTools, you can script any site you can load in an iframe. This includes any http/https website (provided the particular page you’re attempting to load isn’t blocked by the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors">frame-ancestors</a> content security policy directive).</p><p>It also includes any extension page, even those not listed under <a href="https://developer.chrome.com/docs/extensions/mv3/manifest/web_accessible_resources/">web_accessible_resources</a>. The reason for that is that the DevTools has the <a href="https://source.chromium.org/chromium/chromium/src/+/main:extensions/browser/extension_navigation_throttle.cc;l=266;drc=a1545e183728a7ee376fd50fcd35de618bbb4b78">ability</a> to load any extension resource. One reason that’s important is that without that exception, the page listed under <code class="language-plaintext highlighter-rouge">devtools_page</code> would have to be web accessible for the DevTools to load it.</p><p>Being able to script any extension is potentially very useful, as it means you can also script builtin extensions and those extensions typically have access to private APIs, giving you further options to escalate privileges (such a case is also described further below).</p><h2 id="the-chrome-devtools-protocol">The Chrome DevTools Protocol</h2><p>As mentioned above, the Chrome DevTools Protocol is what powers the DevTools functionality internally. The DevTools frontend is essentially a UI built on top of the Chrome DevTools Protocol and the DevTools relies on this protocol to implement the bulk of its functionality.</p><p>If you can run code within the context of a DevTools instance, while that instance is attached to a page, you can then script any page, no matter how privileged. Unlike an extension using the debugger API, which will be detached when the target page is navigated to a privileged location, the DevTools has the ability to debug any page.</p><p>Not only can you script any page, you also have full access to the Chrome DevTools Protocol. That means that you can call methods that extensions can’t - such as <code class="language-plaintext highlighter-rouge">Browser.setDownloadBehavior</code>.</p><p>There’s a distinction here between being attached to a page and not being attached. When you open the DevTools in a tab (e.g. using <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>I</kbd> or <kbd>F12</kbd>), the DevTools is attached, via a debugging session, to the page loaded within that tab.</p><p>On the other hand, if you load a DevTools URL within the browser directly, that DevTools instance won’t be attached to anything, so you won’t be able to make use of the Chrome DevTools Protocol.</p><h1 id="escaping-the-sandbox">Escaping the sandbox</h1><p>Given all of the above, there are at least two ways you can escape the browser’s sandbox:</p><h2 id="by-targeting-an-extension">By targeting an extension</h2><p>The first would be to use the fact that the DevTools can script any extension to attack a higher privileged extension. In the case of Edge, the Edge Feedback App has access to a <code class="language-plaintext highlighter-rouge">chrome.edgeFeedbackPrivate</code> API. Previously, this API had a method named <code class="language-plaintext highlighter-rouge">saveBytesToFile</code>. Because that method didn’t validate paths it received, it was possible to write a file to an arbitrary location using it. That could be used, for example, to save an executable into the user’s startup folder, which would then be run on the next login.</p><p>That specific issue in the Edge Feedback App is now fixed, and further more, it’s no longer possible to load App pages in regular tabs either.</p><p>In terms of finding potentially vulnerable extensions, <code class="language-plaintext highlighter-rouge">chrome://extensions-internals</code> is very useful. It contains a list of all extensions currently loaded in the browser. You can use it to see which component (builtin) extensions are loaded, which isn’t something that’s shown on <code class="language-plaintext highlighter-rouge">chrome://extensions</code>.</p><p>Once you’ve identified a particular extension you’d like to investigate, you can load a page from that extension, then check what APIs are available to it.</p><h2 id="by-using-the-chrome-devtools-protocol">By using the Chrome DevTools Protocol</h2><p>Since the Chrome DevTools Protocol is only available if the DevTools is actually attached to a page, there are only two feasible ways of making use of that functionality:</p><ol><li>The user would need to open the DevTools manually, or</li><li>The extension would need to open the DevTools - for example, by sending the <kbd>F12</kbd> key event using the <a href="https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-dispatchKeyEvent">Input.dispatchKeyEvent</a> DevTools Protocol method. This would require that the extension have the debugger permission.</li></ol><p>A relatively simple way of escaping the sandbox once you can run code within a DevTools context and have the ability to open an attached DevTools instance is to go through the following steps:</p><ol><li><p>Add a console pin within the DevTools. This can be done easily using the following code:</p><div class="language-js highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">pin</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">...</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// Contains the code to run</span>
<span class="nx">localStorage</span><span class="p">.</span><span class="nx">consolePins</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">([</span><span class="nx">pin</span><span class="p">]);</span>
</pre></table></code></div></div><p>This doesn’t depend at all on having a DevTools instance that’s attached to a page. So provided that you can script the DevTools, you can immediately add a console pin.</p><blockquote><p>Note there is a slight difference in terminology here. While the <code class="language-plaintext highlighter-rouge">localStorage</code> key is called <code class="language-plaintext highlighter-rouge">consolePins</code>, a console pin is referred to as a “live expression” in the DevTools UI.</p></blockquote></li><li><p>Open an attached DevTools instance, through one of the two ways described above.</p></li><li><p>Navigate the page being debugged to <code class="language-plaintext highlighter-rouge">chrome://downloads</code>. The downloads page is an interesting case, as it’s one of the very few places in the browser where a local file can be legitimately opened. That means that it’s an ideal end-stage attack target.</p><p>To actually open a file, you’ll need to call the <a href="https://source.chromium.org/chromium/chromium/src/+/main:chrome/browser/ui/webui/downloads/downloads.mojom;l=48;drc=f8a870251c70a05f585edff58b21fdbbf5d01670">OpenFileRequiringGesture</a> mojo method that’s available to that page. As the name of that method suggests, a recent user gesture is required to successfully invoke the method. More specifically, a user gesture needs to have been received within the last <a href="https://source.chromium.org/chromium/chromium/src/+/main:content/browser/web_contents/web_contents_impl.cc;l=2224-2225;drc=f8a870251c70a05f585edff58b21fdbbf5d01670">five seconds</a>.</p><p>This can be accomplished by sending a key event using <code class="language-plaintext highlighter-rouge">Input.dispatchKeyEvent</code>, which you’ll need to do anyway if you open the DevTools using an extension with the debugger permission.</p></li><li><p>The console pin added in step 1 will be regularly re-evaluated on the target page. This means that any code you add to the pin will be run within the context of <code class="language-plaintext highlighter-rouge">chrome://downloads</code>, since that’s what the target page was navigated to in step 3. The pin can then call <code class="language-plaintext highlighter-rouge">OpenFileRequiringGesture</code> to open an executable that’s been downloaded.</p><p>This is essentially an indirect use of the Chrome DevTools Protocol, since the console pins functionality internally <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/core/sdk/RuntimeModel.ts;l=645;drc=79e812efee4be5e4d4378562f8acebffe9771f20">uses</a> <a href="https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-evaluate">Runtime.evaluate</a> to evaluate the code for any pins within the context of the target page.</p></li></ol><h1 id="conclusion">Conclusion</h1><p>This hopefully provides an overview of some of the attack surface present within the DevTools and how it might be exploited. The DevTools itself is fairly complex and contains a lot of functionality, which creates the opportunity for exploitable issues.</p><p>Several example issues are given above that allowed an extension to run code within the context of the DevTools. As is shown, being able to do this may allow an extension to read local files, script other extensions and ultimately escape the sandbox.</p><p>Finally, in terms of reward amounts, the issue with the Edge Feedback App was assessed as being a moderate severity issue and therefore wasn’t eligible for a reward (at present, only higher severity issues are rewarded under the Microsoft Edge Bounty Program). The <code class="language-plaintext highlighter-rouge">remoteBase</code> issue described above was rewarded $30,000 USD by Microsoft. With the addition of the other two Chromium issues I filed and described above (issue <a href="https://crbug.com/1059577">1059577</a> and issue <a href="https://crbug.com/1064519">1064519</a>), the total amount rewarded was $36,000 USD. Which shows that finding and reporting these sorts of issues definitely has value.</p><h1 id="source-code-references">Source code references</h1><p>One of the main difficulties with trying to understand this sort of functionality within Chromium is trying to find the relevant source code. Due to the size of the Chromium codebase, this can be non-trivial at times. To make it easier to get a foothold in this area, here are some links to relevant source code:</p><ul><li><p>The DevTools frontend:</p><p><a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/">https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/</a></p><p>This contains the TypeScript code used for the DevTools frontend. If you’re investigating functionality provided by the frontend, this is where you’ll want to look.</p></li><li><p>ExtensionServer.ts:</p><p><a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/models/extensions/ExtensionServer.ts;drc=d662bdf64b7d5168e7746f0cecf74598ec2ed445">https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/models/extensions/ExtensionServer.ts;drc=d662bdf64b7d5168e7746f0cecf74598ec2ed445</a></p><p>This is the code that handles messages sent from an extension’s DevTools page, in order to implement the <code class="language-plaintext highlighter-rouge">chrome.devtools</code> functionality.</p></li><li><p>ExtensionAPI.ts:</p><p><a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/models/extensions/ExtensionAPI.ts;drc=d662bdf64b7d5168e7746f0cecf74598ec2ed445">https://source.chromium.org/chromium/chromium/src/+/main:third_party/devtools-frontend/src/front_end/models/extensions/ExtensionAPI.ts;drc=d662bdf64b7d5168e7746f0cecf74598ec2ed445</a></p><p>This is the client-side implementation of ExtensionServer.ts. In other words, the code in this file is loaded within an extension’s DevTools page and is what’s responsible for sending channel messages to the DevTools.</p></li><li><p>The browser-side DevTools functionality implementation:</p><p><a href="https://source.chromium.org/chromium/chromium/src/+/main:chrome/browser/devtools/">https://source.chromium.org/chromium/chromium/src/+/main:chrome/browser/devtools/</a></p><p>This directory contains C++ code that implements various DevTools functionality on the browser-side. For example, <a href="https://source.chromium.org/chromium/chromium/src/+/main:chrome/browser/devtools/devtools_window.cc;l=1085;drc=f8a870251c70a05f585edff58b21fdbbf5d01670">DevToolsWindow::Create</a> is what creates a browser window for a DevTools instance.</p></li><li><p>The Chrome DevTools Protocol documentation:</p><p><a href="https://chromedevtools.github.io/devtools-protocol/">https://chromedevtools.github.io/devtools-protocol/</a></p><p>Contains a listing of all methods available within the Chrome DevTools Protocol, though an extension won’t necessarily be able to call all of the methods.</p></li><li><p>The bulk of the browser-side implementation of the Chrome DevTools Protocol:</p><p><a href="https://source.chromium.org/chromium/chromium/src/+/main:content/browser/devtools/protocol/">https://source.chromium.org/chromium/chromium/src/+/main:content/browser/devtools/protocol/</a></p><p>Note that not all of the Chrome DevTools Protocol is implemented here. For example, some methods are implemented renderer-side.</p><p>Reading through the implementation for a DevTools Protocol method can be very useful, both to determine exactly what the DevTools is doing, as well as to determine what an extension with the debugger permission can do.</p></li></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/edgevr/categories/vulnerabilities/'>Vulnerabilities</a>, <a href='/edgevr/categories/exploit/'>Exploit</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/edgevr/tags/devtools/" class="post-tag no-text-decoration" >DevTools</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><!-- Post sharing snippet v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Guest Blog Post - Attacking the DevTools - Microsoft Browser Vulnerability Research&url=https://microsoftedge.github.io/edgevr/posts/attacking-the-devtools/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Guest Blog Post - Attacking the DevTools - Microsoft Browser Vulnerability Research&u=https://microsoftedge.github.io/edgevr/posts/attacking-the-devtools/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Guest Blog Post - Attacking the DevTools - Microsoft Browser Vulnerability Research&url=https://microsoftedge.github.io/edgevr/posts/attacking-the-devtools/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://microsoftedge.github.io/edgevr/posts/attacking-the-devtools/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><!-- The Pannel on right side (Desktop views) v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><h3 data-toc-skip>Recent Update</h3><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/edgevr/posts/Introducing-Enhanced-Security-for-Microsoft-Edge/">Introducing Enhanced Security for Microsoft Edge</a></li><li><a href="/edgevr/posts/Super-Duper-Secure-Mode/">Super Duper Secure Mode</a></li><li><a href="/edgevr/posts/attacking-the-devtools/">Guest Blog Post - Attacking the DevTools</a></li><li><a href="/edgevr/posts/eliminating-xss-with-trusted-types/">Eliminating XSS from WebUI with Trusted Types</a></li><li><a href="/edgevr/posts/Hacking-Chrome-iOS/">iOS Chromium Overlooked and Underappreciated</a></li></ul></div><div id="access-tags"><h3 data-toc-skip>Trending Tags</h3><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/edgevr/tags/tips/">tips</a> <a class="post-tag" href="/edgevr/tags/site-isolation/">Site Isolation</a> <a class="post-tag" href="/edgevr/tags/jit/">JIT</a> <a class="post-tag" href="/edgevr/tags/ios/">iOS</a> <a class="post-tag" href="/edgevr/tags/fuzzing/">fuzzing</a> <a class="post-tag" href="/edgevr/tags/ui/">UI</a> <a class="post-tag" href="/edgevr/tags/trusted-types/">Trusted Types</a> <a class="post-tag" href="/edgevr/tags/memory-corruption/">Memory Corruption</a> <a class="post-tag" href="/edgevr/tags/headlines/">Headlines</a> <a class="post-tag" href="/edgevr/tags/devtools/">DevTools</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h3 data-toc-skip class="pl-3 pt-2 mb-2">Contents</h3><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <!-- Recommend the other 3 posts according to the tags and categories of the current post, if the number is not enough, use the other latest posts to supplement. v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/edgevr/posts/yet-another-uaf/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Mar 2, 2021 <i class="unloaded">2021-03-02T08:00:00-08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Yet another RenderFrameHostImpl UAF</h3><div class="text-muted small"><p> Introduction Back in 2020 while reviewing Chromium code, I found issue 1068395, a Use-After-Free in Browser Process that can be used to escape the Chromium sandbox on Android Devices. This is an i...</p></div></div></a></div><div class="card"> <a href="/edgevr/posts/Hacking-Chrome-iOS/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Oct 16, 2020 <i class="unloaded">2020-10-16T09:00:00-07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>iOS Chromium Overlooked and Underappreciated</h3><div class="text-muted small"><p> A Bold New Frontier As part of Microsoft’s Edge’s move to using Chromium as the backbone of our browsers, we are updating all our browser product lines, including the iOS version. As security engin...</p></div></div></a></div><div class="card"> <a href="/edgevr/posts/memory-corruption-vulnerabilities-in-edge/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Oct 17 <i class="unloaded">2022-10-17T09:00:00-07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Guest Blog Post - Memory corruption vulnerabilities in Edge</h3><div class="text-muted small"><p> Introduction Memory corruption issues in the browser process are typically some of the most severe issues in Chromium and browsers that are based off it. Such issues can include use-after-free (UA...</p></div></div></a></div></div></div><!-- Navigation buttons at the bottom of the post. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --><div class="post-navigation d-flex justify-content-between"> <a href="/edgevr/posts/ui-security-thinking-outside-the-viewport/" class="btn btn-outline-primary"><p>UI Security - Thinking Outside the Viewport</p></a> <a href="/edgevr/posts/Super-Duper-Secure-Mode/" class="btn btn-outline-primary"><p>Super Duper Secure Mode</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script> <!-- The Footer v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/MSEdgeDev">Microsoft Corporation</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/">Chirpy</a> theme.</p></div></div></footer></div><!-- The Search results v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/edgevr/tags/tips/">tips</a> <a class="post-tag" href="/edgevr/tags/site-isolation/">Site Isolation</a> <a class="post-tag" href="/edgevr/tags/jit/">JIT</a> <a class="post-tag" href="/edgevr/tags/ios/">iOS</a> <a class="post-tag" href="/edgevr/tags/fuzzing/">fuzzing</a> <a class="post-tag" href="/edgevr/tags/ui/">UI</a> <a class="post-tag" href="/edgevr/tags/trusted-types/">Trusted Types</a> <a class="post-tag" href="/edgevr/tags/memory-corruption/">Memory Corruption</a> <a class="post-tag" href="/edgevr/tags/headlines/">Headlines</a> <a class="post-tag" href="/edgevr/tags/devtools/">DevTools</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <!-- The GA snippet v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', '', 'auto'); ga('send', 'pageview'); </script> <!-- Jekyll Simple Search loader v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/edgevr/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://microsoftedge.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
