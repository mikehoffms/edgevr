<!DOCTYPE html><html lang="en" > <!-- The Head v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="twitter:image" content="https://microsoftedge.github.io/edgevr/assets/img/edge-logo-128x128.png"><title>Yet another RenderFrameHostImpl UAF | Microsoft Browser Vulnerability Research</title><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Yet another RenderFrameHostImpl UAF" /><meta name="author" content="Lucas P." /><meta property="og:locale" content="en_US" /><meta name="description" content="Introduction Back in 2020 while reviewing Chromium code, I found issue 1068395, a Use-After-Free in Browser Process that can be used to escape the Chromium sandbox on Android Devices. This is an interesting vulnerability as it’s a bug pattern that keeps happening in the Chromium codebase. Having a good understanding of this pattern and how an attacker can exploit it is a good exercise to gain knowledge as well as inspiration in what to look for when reviewing code and writing new fuzzers. More importantly this can help us learn how we can mitigate such bug patterns. Today, we will explore how issue 1068395 can be exploited assuming a compromised Renderer Process (using a vulnerability like 1126249). What Is a RenderFrameHost? Whenever a website is navigated to, the Browser Process will spawn a new Renderer Process. This process will parse the website’s content, such as JavaScript, HTML, and CSS and display it on its main frame. To track the main frame and communicate with it, the Browser Process will instantiate a RenderFrameHostImpl (RFH) object to represent the Renderer’s main frame. Complicating things further, a website may have multiple “child-frames” (a.k.a iframes) that will embed another page context inside the main frame which can be created and destroyed at any moment by JavaScript. If the embedded origin is the same as the main frame, the Renderer Process will create a “frame” object and track it using a frame-tree data structure. The Browser Process will mirror this behavior and create a new RFH object for each new child frame. However, if the contexts have a different origin, the Browser Process will spawn a new Renderer Process due to site isolation. For us, the behavior described previously may be read as: We control the RFH’s object creation and destruction (or its lifetime) from JavaScript! Can we leverage such behavior to find security vulnerabilities? RenderFrameHost and Mojo interfaces Nowadays, modern web-browsers are implemented with a multi-process architecture in mind. In this model, we have untrusted content parsed in a very restrictive/locked-down process (a.k.a a “sandboxed process”). To provide resource access to such a locked-down process, we have a “broker process”. In our case, this is the “browser process”. The browser process can provide access to these restricted resources via a mechanism called Inter-Process-Communication (IPC). Chromium has two IPC mechanisms, the old-IPC/Legacy IPC and Mojo IPC. Nowadays, most features that want to expose resources to the Renderer Process (untrusted/sandboxed process) do it by using a Mojo interface. These interfaces are described using a mojom file, for example (from mojo_and_services.md): 1 2 3 4 interface PingResponder { // Receives a &quot;Ping&quot; and responds with a random integer. Ping() =&gt; (int32 random); }; A Mojo interface is usually bound per-frame, therefore, every time an iframe is created and you request to bind to new a Mojo interface, it may end up allocating a new Mojo interface object in Browser Process (or bind into an existing one). If you are curious about what interfaces are exposed to an iframe, you can check the browser_interface_binders.cc. There is a “trick” here, as explained by BrowserInterfaceBroker, different “execution types” (a.k.a iframe/document, service workers and so on), may have a different binder function (thus, different set of interfaces exposed), it can be observed in PopulateServiceWorkerBinders and PopulateFrameBinders. (sidenote: Monitoring the commit changes in browser_interface_binders.cc is a nice method to find new Mojo Interfaces!). Many objects accessible over Mojo don’t need access to the web page itself and are there to just facilitate access to privileged operations not allowed in the sandbox. However, there are situations that a Mojo interface object may require to access to the RFH object that has instantiated it, like accessing its RFH’s WebContentsImpl object, accessing its RenderFrameProcess object and so on. One way to accomplish this is by providing a raw pointer to the RFH that has instantiated the interface in the Mojo interface object constructor. The constructor can then store this pointer as a class member. You can observe such behavior in the SensorProviderProxyImpl: 1 2 3 4 5 6 7 8 9 SensorProviderProxyImpl::SensorProviderProxyImpl( PermissionControllerImpl* permission_controller, RenderFrameHost* render_frame_host) : permission_controller_(permission_controller), render_frame_host_(render_frame_host) { // [1] DCHECK(permission_controller); DCHECK(render_frame_host); } As you can see at [1], SensorProviderProxyImpl will store the raw pointer for the RFH that has instantiated it as a member. Now, there is a question, can we guarantee that the Mojo interface will not outlive (stay alive longer than) RFH object? The answer can be found by checking how the Mojo interface object gets created. Let’s look at the code below. 1 2 3 4 5 6 7 8 9 10 void RenderFrameHostImpl::GetSensorProvider( mojo::PendingReceiver&lt;device::mojom::SensorProvider&gt; receiver) { if (!sensor_provider_proxy_) { sensor_provider_proxy_ = std::make_unique&lt;SensorProviderProxyImpl&gt;( // [2] PermissionControllerImpl::FromBrowserContext( GetProcess()-&gt;GetBrowserContext()), this); } sensor_provider_proxy_-&gt;Bind(std::move(receiver)); } The SensorProvider Mojo interface object is a member variable in the RenderFrameHostImpl class [2]. If the sensor_provider_proxy_ has not been initialized yet, it’ll instantiate a std::unique_ptr for it. So, we can guarantee that SensorProviderProxyImpl object will be destroyed once the RFH object gets destroyed as their lifetimes are tied to each other! However, Chromium is a complex code-base and things aren’t always that easy; there are other ways in which Mojo interface objects may be created. For example, one may be instantiated by using Mojo::MakeSelfOwnedReceiver. The documentation states: “A self-owned receiver exists as a standalone object which owns its interface implementation and automatically cleans itself up when its bound interface endpoint detects an error.” In other words, the lifetime for the Mojo interface object is tied with its mojo connection: so, if the mojo connection stays alive, the Mojo interface object will stay alive as well (more details in here). This means both sides of the mojo connection (Browser and Renderer Process) control the object lifetime; this is explained well in “Virtually Unlimited Memory: Escaping the Chrome Sandbox” by Mark Brand). That also means that we can have a situation where UI thread will destroy the RFH object, and the Mojo connection is still alive (as it is self-owned) and processing mojo messages until the bind detects an error or that it was closed. Thus, if during this time-window the Mojo interface object processes a message that will access the freed RFH object, we will have a Use-After-Free (UAF) issue. This is an example of the problem that most of the vulnerabilities linked to in the introduction end up exploiting. It has been exploited by many researchers, explained in other blogposts, like “Escaping the Chrome Sandbox” and in CTFs like PlaidCTF. Chromium does have some features to mitigate such problems, and we will go through some examples: WebContentsObserver: If your Mojo interface implementation inherits from this class, you will be provided with a set of callback events (virtual methods) that may be overridden by your implementation. Among these callbacks, we have RenderFrameDeleted, which gets triggered every time an RFH object gets deleted. We can observe its use in InstalledAppProviderImpl. This class was used to fix the vulnerability described in “Escaping the Chrome Sandbox”. 1 2 3 4 5 6 void InstalledAppProviderImpl::RenderFrameDeleted( RenderFrameHost* render_frame_host) { if (render_frame_host_ == render_frame_host) { render_frame_host_ = nullptr; } } FrameServiceBase: This class is similar to WebContentsObserver, however, it implements all callbacks for you and guarantees that the implementation object gets freed as soon as the RFH object that created it gets deleted. By using one of the mechanisms mentioned above, you can guarantee that the Mojo Interfaces you own won’t have Use-After-Free issues with RFH objects. Now that we understand the complexities of Mojo interfaces and RFH, and the problems that can arise from their mismanagement, we can start looking around to see if we can find a vulnerability :). Enter SmsReceiver! Like all normal people do at 4AM, I was using Chromium Code Search to read around Chromium’s source code. While looking around the commit changes for browser_interface_binders.cc to check for new Mojo interfaces and other related changes, SmsService caught my eye. Let’s see how the Mojo interface object is created. 1 2 3 4 5 6 7 8 9 10 11 12 void RenderFrameHostImpl::BindSmsReceiverReceiver( mojo::PendingReceiver&lt;blink::mojom::SmsReceiver&gt; receiver) { if (GetParent() &amp;&amp; !GetMainFrame()-&gt;GetLastCommittedOrigin().IsSameOriginWith( GetLastCommittedOrigin())) { mojo::ReportBadMessage(&quot;Must have the same origin as the top-level frame.&quot;); return; } auto* fetcher = SmsFetcher::Get(GetProcess()-&gt;GetBrowserContext(), this); // [3] SmsService::Create(fetcher, this, std::move(receiver)); // [4] } First, it’ll call SmsFetcher::Get with the BrowserContext and this (RFH object reference) as arguments [3]; we will come back for SmsFetcher::Get later, but for now, all we need to know is that it’ll return a pointer to an SmsFetcher object. Afterwards, we will end up calling SmsService::Create with the SmsFetcher object pointer and this (RFH object reference) as argument [4]. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // static void SmsService::Create( SmsFetcher* fetcher, RenderFrameHost* host, mojo::PendingReceiver&lt;blink::mojom::SmsReceiver&gt; receiver) { DCHECK(host); // SmsService owns itself. It will self-destruct when a Mojo interface // error occurs, the render frame host is deleted, or the render frame host // navigates to a new document. new SmsService(fetcher, host, std::move(receiver)); // [5] } SmsService::SmsService( SmsFetcher* fetcher, const url::Origin&amp; origin, RenderFrameHost* host, mojo::PendingReceiver&lt;blink::mojom::SmsReceiver&gt; receiver) : FrameServiceBase(host, std::move(receiver)), // [6] fetcher_(fetcher), origin_(origin) {} As the code-comments explained, the Mojo interface object owns itself [5]. It isn’t using mojo::MakeSelfOwnedReceiver, but SmsService inherits from FrameServiceBase [6], which has a similar effect. In the SmsService constructor we can see it will initialize the FrameServiceBase [6] with our RFH object reference so it can track the RFH object state. As we have already learned, FrameServiceBase will guarantee that the mojo interface object gets deleted as soon as the RFH object gets deleted, therefore, there is no UAF here. Oh well, no bugs here. Let’s move to another mojo interface implementation… wait… Actually, let’s go all the way back to BindSmsReceiverReceiver function. In particular the line below: 1 auto* fetcher = SmsFetcher::Get(GetProcess()-&gt;GetBrowserContext(), this); // [7] As already mentioned, this function will create (or get an already created) SmsFetcher object and return it [7], let’s look further: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 SmsFetcher* SmsFetcher::Get(BrowserContext* context, RenderFrameHost* rfh) { auto* stored_fetcher = static_cast&lt;SmsFetcherImpl*&gt;( context-&gt;GetUserData(kSmsFetcherImplKeyName)); // [8] if (!stored_fetcher || !stored_fetcher-&gt;CanReceiveSms()) { // [9] auto fetcher = std::make_unique&lt;SmsFetcherImpl&gt;(context, SmsProvider::Create(rfh)); context-&gt;SetUserData(kSmsFetcherImplKeyName, std::move(fetcher)); } return static_cast&lt;SmsFetcherImpl*&gt;( context-&gt;GetUserData(kSmsFetcherImplKeyName)); // [10] } The first thing the code does is check if BrowserContext has a SmsFtecherObject stored within it [8], which implies that SmsFetcher lifetime is tied with BrowserContext lifetime! If it both exists and can receive SMS message [9], it will just return a reference to it at [10]. However, if it cannot receive SMS messages or is not created, it will create a new SmsFetcherImpl object [9]. The SmsFetcherImpl constructor expects an SmsProvider object that is created by calling its Create method with our RFH object as an argument. Now, let’s look at the SmsProvider::Create method. (Trivia: Ooops, there was another vulnerability around here: 1070609). 1 2 3 4 5 6 7 8 9 10 11 12 13 // static std::unique_ptr&lt;SmsProvider&gt; SmsProvider::Create(RenderFrameHost* rfh) { #if defined(OS_ANDROID) if (base::CommandLine::ForCurrentProcess()-&gt;GetSwitchValueASCII( switches::kWebOtpBackend) == switches::kWebOtpBackendSmsVerification) { return std::make_unique&lt;SmsProviderGmsVerification&gt;(); } return std::make_unique&lt;SmsProviderGmsUserConsent&gt;(rfh); // [11] #else return nullptr; #endif } There are two SmsProvider types: SmsProviderGmsVerification: Not interesting for us, as it will not take the RFH as argument anyway. SmsProviderGmsUserConsent: It’ll receive the RFH raw pointer as an argument for its constructor [11]. Looks promising, let’s keep looking. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 SmsProviderGmsUserConsent::SmsProviderGmsUserConsent(RenderFrameHost* rfh) : SmsProvider(), render_frame_host_(rfh) { // [12] // This class is constructed a single time whenever the // first web page uses the SMS Retriever API to wait for // SMSes. JNIEnv* env = AttachCurrentThread(); j_sms_receiver_.Reset(Java_SmsUserConsentReceiver_create( env, reinterpret_cast&lt;intptr_t&gt;(this))); } void SmsProviderGmsUserConsent::Retrieve() { JNIEnv* env = AttachCurrentThread(); WebContents* web_contents = WebContents::FromRenderFrameHost(render_frame_host_); // [13] if (!web_contents || !web_contents-&gt;GetTopLevelNativeWindow()) return; Java_SmsUserConsentReceiver_listen( env, j_sms_receiver_, web_contents-&gt;GetTopLevelNativeWindow()-&gt;GetJavaObject()); } Oh! So, we will store the raw pointer for the RFH object as a member variable inside the SmsProviderGmsUserConsent [12] class. That looks dangerous. Also we will end up accessing it whenever we call the Retrieve method [13]. Unless there is some mechanism that ensures the RFH has not been deleted (spoilers: there aren’t) it may lead to a UAF. Now, to understand better, let’s create an “ownership/reference map”, after creating SmsFetcherImpl object, we will end up with something similar to: As we all love to study chromium code base, one of the things we have learned by watching “Anatomy of the browser 201 (Chrome University 2019)” is that the BrowserContext is pretty much our current Profile. This means it’ll stay alive longer than objects like WebContentsImpl and RenderFrameHostImpl! We also have learned that we won’t always create a new SmsFetcherImpl. Instead, we will create it once and provide a reference to it every time a new SmsService is created. This smells like a chance for a UAF as we will keep reusing the same RFH object pointer (inside SmsProviderGmsUserConsent) for all new SmsProvider Mojo interface instances. Indeed, we will have a problem here, as the first time we create a SmsProviderGmsUserConsent, it’ll store a reference to the RFH object that created it. However, we know that SmsFetcherImpl will keep reusing SmsProviderGmsUserConsent even after the RFH object is deleted, as there aren’t any mechanisms to ensure that RFH object hasn’t been deleted! Therefore, if we have a new RFH object that binds to the SmsService interface, the SmsService object will store a raw pointer to the SmsFetcherImpl object containing the SmsProviderGmsUserConsent which holds a dangling RFH pointer. To illustrate it, let’s look at the diagram below. Create an iframe and bind to SmsReceiver Create another iframe and Bind to SmsReceiver Delete the first iframe (aka iframe A), thus, it’s iframe A’s RFH object gets deleted, but we still have a reference to it in SmsProviderGmsUserConsent. Call receive in SmsReceiver for iframe B As you can see, at the end, iframe B’s SmsService may end up dereferencing a freed RFH! Unfortunately, FrameServiceBase cannot save us from this problem, in the end we will have a Use-After-Free issue. Now, we have found a cool vulnerability, let’s try to use it to achieve code execution in Browser Process context! Exploiting the Issue At this point we know that SmsProviderGmsUserConsent::Retrieve will end up using our freed RFH for some operations. Let’s take a look at how exactly it is used: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void SmsProviderGmsUserConsent::Retrieve() { JNIEnv* env = AttachCurrentThread(); WebContents* web_contents = WebContents::FromRenderFrameHost(render_frame_host_); // [14] if (!web_contents || !web_contents-&gt;GetTopLevelNativeWindow()) return; Java_SmsUserConsentReceiver_listen( env, j_sms_receiver_, web_contents-&gt;GetTopLevelNativeWindow()-&gt;GetJavaObject()); } First, it’ll get a reference to the “freed” RFH and use it as an argument for the function WebContents::FromRenderFrameHost [14]. Then, it’ll return a pointer to the WebContentsImpl object. Finally, it’ll check if the WebContentsImpl isn’t nullptr and execute some Java code, otherwise, it’ll just return early. Now, let’s look at the FromRenderFrameHost implementation: 1 2 3 4 5 6 7 8 9 10 11 12 WebContents* WebContents::FromRenderFrameHost(RenderFrameHost* rfh) { if (!rfh) return nullptr; if (!rfh-&gt;IsCurrent() &amp;&amp; base::FeatureList::IsEnabled( // [15] kCheckWebContentsAccessFromNonCurrentFrame)) { // TODO(crbug.com/1059903): return nullptr here eventually. base::debug::DumpWithoutCrashing(); } return static_cast&lt;RenderFrameHostImpl*&gt;(rfh)-&gt;delegate()-&gt;GetAsWebContents(); // [16] There are two function calls here that use the RFH. The first is at [15], and the second at [16] where it will read a member object inside RFH and call its GetAsWebContents function. These method’s declarations look like the following: 1 2 3 virtual bool IsCurrent() = 0; virtual WebContents* GetAsWebContents(); As you can see both methods are declared virtual. As we know, the compiler will end up creating a virtual table to handle the dynamic dispatch! So, if we can somehow control the “freed” object, and replace its virtual table with a fake one that we control, we could call an arbitrary function pointer. Once we can call an arbitrary pointer, we can use Returned-Oriented-Programming (ROP) or Jump-Oriented-Programming (JOP) and achieve arbitrary code execution. Also, if we can make the GetAsWebContents return nullptr (0x0), we can smoothly continue the browser execution with no crash. Sounds like a nice plan! However, we have a problem here: Address Space Layout Randomization (ASLR). We may have a UAF and we may somehow be able to replace its object virtual table with controlled contents, but we have no idea where .text, .data or heap allocations are as we have no information disclosure vulnerability. We did not get so far to give up! Let’s think about it further. Zygote to Rescue! I was using a Pixel 3A android device as target for my exploit and while I was researching a solution for the ASLR problem, I found out that Android has its own way to launch applications. It is using a concept called “Zygote” and there are many articles giving in-depth details of how it works and its security implications. For us, Zygote essentially means that every new spawned process will share the same ASLR base between them, in another words: Processes can end up sharing the same virtual memory mapping between some shared libraries! That is perfect, as having a remote code execution exploit (taking over Renderer Process by using either a V8 or Blink vulnerability, for example) may help us to easily defeat ASLR as both Renderer Process and Browser process share the same virtual mapping between shared libraries. Do we really need ROP and/or JOP? Essentially, once we can replace the “freed” RFH object in memory with attacker-controlled data, we want to make its virtual table to point to a fake virtual table and jump into any arbitrary function or a stack-pivot for ROP. However, ASLR is still a problem for the heap segments as we have no information about its heap layout. We can bypass the heap problem by calling another object virtual table that will end up writing the RFH this pointer onto itself (and being able to read the object memory back into Renderer Process). That should work; however, there is something even better! Guang Gong has presented a nice technique in “An exploit Chain to Remotely Root Modern Android Devices”. The article explains that the libllvm-glnext.so (that is present in Pixel 3a) has a function pointer to system in its .GOT segment. We can easily replace the RFH virtual table to point into libllvm-glnext.so .GOT and make a call to system! The beauty here is that the system’s function argument is a pointer to the RFH object (aka this) that we fully control! Now we can call system with arbitrary command in context of Browser Process! Feels back into 90s, right? Keeping the Browser alive (CRASH != FUN) Let’s look again at the WebContents::FromenderFrameHost function but from another perspective, the ARM-assembly perspective: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 0x0000000000000000: 10 B5 push {r4, lr} 0x0000000000000002: 98 B1 cbz r0, #0x2c 0x0000000000000004: 04 46 mov r4, r0 // R0 = RFH-&gt;vtable 0x0000000000000006: 00 68 ldr r0, [r0] // R1 = RFH-&gt;vtable[0xBC/0x4] -- system pointer 0x0000000000000008: D0 F8 BC 10 ldr.w r1, [r0, #0xbc] 0x000000000000000c: 20 46 mov r0, r4 // system(R0) 0x000000000000000e: 88 47 blx r1 // [17] 0x0000000000000010: 30 B9 cbnz r0, #0x20 0x0000000000000012: 07 48 ldr r0, [pc, #0x1c] 0x0000000000000014: 78 44 add r0, pc 0x0000000000000016: A9 F1 42 EA blx #0x1a949c 0x000000000000001a: 08 B1 cbz r0, #0x20 0x000000000000001c: A9 F1 06 EE blx #0x1a9c2c // R0 = RFH-&gt;member_7c 0x0000000000000020: E0 6F ldr r0, [r4, #0x7c] // R1 = RFH-&gt;member_7c-&gt;vtable 0x0000000000000022: 01 68 ldr r1, [r0] // R1 = RFH-&gt;member_7c-&gt;vtable[0x64/0x4] 0x0000000000000024: 49 6E ldr r1, [r1, #0x64] 0x0000000000000026: BD E8 10 40 pop.w {r4, lr} // [18] // return R1(), where R1 is a function that will set R0 (return value) to 0 // it&#39;ll make WebContents == nullptr and not crashing the browser :) 0x000000000000002a: 08 47 bx r1 0x000000000000002c: 00 20 movs r0, #0 0x000000000000002e: 10 BD pop {r4, pc} As you can see, there are two virtual function calls. The first call, RFH-&gt;vtable_fptr[0x2F] [17], we can use to call system with controlled arguments. However, the second virtual call, RFH-&gt;member_7C-&gt;vtable_fptr[0x19] [18], is a problem for us. As you already know we have no information disclosure about the heap memory layout, so, we cannot easily fake a member_7C object. So, what is the solution here? Maybe we could just let the browser crash anyway, as we will end up executing the system command before the crash happens… But, let’s be honest, crashing the browser isn’t fun, can we do something else? Yes, Zygote@libllvm-glnext to the rescue again. Do we have such a magic pointer in libllvm-glnext? Yes! At offset 0x8E4BE8 (.GOT segment) we have exactly what we need, we will end up with the following call chain: Now, we can both call system and resume execution smoothly without crashing the browser :) Replacing the Object Alright, at this point we want to replace the object in memory with fully controlled content. What we need here is some heap-spray primitive. We could go and try to find our own, however, let’s not recreate the wheel. We can use the same technique demonstrated by “GPZ Virtually Unlimited Memory”, since it still works and fulfills all our needs. Now, the next step is to find the size of the RFH object size in memory. This is necessary as we increase the chance to reclaim the memory by spraying payloads of the same size as the RFH object. You can do it by using your favorite disassembler, compiler, debugger, or any other tool. In my case, it was 0x880 bytes. However, if you heap spray using the technique above, it may work and reclaim the object, but it may also be a bit unstable. Apparently, on Android, at least for the version that I had when I wrote the exploit, the Browser Process will end up using jemalloc as the default heap allocator. There is enough documentation (that I recommend reading) regarding the allocator internals, thus, I will not go into details here. What is interesting for us is that jemalloc implements thread specific caches. Remember, our target object, the freed RFH, is created and destroyed on UI thread and the heap-spray technique will happen on IO thread. Due to this, we may have our allocations happening in different thread-caches/arenas. As we want to be able to reclaim a freed region (a.k.a our RFH object) from another thread, we need to cause either a flush event or hard event that will end up freeing some bins/regions inside a tcache (each bin has its own tcache, that is a list for the recently freed regions). Once a flush or hard event occurs, the region can now be allocated by other threads. This can be accomplished by first freeing our victim RFH object and then allocating multiple iframes and freeing them. Following this you can spray as normal with your heap-spray primitive. In my tests, this seems to have increased the exploit’s reliability. Putting It All Together Now, using all the knowledge we have learned, let’s summarize how our exploit works: Create a child iframe that will use MojoJS to create and bind to a SmsReceiver interface (thus, creating a SmsProviderGmsUserConsent with a pointer to its RFH). MojoJS can be enabled by a compromised renderer. Send a postMessage from the child iframe to the main frame to tell it the Mojo interface has been created. The main frame can now delete the child iframe with document.body.removeChild. In the main frame, create another SmsReceiver interface. This instantiation will use the already created SmsFetcherImpl which has a raw pointer to the freed RFH object. Prepare our heap payload: The first 4 bytes (32 bit architecture) is the virtual table pointer, it’ll be a pointer to libllvm-glnext.so .got.plt minus 0xBC (offset for virtual table) so we land in the correct address. The next bytes will be our shell command, something of the form “|| (command).” This way it’ll first execute the virtual table address as a “command” and then execute our shell command. For the exploit, I used: &#39; || (toybox nc -p 4444 -l /bin/sh)&#39;). At offset 0x7C of our payload we will have a pointer to the “magic function pointer” in libllvm-glnext.so, so we can guarantee the GetAsWebContents virtual method will return the value 0x0, making SmsProviderGmsUserConsent::Retrieve return early, avoiding a browser crash. Spray these bytes using the same technique learned here, but use the jemalloc trick described earlier to make it more reliable. Call SmsReceiver.receive method and watch the magic! You can find the final exploit here. Conclusion At this point you can run shell commands in the context of Browser Process. Due to the Android security model, you may have limited resource access as you are still inside Android’s application sandbox. The next step would be to chain a kernel vulnerability, as described here, but this is a story for another day. I hope you have enjoyed reading and learning a little more about Chromium as much as I have while learning and writing all of it. This issue was a nice exploit exercise and I think it would have been harder to exploit if Zygote didn’t weaken ASLR on Android. Now that we know how the vulnerability works and its pattern, we can write more security documentation, give insight to our developers into how to write Mojo interfaces with no such pattern and proactively find vulnerabilities on our security reviews. Furthermore, Google has been working hard to mitigate UAF issues through efforts such as PartitionAlloc everywhere, MiraclePtr and *Scan. We are looking forward to making contributions and working with them to make these vulnerabilities harder to exploit." /><meta property="og:description" content="Introduction Back in 2020 while reviewing Chromium code, I found issue 1068395, a Use-After-Free in Browser Process that can be used to escape the Chromium sandbox on Android Devices. This is an interesting vulnerability as it’s a bug pattern that keeps happening in the Chromium codebase. Having a good understanding of this pattern and how an attacker can exploit it is a good exercise to gain knowledge as well as inspiration in what to look for when reviewing code and writing new fuzzers. More importantly this can help us learn how we can mitigate such bug patterns. Today, we will explore how issue 1068395 can be exploited assuming a compromised Renderer Process (using a vulnerability like 1126249). What Is a RenderFrameHost? Whenever a website is navigated to, the Browser Process will spawn a new Renderer Process. This process will parse the website’s content, such as JavaScript, HTML, and CSS and display it on its main frame. To track the main frame and communicate with it, the Browser Process will instantiate a RenderFrameHostImpl (RFH) object to represent the Renderer’s main frame. Complicating things further, a website may have multiple “child-frames” (a.k.a iframes) that will embed another page context inside the main frame which can be created and destroyed at any moment by JavaScript. If the embedded origin is the same as the main frame, the Renderer Process will create a “frame” object and track it using a frame-tree data structure. The Browser Process will mirror this behavior and create a new RFH object for each new child frame. However, if the contexts have a different origin, the Browser Process will spawn a new Renderer Process due to site isolation. For us, the behavior described previously may be read as: We control the RFH’s object creation and destruction (or its lifetime) from JavaScript! Can we leverage such behavior to find security vulnerabilities? RenderFrameHost and Mojo interfaces Nowadays, modern web-browsers are implemented with a multi-process architecture in mind. In this model, we have untrusted content parsed in a very restrictive/locked-down process (a.k.a a “sandboxed process”). To provide resource access to such a locked-down process, we have a “broker process”. In our case, this is the “browser process”. The browser process can provide access to these restricted resources via a mechanism called Inter-Process-Communication (IPC). Chromium has two IPC mechanisms, the old-IPC/Legacy IPC and Mojo IPC. Nowadays, most features that want to expose resources to the Renderer Process (untrusted/sandboxed process) do it by using a Mojo interface. These interfaces are described using a mojom file, for example (from mojo_and_services.md): 1 2 3 4 interface PingResponder { // Receives a &quot;Ping&quot; and responds with a random integer. Ping() =&gt; (int32 random); }; A Mojo interface is usually bound per-frame, therefore, every time an iframe is created and you request to bind to new a Mojo interface, it may end up allocating a new Mojo interface object in Browser Process (or bind into an existing one). If you are curious about what interfaces are exposed to an iframe, you can check the browser_interface_binders.cc. There is a “trick” here, as explained by BrowserInterfaceBroker, different “execution types” (a.k.a iframe/document, service workers and so on), may have a different binder function (thus, different set of interfaces exposed), it can be observed in PopulateServiceWorkerBinders and PopulateFrameBinders. (sidenote: Monitoring the commit changes in browser_interface_binders.cc is a nice method to find new Mojo Interfaces!). Many objects accessible over Mojo don’t need access to the web page itself and are there to just facilitate access to privileged operations not allowed in the sandbox. However, there are situations that a Mojo interface object may require to access to the RFH object that has instantiated it, like accessing its RFH’s WebContentsImpl object, accessing its RenderFrameProcess object and so on. One way to accomplish this is by providing a raw pointer to the RFH that has instantiated the interface in the Mojo interface object constructor. The constructor can then store this pointer as a class member. You can observe such behavior in the SensorProviderProxyImpl: 1 2 3 4 5 6 7 8 9 SensorProviderProxyImpl::SensorProviderProxyImpl( PermissionControllerImpl* permission_controller, RenderFrameHost* render_frame_host) : permission_controller_(permission_controller), render_frame_host_(render_frame_host) { // [1] DCHECK(permission_controller); DCHECK(render_frame_host); } As you can see at [1], SensorProviderProxyImpl will store the raw pointer for the RFH that has instantiated it as a member. Now, there is a question, can we guarantee that the Mojo interface will not outlive (stay alive longer than) RFH object? The answer can be found by checking how the Mojo interface object gets created. Let’s look at the code below. 1 2 3 4 5 6 7 8 9 10 void RenderFrameHostImpl::GetSensorProvider( mojo::PendingReceiver&lt;device::mojom::SensorProvider&gt; receiver) { if (!sensor_provider_proxy_) { sensor_provider_proxy_ = std::make_unique&lt;SensorProviderProxyImpl&gt;( // [2] PermissionControllerImpl::FromBrowserContext( GetProcess()-&gt;GetBrowserContext()), this); } sensor_provider_proxy_-&gt;Bind(std::move(receiver)); } The SensorProvider Mojo interface object is a member variable in the RenderFrameHostImpl class [2]. If the sensor_provider_proxy_ has not been initialized yet, it’ll instantiate a std::unique_ptr for it. So, we can guarantee that SensorProviderProxyImpl object will be destroyed once the RFH object gets destroyed as their lifetimes are tied to each other! However, Chromium is a complex code-base and things aren’t always that easy; there are other ways in which Mojo interface objects may be created. For example, one may be instantiated by using Mojo::MakeSelfOwnedReceiver. The documentation states: “A self-owned receiver exists as a standalone object which owns its interface implementation and automatically cleans itself up when its bound interface endpoint detects an error.” In other words, the lifetime for the Mojo interface object is tied with its mojo connection: so, if the mojo connection stays alive, the Mojo interface object will stay alive as well (more details in here). This means both sides of the mojo connection (Browser and Renderer Process) control the object lifetime; this is explained well in “Virtually Unlimited Memory: Escaping the Chrome Sandbox” by Mark Brand). That also means that we can have a situation where UI thread will destroy the RFH object, and the Mojo connection is still alive (as it is self-owned) and processing mojo messages until the bind detects an error or that it was closed. Thus, if during this time-window the Mojo interface object processes a message that will access the freed RFH object, we will have a Use-After-Free (UAF) issue. This is an example of the problem that most of the vulnerabilities linked to in the introduction end up exploiting. It has been exploited by many researchers, explained in other blogposts, like “Escaping the Chrome Sandbox” and in CTFs like PlaidCTF. Chromium does have some features to mitigate such problems, and we will go through some examples: WebContentsObserver: If your Mojo interface implementation inherits from this class, you will be provided with a set of callback events (virtual methods) that may be overridden by your implementation. Among these callbacks, we have RenderFrameDeleted, which gets triggered every time an RFH object gets deleted. We can observe its use in InstalledAppProviderImpl. This class was used to fix the vulnerability described in “Escaping the Chrome Sandbox”. 1 2 3 4 5 6 void InstalledAppProviderImpl::RenderFrameDeleted( RenderFrameHost* render_frame_host) { if (render_frame_host_ == render_frame_host) { render_frame_host_ = nullptr; } } FrameServiceBase: This class is similar to WebContentsObserver, however, it implements all callbacks for you and guarantees that the implementation object gets freed as soon as the RFH object that created it gets deleted. By using one of the mechanisms mentioned above, you can guarantee that the Mojo Interfaces you own won’t have Use-After-Free issues with RFH objects. Now that we understand the complexities of Mojo interfaces and RFH, and the problems that can arise from their mismanagement, we can start looking around to see if we can find a vulnerability :). Enter SmsReceiver! Like all normal people do at 4AM, I was using Chromium Code Search to read around Chromium’s source code. While looking around the commit changes for browser_interface_binders.cc to check for new Mojo interfaces and other related changes, SmsService caught my eye. Let’s see how the Mojo interface object is created. 1 2 3 4 5 6 7 8 9 10 11 12 void RenderFrameHostImpl::BindSmsReceiverReceiver( mojo::PendingReceiver&lt;blink::mojom::SmsReceiver&gt; receiver) { if (GetParent() &amp;&amp; !GetMainFrame()-&gt;GetLastCommittedOrigin().IsSameOriginWith( GetLastCommittedOrigin())) { mojo::ReportBadMessage(&quot;Must have the same origin as the top-level frame.&quot;); return; } auto* fetcher = SmsFetcher::Get(GetProcess()-&gt;GetBrowserContext(), this); // [3] SmsService::Create(fetcher, this, std::move(receiver)); // [4] } First, it’ll call SmsFetcher::Get with the BrowserContext and this (RFH object reference) as arguments [3]; we will come back for SmsFetcher::Get later, but for now, all we need to know is that it’ll return a pointer to an SmsFetcher object. Afterwards, we will end up calling SmsService::Create with the SmsFetcher object pointer and this (RFH object reference) as argument [4]. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // static void SmsService::Create( SmsFetcher* fetcher, RenderFrameHost* host, mojo::PendingReceiver&lt;blink::mojom::SmsReceiver&gt; receiver) { DCHECK(host); // SmsService owns itself. It will self-destruct when a Mojo interface // error occurs, the render frame host is deleted, or the render frame host // navigates to a new document. new SmsService(fetcher, host, std::move(receiver)); // [5] } SmsService::SmsService( SmsFetcher* fetcher, const url::Origin&amp; origin, RenderFrameHost* host, mojo::PendingReceiver&lt;blink::mojom::SmsReceiver&gt; receiver) : FrameServiceBase(host, std::move(receiver)), // [6] fetcher_(fetcher), origin_(origin) {} As the code-comments explained, the Mojo interface object owns itself [5]. It isn’t using mojo::MakeSelfOwnedReceiver, but SmsService inherits from FrameServiceBase [6], which has a similar effect. In the SmsService constructor we can see it will initialize the FrameServiceBase [6] with our RFH object reference so it can track the RFH object state. As we have already learned, FrameServiceBase will guarantee that the mojo interface object gets deleted as soon as the RFH object gets deleted, therefore, there is no UAF here. Oh well, no bugs here. Let’s move to another mojo interface implementation… wait… Actually, let’s go all the way back to BindSmsReceiverReceiver function. In particular the line below: 1 auto* fetcher = SmsFetcher::Get(GetProcess()-&gt;GetBrowserContext(), this); // [7] As already mentioned, this function will create (or get an already created) SmsFetcher object and return it [7], let’s look further: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 SmsFetcher* SmsFetcher::Get(BrowserContext* context, RenderFrameHost* rfh) { auto* stored_fetcher = static_cast&lt;SmsFetcherImpl*&gt;( context-&gt;GetUserData(kSmsFetcherImplKeyName)); // [8] if (!stored_fetcher || !stored_fetcher-&gt;CanReceiveSms()) { // [9] auto fetcher = std::make_unique&lt;SmsFetcherImpl&gt;(context, SmsProvider::Create(rfh)); context-&gt;SetUserData(kSmsFetcherImplKeyName, std::move(fetcher)); } return static_cast&lt;SmsFetcherImpl*&gt;( context-&gt;GetUserData(kSmsFetcherImplKeyName)); // [10] } The first thing the code does is check if BrowserContext has a SmsFtecherObject stored within it [8], which implies that SmsFetcher lifetime is tied with BrowserContext lifetime! If it both exists and can receive SMS message [9], it will just return a reference to it at [10]. However, if it cannot receive SMS messages or is not created, it will create a new SmsFetcherImpl object [9]. The SmsFetcherImpl constructor expects an SmsProvider object that is created by calling its Create method with our RFH object as an argument. Now, let’s look at the SmsProvider::Create method. (Trivia: Ooops, there was another vulnerability around here: 1070609). 1 2 3 4 5 6 7 8 9 10 11 12 13 // static std::unique_ptr&lt;SmsProvider&gt; SmsProvider::Create(RenderFrameHost* rfh) { #if defined(OS_ANDROID) if (base::CommandLine::ForCurrentProcess()-&gt;GetSwitchValueASCII( switches::kWebOtpBackend) == switches::kWebOtpBackendSmsVerification) { return std::make_unique&lt;SmsProviderGmsVerification&gt;(); } return std::make_unique&lt;SmsProviderGmsUserConsent&gt;(rfh); // [11] #else return nullptr; #endif } There are two SmsProvider types: SmsProviderGmsVerification: Not interesting for us, as it will not take the RFH as argument anyway. SmsProviderGmsUserConsent: It’ll receive the RFH raw pointer as an argument for its constructor [11]. Looks promising, let’s keep looking. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 SmsProviderGmsUserConsent::SmsProviderGmsUserConsent(RenderFrameHost* rfh) : SmsProvider(), render_frame_host_(rfh) { // [12] // This class is constructed a single time whenever the // first web page uses the SMS Retriever API to wait for // SMSes. JNIEnv* env = AttachCurrentThread(); j_sms_receiver_.Reset(Java_SmsUserConsentReceiver_create( env, reinterpret_cast&lt;intptr_t&gt;(this))); } void SmsProviderGmsUserConsent::Retrieve() { JNIEnv* env = AttachCurrentThread(); WebContents* web_contents = WebContents::FromRenderFrameHost(render_frame_host_); // [13] if (!web_contents || !web_contents-&gt;GetTopLevelNativeWindow()) return; Java_SmsUserConsentReceiver_listen( env, j_sms_receiver_, web_contents-&gt;GetTopLevelNativeWindow()-&gt;GetJavaObject()); } Oh! So, we will store the raw pointer for the RFH object as a member variable inside the SmsProviderGmsUserConsent [12] class. That looks dangerous. Also we will end up accessing it whenever we call the Retrieve method [13]. Unless there is some mechanism that ensures the RFH has not been deleted (spoilers: there aren’t) it may lead to a UAF. Now, to understand better, let’s create an “ownership/reference map”, after creating SmsFetcherImpl object, we will end up with something similar to: As we all love to study chromium code base, one of the things we have learned by watching “Anatomy of the browser 201 (Chrome University 2019)” is that the BrowserContext is pretty much our current Profile. This means it’ll stay alive longer than objects like WebContentsImpl and RenderFrameHostImpl! We also have learned that we won’t always create a new SmsFetcherImpl. Instead, we will create it once and provide a reference to it every time a new SmsService is created. This smells like a chance for a UAF as we will keep reusing the same RFH object pointer (inside SmsProviderGmsUserConsent) for all new SmsProvider Mojo interface instances. Indeed, we will have a problem here, as the first time we create a SmsProviderGmsUserConsent, it’ll store a reference to the RFH object that created it. However, we know that SmsFetcherImpl will keep reusing SmsProviderGmsUserConsent even after the RFH object is deleted, as there aren’t any mechanisms to ensure that RFH object hasn’t been deleted! Therefore, if we have a new RFH object that binds to the SmsService interface, the SmsService object will store a raw pointer to the SmsFetcherImpl object containing the SmsProviderGmsUserConsent which holds a dangling RFH pointer. To illustrate it, let’s look at the diagram below. Create an iframe and bind to SmsReceiver Create another iframe and Bind to SmsReceiver Delete the first iframe (aka iframe A), thus, it’s iframe A’s RFH object gets deleted, but we still have a reference to it in SmsProviderGmsUserConsent. Call receive in SmsReceiver for iframe B As you can see, at the end, iframe B’s SmsService may end up dereferencing a freed RFH! Unfortunately, FrameServiceBase cannot save us from this problem, in the end we will have a Use-After-Free issue. Now, we have found a cool vulnerability, let’s try to use it to achieve code execution in Browser Process context! Exploiting the Issue At this point we know that SmsProviderGmsUserConsent::Retrieve will end up using our freed RFH for some operations. Let’s take a look at how exactly it is used: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void SmsProviderGmsUserConsent::Retrieve() { JNIEnv* env = AttachCurrentThread(); WebContents* web_contents = WebContents::FromRenderFrameHost(render_frame_host_); // [14] if (!web_contents || !web_contents-&gt;GetTopLevelNativeWindow()) return; Java_SmsUserConsentReceiver_listen( env, j_sms_receiver_, web_contents-&gt;GetTopLevelNativeWindow()-&gt;GetJavaObject()); } First, it’ll get a reference to the “freed” RFH and use it as an argument for the function WebContents::FromRenderFrameHost [14]. Then, it’ll return a pointer to the WebContentsImpl object. Finally, it’ll check if the WebContentsImpl isn’t nullptr and execute some Java code, otherwise, it’ll just return early. Now, let’s look at the FromRenderFrameHost implementation: 1 2 3 4 5 6 7 8 9 10 11 12 WebContents* WebContents::FromRenderFrameHost(RenderFrameHost* rfh) { if (!rfh) return nullptr; if (!rfh-&gt;IsCurrent() &amp;&amp; base::FeatureList::IsEnabled( // [15] kCheckWebContentsAccessFromNonCurrentFrame)) { // TODO(crbug.com/1059903): return nullptr here eventually. base::debug::DumpWithoutCrashing(); } return static_cast&lt;RenderFrameHostImpl*&gt;(rfh)-&gt;delegate()-&gt;GetAsWebContents(); // [16] There are two function calls here that use the RFH. The first is at [15], and the second at [16] where it will read a member object inside RFH and call its GetAsWebContents function. These method’s declarations look like the following: 1 2 3 virtual bool IsCurrent() = 0; virtual WebContents* GetAsWebContents(); As you can see both methods are declared virtual. As we know, the compiler will end up creating a virtual table to handle the dynamic dispatch! So, if we can somehow control the “freed” object, and replace its virtual table with a fake one that we control, we could call an arbitrary function pointer. Once we can call an arbitrary pointer, we can use Returned-Oriented-Programming (ROP) or Jump-Oriented-Programming (JOP) and achieve arbitrary code execution. Also, if we can make the GetAsWebContents return nullptr (0x0), we can smoothly continue the browser execution with no crash. Sounds like a nice plan! However, we have a problem here: Address Space Layout Randomization (ASLR). We may have a UAF and we may somehow be able to replace its object virtual table with controlled contents, but we have no idea where .text, .data or heap allocations are as we have no information disclosure vulnerability. We did not get so far to give up! Let’s think about it further. Zygote to Rescue! I was using a Pixel 3A android device as target for my exploit and while I was researching a solution for the ASLR problem, I found out that Android has its own way to launch applications. It is using a concept called “Zygote” and there are many articles giving in-depth details of how it works and its security implications. For us, Zygote essentially means that every new spawned process will share the same ASLR base between them, in another words: Processes can end up sharing the same virtual memory mapping between some shared libraries! That is perfect, as having a remote code execution exploit (taking over Renderer Process by using either a V8 or Blink vulnerability, for example) may help us to easily defeat ASLR as both Renderer Process and Browser process share the same virtual mapping between shared libraries. Do we really need ROP and/or JOP? Essentially, once we can replace the “freed” RFH object in memory with attacker-controlled data, we want to make its virtual table to point to a fake virtual table and jump into any arbitrary function or a stack-pivot for ROP. However, ASLR is still a problem for the heap segments as we have no information about its heap layout. We can bypass the heap problem by calling another object virtual table that will end up writing the RFH this pointer onto itself (and being able to read the object memory back into Renderer Process). That should work; however, there is something even better! Guang Gong has presented a nice technique in “An exploit Chain to Remotely Root Modern Android Devices”. The article explains that the libllvm-glnext.so (that is present in Pixel 3a) has a function pointer to system in its .GOT segment. We can easily replace the RFH virtual table to point into libllvm-glnext.so .GOT and make a call to system! The beauty here is that the system’s function argument is a pointer to the RFH object (aka this) that we fully control! Now we can call system with arbitrary command in context of Browser Process! Feels back into 90s, right? Keeping the Browser alive (CRASH != FUN) Let’s look again at the WebContents::FromenderFrameHost function but from another perspective, the ARM-assembly perspective: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 0x0000000000000000: 10 B5 push {r4, lr} 0x0000000000000002: 98 B1 cbz r0, #0x2c 0x0000000000000004: 04 46 mov r4, r0 // R0 = RFH-&gt;vtable 0x0000000000000006: 00 68 ldr r0, [r0] // R1 = RFH-&gt;vtable[0xBC/0x4] -- system pointer 0x0000000000000008: D0 F8 BC 10 ldr.w r1, [r0, #0xbc] 0x000000000000000c: 20 46 mov r0, r4 // system(R0) 0x000000000000000e: 88 47 blx r1 // [17] 0x0000000000000010: 30 B9 cbnz r0, #0x20 0x0000000000000012: 07 48 ldr r0, [pc, #0x1c] 0x0000000000000014: 78 44 add r0, pc 0x0000000000000016: A9 F1 42 EA blx #0x1a949c 0x000000000000001a: 08 B1 cbz r0, #0x20 0x000000000000001c: A9 F1 06 EE blx #0x1a9c2c // R0 = RFH-&gt;member_7c 0x0000000000000020: E0 6F ldr r0, [r4, #0x7c] // R1 = RFH-&gt;member_7c-&gt;vtable 0x0000000000000022: 01 68 ldr r1, [r0] // R1 = RFH-&gt;member_7c-&gt;vtable[0x64/0x4] 0x0000000000000024: 49 6E ldr r1, [r1, #0x64] 0x0000000000000026: BD E8 10 40 pop.w {r4, lr} // [18] // return R1(), where R1 is a function that will set R0 (return value) to 0 // it&#39;ll make WebContents == nullptr and not crashing the browser :) 0x000000000000002a: 08 47 bx r1 0x000000000000002c: 00 20 movs r0, #0 0x000000000000002e: 10 BD pop {r4, pc} As you can see, there are two virtual function calls. The first call, RFH-&gt;vtable_fptr[0x2F] [17], we can use to call system with controlled arguments. However, the second virtual call, RFH-&gt;member_7C-&gt;vtable_fptr[0x19] [18], is a problem for us. As you already know we have no information disclosure about the heap memory layout, so, we cannot easily fake a member_7C object. So, what is the solution here? Maybe we could just let the browser crash anyway, as we will end up executing the system command before the crash happens… But, let’s be honest, crashing the browser isn’t fun, can we do something else? Yes, Zygote@libllvm-glnext to the rescue again. Do we have such a magic pointer in libllvm-glnext? Yes! At offset 0x8E4BE8 (.GOT segment) we have exactly what we need, we will end up with the following call chain: Now, we can both call system and resume execution smoothly without crashing the browser :) Replacing the Object Alright, at this point we want to replace the object in memory with fully controlled content. What we need here is some heap-spray primitive. We could go and try to find our own, however, let’s not recreate the wheel. We can use the same technique demonstrated by “GPZ Virtually Unlimited Memory”, since it still works and fulfills all our needs. Now, the next step is to find the size of the RFH object size in memory. This is necessary as we increase the chance to reclaim the memory by spraying payloads of the same size as the RFH object. You can do it by using your favorite disassembler, compiler, debugger, or any other tool. In my case, it was 0x880 bytes. However, if you heap spray using the technique above, it may work and reclaim the object, but it may also be a bit unstable. Apparently, on Android, at least for the version that I had when I wrote the exploit, the Browser Process will end up using jemalloc as the default heap allocator. There is enough documentation (that I recommend reading) regarding the allocator internals, thus, I will not go into details here. What is interesting for us is that jemalloc implements thread specific caches. Remember, our target object, the freed RFH, is created and destroyed on UI thread and the heap-spray technique will happen on IO thread. Due to this, we may have our allocations happening in different thread-caches/arenas. As we want to be able to reclaim a freed region (a.k.a our RFH object) from another thread, we need to cause either a flush event or hard event that will end up freeing some bins/regions inside a tcache (each bin has its own tcache, that is a list for the recently freed regions). Once a flush or hard event occurs, the region can now be allocated by other threads. This can be accomplished by first freeing our victim RFH object and then allocating multiple iframes and freeing them. Following this you can spray as normal with your heap-spray primitive. In my tests, this seems to have increased the exploit’s reliability. Putting It All Together Now, using all the knowledge we have learned, let’s summarize how our exploit works: Create a child iframe that will use MojoJS to create and bind to a SmsReceiver interface (thus, creating a SmsProviderGmsUserConsent with a pointer to its RFH). MojoJS can be enabled by a compromised renderer. Send a postMessage from the child iframe to the main frame to tell it the Mojo interface has been created. The main frame can now delete the child iframe with document.body.removeChild. In the main frame, create another SmsReceiver interface. This instantiation will use the already created SmsFetcherImpl which has a raw pointer to the freed RFH object. Prepare our heap payload: The first 4 bytes (32 bit architecture) is the virtual table pointer, it’ll be a pointer to libllvm-glnext.so .got.plt minus 0xBC (offset for virtual table) so we land in the correct address. The next bytes will be our shell command, something of the form “|| (command).” This way it’ll first execute the virtual table address as a “command” and then execute our shell command. For the exploit, I used: &#39; || (toybox nc -p 4444 -l /bin/sh)&#39;). At offset 0x7C of our payload we will have a pointer to the “magic function pointer” in libllvm-glnext.so, so we can guarantee the GetAsWebContents virtual method will return the value 0x0, making SmsProviderGmsUserConsent::Retrieve return early, avoiding a browser crash. Spray these bytes using the same technique learned here, but use the jemalloc trick described earlier to make it more reliable. Call SmsReceiver.receive method and watch the magic! You can find the final exploit here. Conclusion At this point you can run shell commands in the context of Browser Process. Due to the Android security model, you may have limited resource access as you are still inside Android’s application sandbox. The next step would be to chain a kernel vulnerability, as described here, but this is a story for another day. I hope you have enjoyed reading and learning a little more about Chromium as much as I have while learning and writing all of it. This issue was a nice exploit exercise and I think it would have been harder to exploit if Zygote didn’t weaken ASLR on Android. Now that we know how the vulnerability works and its pattern, we can write more security documentation, give insight to our developers into how to write Mojo interfaces with no such pattern and proactively find vulnerabilities on our security reviews. Furthermore, Google has been working hard to mitigate UAF issues through efforts such as PartitionAlloc everywhere, MiraclePtr and *Scan. We are looking forward to making contributions and working with them to make these vulnerabilities harder to exploit." /><link rel="canonical" href="https://microsoftedge.github.io/edgevr/posts/yet-another-uaf/" /><meta property="og:url" content="https://microsoftedge.github.io/edgevr/posts/yet-another-uaf/" /><meta property="og:site_name" content="Microsoft Browser Vulnerability Research" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-03-02T08:00:00-08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Yet another RenderFrameHostImpl UAF" /><meta name="twitter:site" content="@MSEdgeDev" /><meta name="twitter:creator" content="@Lucas P." /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Lucas P."},"description":"Introduction Back in 2020 while reviewing Chromium code, I found issue 1068395, a Use-After-Free in Browser Process that can be used to escape the Chromium sandbox on Android Devices. This is an interesting vulnerability as it’s a bug pattern that keeps happening in the Chromium codebase. Having a good understanding of this pattern and how an attacker can exploit it is a good exercise to gain knowledge as well as inspiration in what to look for when reviewing code and writing new fuzzers. More importantly this can help us learn how we can mitigate such bug patterns. Today, we will explore how issue 1068395 can be exploited assuming a compromised Renderer Process (using a vulnerability like 1126249). What Is a RenderFrameHost? Whenever a website is navigated to, the Browser Process will spawn a new Renderer Process. This process will parse the website’s content, such as JavaScript, HTML, and CSS and display it on its main frame. To track the main frame and communicate with it, the Browser Process will instantiate a RenderFrameHostImpl (RFH) object to represent the Renderer’s main frame. Complicating things further, a website may have multiple “child-frames” (a.k.a iframes) that will embed another page context inside the main frame which can be created and destroyed at any moment by JavaScript. If the embedded origin is the same as the main frame, the Renderer Process will create a “frame” object and track it using a frame-tree data structure. The Browser Process will mirror this behavior and create a new RFH object for each new child frame. However, if the contexts have a different origin, the Browser Process will spawn a new Renderer Process due to site isolation. For us, the behavior described previously may be read as: We control the RFH’s object creation and destruction (or its lifetime) from JavaScript! Can we leverage such behavior to find security vulnerabilities? RenderFrameHost and Mojo interfaces Nowadays, modern web-browsers are implemented with a multi-process architecture in mind. In this model, we have untrusted content parsed in a very restrictive/locked-down process (a.k.a a “sandboxed process”). To provide resource access to such a locked-down process, we have a “broker process”. In our case, this is the “browser process”. The browser process can provide access to these restricted resources via a mechanism called Inter-Process-Communication (IPC). Chromium has two IPC mechanisms, the old-IPC/Legacy IPC and Mojo IPC. Nowadays, most features that want to expose resources to the Renderer Process (untrusted/sandboxed process) do it by using a Mojo interface. These interfaces are described using a mojom file, for example (from mojo_and_services.md): 1 2 3 4 interface PingResponder { // Receives a &quot;Ping&quot; and responds with a random integer. Ping() =&gt; (int32 random); }; A Mojo interface is usually bound per-frame, therefore, every time an iframe is created and you request to bind to new a Mojo interface, it may end up allocating a new Mojo interface object in Browser Process (or bind into an existing one). If you are curious about what interfaces are exposed to an iframe, you can check the browser_interface_binders.cc. There is a “trick” here, as explained by BrowserInterfaceBroker, different “execution types” (a.k.a iframe/document, service workers and so on), may have a different binder function (thus, different set of interfaces exposed), it can be observed in PopulateServiceWorkerBinders and PopulateFrameBinders. (sidenote: Monitoring the commit changes in browser_interface_binders.cc is a nice method to find new Mojo Interfaces!). Many objects accessible over Mojo don’t need access to the web page itself and are there to just facilitate access to privileged operations not allowed in the sandbox. However, there are situations that a Mojo interface object may require to access to the RFH object that has instantiated it, like accessing its RFH’s WebContentsImpl object, accessing its RenderFrameProcess object and so on. One way to accomplish this is by providing a raw pointer to the RFH that has instantiated the interface in the Mojo interface object constructor. The constructor can then store this pointer as a class member. You can observe such behavior in the SensorProviderProxyImpl: 1 2 3 4 5 6 7 8 9 SensorProviderProxyImpl::SensorProviderProxyImpl( PermissionControllerImpl* permission_controller, RenderFrameHost* render_frame_host) : permission_controller_(permission_controller), render_frame_host_(render_frame_host) { // [1] DCHECK(permission_controller); DCHECK(render_frame_host); } As you can see at [1], SensorProviderProxyImpl will store the raw pointer for the RFH that has instantiated it as a member. Now, there is a question, can we guarantee that the Mojo interface will not outlive (stay alive longer than) RFH object? The answer can be found by checking how the Mojo interface object gets created. Let’s look at the code below. 1 2 3 4 5 6 7 8 9 10 void RenderFrameHostImpl::GetSensorProvider( mojo::PendingReceiver&lt;device::mojom::SensorProvider&gt; receiver) { if (!sensor_provider_proxy_) { sensor_provider_proxy_ = std::make_unique&lt;SensorProviderProxyImpl&gt;( // [2] PermissionControllerImpl::FromBrowserContext( GetProcess()-&gt;GetBrowserContext()), this); } sensor_provider_proxy_-&gt;Bind(std::move(receiver)); } The SensorProvider Mojo interface object is a member variable in the RenderFrameHostImpl class [2]. If the sensor_provider_proxy_ has not been initialized yet, it’ll instantiate a std::unique_ptr for it. So, we can guarantee that SensorProviderProxyImpl object will be destroyed once the RFH object gets destroyed as their lifetimes are tied to each other! However, Chromium is a complex code-base and things aren’t always that easy; there are other ways in which Mojo interface objects may be created. For example, one may be instantiated by using Mojo::MakeSelfOwnedReceiver. The documentation states: “A self-owned receiver exists as a standalone object which owns its interface implementation and automatically cleans itself up when its bound interface endpoint detects an error.” In other words, the lifetime for the Mojo interface object is tied with its mojo connection: so, if the mojo connection stays alive, the Mojo interface object will stay alive as well (more details in here). This means both sides of the mojo connection (Browser and Renderer Process) control the object lifetime; this is explained well in “Virtually Unlimited Memory: Escaping the Chrome Sandbox” by Mark Brand). That also means that we can have a situation where UI thread will destroy the RFH object, and the Mojo connection is still alive (as it is self-owned) and processing mojo messages until the bind detects an error or that it was closed. Thus, if during this time-window the Mojo interface object processes a message that will access the freed RFH object, we will have a Use-After-Free (UAF) issue. This is an example of the problem that most of the vulnerabilities linked to in the introduction end up exploiting. It has been exploited by many researchers, explained in other blogposts, like “Escaping the Chrome Sandbox” and in CTFs like PlaidCTF. Chromium does have some features to mitigate such problems, and we will go through some examples: WebContentsObserver: If your Mojo interface implementation inherits from this class, you will be provided with a set of callback events (virtual methods) that may be overridden by your implementation. Among these callbacks, we have RenderFrameDeleted, which gets triggered every time an RFH object gets deleted. We can observe its use in InstalledAppProviderImpl. This class was used to fix the vulnerability described in “Escaping the Chrome Sandbox”. 1 2 3 4 5 6 void InstalledAppProviderImpl::RenderFrameDeleted( RenderFrameHost* render_frame_host) { if (render_frame_host_ == render_frame_host) { render_frame_host_ = nullptr; } } FrameServiceBase: This class is similar to WebContentsObserver, however, it implements all callbacks for you and guarantees that the implementation object gets freed as soon as the RFH object that created it gets deleted. By using one of the mechanisms mentioned above, you can guarantee that the Mojo Interfaces you own won’t have Use-After-Free issues with RFH objects. Now that we understand the complexities of Mojo interfaces and RFH, and the problems that can arise from their mismanagement, we can start looking around to see if we can find a vulnerability :). Enter SmsReceiver! Like all normal people do at 4AM, I was using Chromium Code Search to read around Chromium’s source code. While looking around the commit changes for browser_interface_binders.cc to check for new Mojo interfaces and other related changes, SmsService caught my eye. Let’s see how the Mojo interface object is created. 1 2 3 4 5 6 7 8 9 10 11 12 void RenderFrameHostImpl::BindSmsReceiverReceiver( mojo::PendingReceiver&lt;blink::mojom::SmsReceiver&gt; receiver) { if (GetParent() &amp;&amp; !GetMainFrame()-&gt;GetLastCommittedOrigin().IsSameOriginWith( GetLastCommittedOrigin())) { mojo::ReportBadMessage(&quot;Must have the same origin as the top-level frame.&quot;); return; } auto* fetcher = SmsFetcher::Get(GetProcess()-&gt;GetBrowserContext(), this); // [3] SmsService::Create(fetcher, this, std::move(receiver)); // [4] } First, it’ll call SmsFetcher::Get with the BrowserContext and this (RFH object reference) as arguments [3]; we will come back for SmsFetcher::Get later, but for now, all we need to know is that it’ll return a pointer to an SmsFetcher object. Afterwards, we will end up calling SmsService::Create with the SmsFetcher object pointer and this (RFH object reference) as argument [4]. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // static void SmsService::Create( SmsFetcher* fetcher, RenderFrameHost* host, mojo::PendingReceiver&lt;blink::mojom::SmsReceiver&gt; receiver) { DCHECK(host); // SmsService owns itself. It will self-destruct when a Mojo interface // error occurs, the render frame host is deleted, or the render frame host // navigates to a new document. new SmsService(fetcher, host, std::move(receiver)); // [5] } SmsService::SmsService( SmsFetcher* fetcher, const url::Origin&amp; origin, RenderFrameHost* host, mojo::PendingReceiver&lt;blink::mojom::SmsReceiver&gt; receiver) : FrameServiceBase(host, std::move(receiver)), // [6] fetcher_(fetcher), origin_(origin) {} As the code-comments explained, the Mojo interface object owns itself [5]. It isn’t using mojo::MakeSelfOwnedReceiver, but SmsService inherits from FrameServiceBase [6], which has a similar effect. In the SmsService constructor we can see it will initialize the FrameServiceBase [6] with our RFH object reference so it can track the RFH object state. As we have already learned, FrameServiceBase will guarantee that the mojo interface object gets deleted as soon as the RFH object gets deleted, therefore, there is no UAF here. Oh well, no bugs here. Let’s move to another mojo interface implementation… wait… Actually, let’s go all the way back to BindSmsReceiverReceiver function. In particular the line below: 1 auto* fetcher = SmsFetcher::Get(GetProcess()-&gt;GetBrowserContext(), this); // [7] As already mentioned, this function will create (or get an already created) SmsFetcher object and return it [7], let’s look further: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 SmsFetcher* SmsFetcher::Get(BrowserContext* context, RenderFrameHost* rfh) { auto* stored_fetcher = static_cast&lt;SmsFetcherImpl*&gt;( context-&gt;GetUserData(kSmsFetcherImplKeyName)); // [8] if (!stored_fetcher || !stored_fetcher-&gt;CanReceiveSms()) { // [9] auto fetcher = std::make_unique&lt;SmsFetcherImpl&gt;(context, SmsProvider::Create(rfh)); context-&gt;SetUserData(kSmsFetcherImplKeyName, std::move(fetcher)); } return static_cast&lt;SmsFetcherImpl*&gt;( context-&gt;GetUserData(kSmsFetcherImplKeyName)); // [10] } The first thing the code does is check if BrowserContext has a SmsFtecherObject stored within it [8], which implies that SmsFetcher lifetime is tied with BrowserContext lifetime! If it both exists and can receive SMS message [9], it will just return a reference to it at [10]. However, if it cannot receive SMS messages or is not created, it will create a new SmsFetcherImpl object [9]. The SmsFetcherImpl constructor expects an SmsProvider object that is created by calling its Create method with our RFH object as an argument. Now, let’s look at the SmsProvider::Create method. (Trivia: Ooops, there was another vulnerability around here: 1070609). 1 2 3 4 5 6 7 8 9 10 11 12 13 // static std::unique_ptr&lt;SmsProvider&gt; SmsProvider::Create(RenderFrameHost* rfh) { #if defined(OS_ANDROID) if (base::CommandLine::ForCurrentProcess()-&gt;GetSwitchValueASCII( switches::kWebOtpBackend) == switches::kWebOtpBackendSmsVerification) { return std::make_unique&lt;SmsProviderGmsVerification&gt;(); } return std::make_unique&lt;SmsProviderGmsUserConsent&gt;(rfh); // [11] #else return nullptr; #endif } There are two SmsProvider types: SmsProviderGmsVerification: Not interesting for us, as it will not take the RFH as argument anyway. SmsProviderGmsUserConsent: It’ll receive the RFH raw pointer as an argument for its constructor [11]. Looks promising, let’s keep looking. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 SmsProviderGmsUserConsent::SmsProviderGmsUserConsent(RenderFrameHost* rfh) : SmsProvider(), render_frame_host_(rfh) { // [12] // This class is constructed a single time whenever the // first web page uses the SMS Retriever API to wait for // SMSes. JNIEnv* env = AttachCurrentThread(); j_sms_receiver_.Reset(Java_SmsUserConsentReceiver_create( env, reinterpret_cast&lt;intptr_t&gt;(this))); } void SmsProviderGmsUserConsent::Retrieve() { JNIEnv* env = AttachCurrentThread(); WebContents* web_contents = WebContents::FromRenderFrameHost(render_frame_host_); // [13] if (!web_contents || !web_contents-&gt;GetTopLevelNativeWindow()) return; Java_SmsUserConsentReceiver_listen( env, j_sms_receiver_, web_contents-&gt;GetTopLevelNativeWindow()-&gt;GetJavaObject()); } Oh! So, we will store the raw pointer for the RFH object as a member variable inside the SmsProviderGmsUserConsent [12] class. That looks dangerous. Also we will end up accessing it whenever we call the Retrieve method [13]. Unless there is some mechanism that ensures the RFH has not been deleted (spoilers: there aren’t) it may lead to a UAF. Now, to understand better, let’s create an “ownership/reference map”, after creating SmsFetcherImpl object, we will end up with something similar to: As we all love to study chromium code base, one of the things we have learned by watching “Anatomy of the browser 201 (Chrome University 2019)” is that the BrowserContext is pretty much our current Profile. This means it’ll stay alive longer than objects like WebContentsImpl and RenderFrameHostImpl! We also have learned that we won’t always create a new SmsFetcherImpl. Instead, we will create it once and provide a reference to it every time a new SmsService is created. This smells like a chance for a UAF as we will keep reusing the same RFH object pointer (inside SmsProviderGmsUserConsent) for all new SmsProvider Mojo interface instances. Indeed, we will have a problem here, as the first time we create a SmsProviderGmsUserConsent, it’ll store a reference to the RFH object that created it. However, we know that SmsFetcherImpl will keep reusing SmsProviderGmsUserConsent even after the RFH object is deleted, as there aren’t any mechanisms to ensure that RFH object hasn’t been deleted! Therefore, if we have a new RFH object that binds to the SmsService interface, the SmsService object will store a raw pointer to the SmsFetcherImpl object containing the SmsProviderGmsUserConsent which holds a dangling RFH pointer. To illustrate it, let’s look at the diagram below. Create an iframe and bind to SmsReceiver Create another iframe and Bind to SmsReceiver Delete the first iframe (aka iframe A), thus, it’s iframe A’s RFH object gets deleted, but we still have a reference to it in SmsProviderGmsUserConsent. Call receive in SmsReceiver for iframe B As you can see, at the end, iframe B’s SmsService may end up dereferencing a freed RFH! Unfortunately, FrameServiceBase cannot save us from this problem, in the end we will have a Use-After-Free issue. Now, we have found a cool vulnerability, let’s try to use it to achieve code execution in Browser Process context! Exploiting the Issue At this point we know that SmsProviderGmsUserConsent::Retrieve will end up using our freed RFH for some operations. Let’s take a look at how exactly it is used: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void SmsProviderGmsUserConsent::Retrieve() { JNIEnv* env = AttachCurrentThread(); WebContents* web_contents = WebContents::FromRenderFrameHost(render_frame_host_); // [14] if (!web_contents || !web_contents-&gt;GetTopLevelNativeWindow()) return; Java_SmsUserConsentReceiver_listen( env, j_sms_receiver_, web_contents-&gt;GetTopLevelNativeWindow()-&gt;GetJavaObject()); } First, it’ll get a reference to the “freed” RFH and use it as an argument for the function WebContents::FromRenderFrameHost [14]. Then, it’ll return a pointer to the WebContentsImpl object. Finally, it’ll check if the WebContentsImpl isn’t nullptr and execute some Java code, otherwise, it’ll just return early. Now, let’s look at the FromRenderFrameHost implementation: 1 2 3 4 5 6 7 8 9 10 11 12 WebContents* WebContents::FromRenderFrameHost(RenderFrameHost* rfh) { if (!rfh) return nullptr; if (!rfh-&gt;IsCurrent() &amp;&amp; base::FeatureList::IsEnabled( // [15] kCheckWebContentsAccessFromNonCurrentFrame)) { // TODO(crbug.com/1059903): return nullptr here eventually. base::debug::DumpWithoutCrashing(); } return static_cast&lt;RenderFrameHostImpl*&gt;(rfh)-&gt;delegate()-&gt;GetAsWebContents(); // [16] There are two function calls here that use the RFH. The first is at [15], and the second at [16] where it will read a member object inside RFH and call its GetAsWebContents function. These method’s declarations look like the following: 1 2 3 virtual bool IsCurrent() = 0; virtual WebContents* GetAsWebContents(); As you can see both methods are declared virtual. As we know, the compiler will end up creating a virtual table to handle the dynamic dispatch! So, if we can somehow control the “freed” object, and replace its virtual table with a fake one that we control, we could call an arbitrary function pointer. Once we can call an arbitrary pointer, we can use Returned-Oriented-Programming (ROP) or Jump-Oriented-Programming (JOP) and achieve arbitrary code execution. Also, if we can make the GetAsWebContents return nullptr (0x0), we can smoothly continue the browser execution with no crash. Sounds like a nice plan! However, we have a problem here: Address Space Layout Randomization (ASLR). We may have a UAF and we may somehow be able to replace its object virtual table with controlled contents, but we have no idea where .text, .data or heap allocations are as we have no information disclosure vulnerability. We did not get so far to give up! Let’s think about it further. Zygote to Rescue! I was using a Pixel 3A android device as target for my exploit and while I was researching a solution for the ASLR problem, I found out that Android has its own way to launch applications. It is using a concept called “Zygote” and there are many articles giving in-depth details of how it works and its security implications. For us, Zygote essentially means that every new spawned process will share the same ASLR base between them, in another words: Processes can end up sharing the same virtual memory mapping between some shared libraries! That is perfect, as having a remote code execution exploit (taking over Renderer Process by using either a V8 or Blink vulnerability, for example) may help us to easily defeat ASLR as both Renderer Process and Browser process share the same virtual mapping between shared libraries. Do we really need ROP and/or JOP? Essentially, once we can replace the “freed” RFH object in memory with attacker-controlled data, we want to make its virtual table to point to a fake virtual table and jump into any arbitrary function or a stack-pivot for ROP. However, ASLR is still a problem for the heap segments as we have no information about its heap layout. We can bypass the heap problem by calling another object virtual table that will end up writing the RFH this pointer onto itself (and being able to read the object memory back into Renderer Process). That should work; however, there is something even better! Guang Gong has presented a nice technique in “An exploit Chain to Remotely Root Modern Android Devices”. The article explains that the libllvm-glnext.so (that is present in Pixel 3a) has a function pointer to system in its .GOT segment. We can easily replace the RFH virtual table to point into libllvm-glnext.so .GOT and make a call to system! The beauty here is that the system’s function argument is a pointer to the RFH object (aka this) that we fully control! Now we can call system with arbitrary command in context of Browser Process! Feels back into 90s, right? Keeping the Browser alive (CRASH != FUN) Let’s look again at the WebContents::FromenderFrameHost function but from another perspective, the ARM-assembly perspective: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 0x0000000000000000: 10 B5 push {r4, lr} 0x0000000000000002: 98 B1 cbz r0, #0x2c 0x0000000000000004: 04 46 mov r4, r0 // R0 = RFH-&gt;vtable 0x0000000000000006: 00 68 ldr r0, [r0] // R1 = RFH-&gt;vtable[0xBC/0x4] -- system pointer 0x0000000000000008: D0 F8 BC 10 ldr.w r1, [r0, #0xbc] 0x000000000000000c: 20 46 mov r0, r4 // system(R0) 0x000000000000000e: 88 47 blx r1 // [17] 0x0000000000000010: 30 B9 cbnz r0, #0x20 0x0000000000000012: 07 48 ldr r0, [pc, #0x1c] 0x0000000000000014: 78 44 add r0, pc 0x0000000000000016: A9 F1 42 EA blx #0x1a949c 0x000000000000001a: 08 B1 cbz r0, #0x20 0x000000000000001c: A9 F1 06 EE blx #0x1a9c2c // R0 = RFH-&gt;member_7c 0x0000000000000020: E0 6F ldr r0, [r4, #0x7c] // R1 = RFH-&gt;member_7c-&gt;vtable 0x0000000000000022: 01 68 ldr r1, [r0] // R1 = RFH-&gt;member_7c-&gt;vtable[0x64/0x4] 0x0000000000000024: 49 6E ldr r1, [r1, #0x64] 0x0000000000000026: BD E8 10 40 pop.w {r4, lr} // [18] // return R1(), where R1 is a function that will set R0 (return value) to 0 // it&#39;ll make WebContents == nullptr and not crashing the browser :) 0x000000000000002a: 08 47 bx r1 0x000000000000002c: 00 20 movs r0, #0 0x000000000000002e: 10 BD pop {r4, pc} As you can see, there are two virtual function calls. The first call, RFH-&gt;vtable_fptr[0x2F] [17], we can use to call system with controlled arguments. However, the second virtual call, RFH-&gt;member_7C-&gt;vtable_fptr[0x19] [18], is a problem for us. As you already know we have no information disclosure about the heap memory layout, so, we cannot easily fake a member_7C object. So, what is the solution here? Maybe we could just let the browser crash anyway, as we will end up executing the system command before the crash happens… But, let’s be honest, crashing the browser isn’t fun, can we do something else? Yes, Zygote@libllvm-glnext to the rescue again. Do we have such a magic pointer in libllvm-glnext? Yes! At offset 0x8E4BE8 (.GOT segment) we have exactly what we need, we will end up with the following call chain: Now, we can both call system and resume execution smoothly without crashing the browser :) Replacing the Object Alright, at this point we want to replace the object in memory with fully controlled content. What we need here is some heap-spray primitive. We could go and try to find our own, however, let’s not recreate the wheel. We can use the same technique demonstrated by “GPZ Virtually Unlimited Memory”, since it still works and fulfills all our needs. Now, the next step is to find the size of the RFH object size in memory. This is necessary as we increase the chance to reclaim the memory by spraying payloads of the same size as the RFH object. You can do it by using your favorite disassembler, compiler, debugger, or any other tool. In my case, it was 0x880 bytes. However, if you heap spray using the technique above, it may work and reclaim the object, but it may also be a bit unstable. Apparently, on Android, at least for the version that I had when I wrote the exploit, the Browser Process will end up using jemalloc as the default heap allocator. There is enough documentation (that I recommend reading) regarding the allocator internals, thus, I will not go into details here. What is interesting for us is that jemalloc implements thread specific caches. Remember, our target object, the freed RFH, is created and destroyed on UI thread and the heap-spray technique will happen on IO thread. Due to this, we may have our allocations happening in different thread-caches/arenas. As we want to be able to reclaim a freed region (a.k.a our RFH object) from another thread, we need to cause either a flush event or hard event that will end up freeing some bins/regions inside a tcache (each bin has its own tcache, that is a list for the recently freed regions). Once a flush or hard event occurs, the region can now be allocated by other threads. This can be accomplished by first freeing our victim RFH object and then allocating multiple iframes and freeing them. Following this you can spray as normal with your heap-spray primitive. In my tests, this seems to have increased the exploit’s reliability. Putting It All Together Now, using all the knowledge we have learned, let’s summarize how our exploit works: Create a child iframe that will use MojoJS to create and bind to a SmsReceiver interface (thus, creating a SmsProviderGmsUserConsent with a pointer to its RFH). MojoJS can be enabled by a compromised renderer. Send a postMessage from the child iframe to the main frame to tell it the Mojo interface has been created. The main frame can now delete the child iframe with document.body.removeChild. In the main frame, create another SmsReceiver interface. This instantiation will use the already created SmsFetcherImpl which has a raw pointer to the freed RFH object. Prepare our heap payload: The first 4 bytes (32 bit architecture) is the virtual table pointer, it’ll be a pointer to libllvm-glnext.so .got.plt minus 0xBC (offset for virtual table) so we land in the correct address. The next bytes will be our shell command, something of the form “|| (command).” This way it’ll first execute the virtual table address as a “command” and then execute our shell command. For the exploit, I used: &#39; || (toybox nc -p 4444 -l /bin/sh)&#39;). At offset 0x7C of our payload we will have a pointer to the “magic function pointer” in libllvm-glnext.so, so we can guarantee the GetAsWebContents virtual method will return the value 0x0, making SmsProviderGmsUserConsent::Retrieve return early, avoiding a browser crash. Spray these bytes using the same technique learned here, but use the jemalloc trick described earlier to make it more reliable. Call SmsReceiver.receive method and watch the magic! You can find the final exploit here. Conclusion At this point you can run shell commands in the context of Browser Process. Due to the Android security model, you may have limited resource access as you are still inside Android’s application sandbox. The next step would be to chain a kernel vulnerability, as described here, but this is a story for another day. I hope you have enjoyed reading and learning a little more about Chromium as much as I have while learning and writing all of it. This issue was a nice exploit exercise and I think it would have been harder to exploit if Zygote didn’t weaken ASLR on Android. Now that we know how the vulnerability works and its pattern, we can write more security documentation, give insight to our developers into how to write Mojo interfaces with no such pattern and proactively find vulnerabilities on our security reviews. Furthermore, Google has been working hard to mitigate UAF issues through efforts such as PartitionAlloc everywhere, MiraclePtr and *Scan. We are looking forward to making contributions and working with them to make these vulnerabilities harder to exploit.","url":"https://microsoftedge.github.io/edgevr/posts/yet-another-uaf/","@type":"BlogPosting","headline":"Yet another RenderFrameHostImpl UAF","dateModified":"2021-03-02T08:00:00-08:00","datePublished":"2021-03-02T08:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://microsoftedge.github.io/edgevr/posts/yet-another-uaf/"},"@context":"https://schema.org"}</script> <!-- The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps Generated by: https://www.favicon-generator.org/ v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT license --><link rel="shortcut icon" href="/edgevr/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/edgevr/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/edgevr/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/edgevr/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/edgevr/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/edgevr/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/edgevr/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/edgevr/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/edgevr/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/edgevr/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/edgevr/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/edgevr/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/edgevr/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/edgevr/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/edgevr/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/edgevr/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/edgevr/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/edgevr/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/edgevr/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/edgevr/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"> <!-- CSS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --><link rel="preload" as="style" href="/edgevr/assets/css/post.css"><link rel="stylesheet" href="/edgevr/assets/css/post.css"><link rel="preload" as="style" href="/edgevr/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/edgevr/assets/css/lib/bootstrap-toc.min.css" /><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" async></script> <script type="text/javascript"> (function(c,l,a,r,i,t,y){ c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)}; t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i; y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y); })(window, document, "clarity", "script", "4xpt5cebre"); </script> <!-- JS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --> <script src="/edgevr/assets/js/post.min.js" async></script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script> <script src="/edgevr/app.js" defer></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"> <!-- The Side Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="/edgevr/" alt="avatar"> <img src="/edgevr/assets/img/edge-logo-128x128.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/edgevr/">Microsoft Browser <b>Vulnerability Research</b></a></div><div class="site-subtitle font-italic">News from the lab</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/edgevr/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/edgevr/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/edgevr/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/edgevr/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a></li></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper" style="margin-right: 9px;"> <!-- Switch the mode between dark and light. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightkMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightkMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border" style="display:none;"></span> <a href="https://github.com/MicrosoftEdge" target="_blank"> <i class="fab fa-github-alt"></i> </a> <a href="/edgevr/feed.xml" > <i class="fas fa-rss"></i> </a></div></div><!-- The Top Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/edgevr/"> Posts </a> </span> <span>Yet another RenderFrameHostImpl UAF</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"> <!-- Fixed kramdown code highlight rendering: https://github.com/penibelst/jekyll-compress-html/issues/101 https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901 --><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Yet another RenderFrameHostImpl UAF</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Mar 2, 2021, 8:00 AM -0800" > Mar 2, 2021 <i class="unloaded">2021-03-02T08:00:00-08:00</i> </span> by <span class="author"> Lucas P. </span></div></div><div class="post-content"><h1 id="introduction">Introduction</h1><p>Back in 2020 while reviewing Chromium code, I found issue <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1068395">1068395</a>, a Use-After-Free in Browser Process that can be used to escape the Chromium sandbox on Android Devices. <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1134480">This</a> <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1101509">is</a> <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1128270">an</a> <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1122917">interesting</a> vulnerability as it’s a bug pattern <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1078671">that</a> keeps <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1106342">happening</a> in the Chromium codebase.</p><p>Having a good understanding of this pattern and how an attacker can exploit it is a good exercise to gain knowledge as well as inspiration in what to look for when reviewing code and writing new fuzzers. More importantly this can help us learn how we can mitigate such bug patterns.</p><p>Today, we will explore how issue <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1068395">1068395</a> can be exploited assuming a compromised Renderer Process (using a vulnerability like <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1126249">1126249</a>).</p><h1 id="what-is-a-renderframehost">What Is a RenderFrameHost?</h1><p>Whenever a website is navigated to, the Browser Process will spawn a new Renderer Process. This process will parse the website’s content, such as JavaScript, HTML, and CSS and display it on its main frame. To track the main frame and communicate with it, the Browser Process will instantiate a <a href="https://source.chromium.org/chromium/chromium/src/+/master:content/browser/renderer_host/render_frame_host_impl.h;l=252;drc=8f5b7ee843864f30c9483a8c64afa0433e2e9b90"><code class="language-plaintext highlighter-rouge">RenderFrameHostImpl</code> (RFH) object</a> to represent the Renderer’s main frame.</p><p>Complicating things further, a website may have multiple “child-frames” (a.k.a iframes) that will embed another page context inside the main frame which can be created and destroyed at any moment by JavaScript. If the embedded origin is the same as the main frame, the Renderer Process will create a “frame” object and track it using a frame-tree data structure. The Browser Process will mirror this behavior and create a new <a href="https://source.chromium.org/chromium/chromium/src/+/master:content/browser/renderer_host/frame_tree_node.h;l=53;drc=8f5b7ee843864f30c9483a8c64afa0433e2e9b90">RFH object for each new child frame</a>. However, if the contexts have a different origin, the Browser Process will spawn a new <a href="https://www.chromium.org/developers/design-documents/site-isolation">Renderer Process due to site isolation</a>.</p><p>For us, the behavior described previously may be read as: We control the RFH’s object creation and destruction (or its lifetime) from JavaScript! Can we leverage such behavior to find security vulnerabilities?</p><h3 id="renderframehost-and-mojo-interfaces">RenderFrameHost and Mojo interfaces</h3><p>Nowadays, modern web-browsers are implemented with a multi-process architecture in mind. In this model, we have untrusted content parsed in a very restrictive/locked-down process (a.k.a a “sandboxed process”). To provide resource access to such a locked-down process, we have a “broker process”. In our case, this is the “browser process”. The browser process can provide access to these restricted resources via a <a href="https://en.wikipedia.org/wiki/Inter-process_communication">mechanism called Inter-Process-Communication (IPC)</a>.</p><p>Chromium has two IPC mechanisms, <a href="https://chromium.googlesource.com/chromium/src/+/master/docs/mojo_ipc_conversion.md">the old-IPC/Legacy IPC</a> and <a href="https://chromium.googlesource.com/chromium/src/+/master/mojo/README.md">Mojo IPC</a>. Nowadays, most features that want to expose resources to the Renderer Process (untrusted/sandboxed process) do it by <a href="https://chromium.googlesource.com/chromium/src/+/master/docs/mojo_and_services.md">using a Mojo interface</a>. These interfaces are described using a mojom file, for example (from <a href="https://chromium.googlesource.com/chromium/src/+/master/docs/mojo_and_services.md">mojo_and_services.md</a>):</p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">interface</span> <span class="n">PingResponder</span> <span class="p">{</span>
  <span class="c1">// Receives a "Ping" and responds with a random integer.</span>
  <span class="n">Ping</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">int32</span> <span class="n">random</span><span class="p">);</span>
<span class="p">};</span>
</pre></table></code></div></div><p>A Mojo interface is usually bound per-frame, therefore, every time an iframe is created and you request to bind to new a Mojo interface, it may end up allocating a new Mojo interface object in Browser Process (or bind into an existing one). If you are curious about what interfaces are exposed to an iframe, you can check the <a href="https://source.chromium.org/chromium/chromium/src/+/master:content/browser/browser_interface_binders.cc;drc=8f5b7ee843864f30c9483a8c64afa0433e2e9b90">browser_interface_binders.cc</a>. There is a “trick” here, as explained by <a href="https://source.chromium.org/chromium/chromium/src/+/master:content/browser/browser_interface_broker_impl.h;l=32;drc=8f5b7ee843864f30c9483a8c64afa0433e2e9b90"><code class="language-plaintext highlighter-rouge">BrowserInterfaceBroker</code></a>, different “execution types” (a.k.a iframe/document, service workers and so on), may have a different binder function (thus, different set of interfaces exposed), it can be observed in <a href="https://source.chromium.org/chromium/chromium/src/+/master:content/browser/browser_interface_binders.cc;l=1114;drc=8f5b7ee843864f30c9483a8c64afa0433e2e9b90"><code class="language-plaintext highlighter-rouge">PopulateServiceWorkerBinders</code></a> and <a href="https://source.chromium.org/chromium/chromium/src/+/master:content/browser/browser_interface_binders.cc;l=553;drc=8f5b7ee843864f30c9483a8c64afa0433e2e9b90"><code class="language-plaintext highlighter-rouge">PopulateFrameBinders</code></a>. (sidenote: Monitoring the commit changes in <a href="https://source.chromium.org/chromium/chromium/src/+/master:content/browser/browser_interface_binders.cc;drc=8f5b7ee843864f30c9483a8c64afa0433e2e9b90">browser_interface_binders.cc</a> is a nice method to find new Mojo Interfaces!).</p><p>Many objects accessible over Mojo don’t need access to the web page itself and are there to just facilitate access to privileged operations not allowed in the sandbox. However, there are situations that a Mojo interface object may require to access to the <a href="https://source.chromium.org/chromium/chromium/src/+/master:content/browser/generic_sensor/sensor_provider_proxy_impl.cc;l=38;drc=8f5b7ee843864f30c9483a8c64afa0433e2e9b90">RFH object that has instantiated it</a>, like accessing its RFH’s <code class="language-plaintext highlighter-rouge">WebContentsImpl</code> object, accessing its <code class="language-plaintext highlighter-rouge">RenderFrameProcess</code> object and so on.</p><p>One way to accomplish this is by providing a raw pointer to the RFH that has instantiated the interface in the Mojo interface object constructor. The constructor can then store this pointer as a class member. You can observe such behavior in the <a href="https://source.chromium.org/chromium/chromium/src/+/master:content/browser/generic_sensor/sensor_provider_proxy_impl.cc;l=38;drc=8f5b7ee843864f30c9483a8c64afa0433e2e9b90"><code class="language-plaintext highlighter-rouge">SensorProviderProxyImpl</code></a>:</p><p><a id="code-note-1"></a></p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">SensorProviderProxyImpl</span><span class="o">::</span><span class="n">SensorProviderProxyImpl</span><span class="p">(</span>
    <span class="n">PermissionControllerImpl</span><span class="o">*</span> <span class="n">permission_controller</span><span class="p">,</span>
    <span class="n">RenderFrameHost</span><span class="o">*</span> <span class="n">render_frame_host</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">permission_controller_</span><span class="p">(</span><span class="n">permission_controller</span><span class="p">),</span>
      <span class="n">render_frame_host_</span><span class="p">(</span><span class="n">render_frame_host</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// [1]</span>

  <span class="n">DCHECK</span><span class="p">(</span><span class="n">permission_controller</span><span class="p">);</span>
  <span class="n">DCHECK</span><span class="p">(</span><span class="n">render_frame_host</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>As you can see at <a href="#code-note-1">[1]</a>, <a href="https://source.chromium.org/chromium/chromium/src/+/master:content/browser/generic_sensor/sensor_provider_proxy_impl.cc;l=38;drc=8f5b7ee843864f30c9483a8c64afa0433e2e9b90"><code class="language-plaintext highlighter-rouge">SensorProviderProxyImpl</code></a> will store the raw pointer for the RFH that has instantiated it as a member. Now, there is a question, can we guarantee that the Mojo interface will not outlive (stay alive longer than) RFH object? The answer can be found by checking how the Mojo interface object gets created. Let’s look at the code below.</p><p><a id="code-note-2"></a></p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">RenderFrameHostImpl</span><span class="o">::</span><span class="n">GetSensorProvider</span><span class="p">(</span>
    <span class="n">mojo</span><span class="o">::</span><span class="n">PendingReceiver</span><span class="o">&lt;</span><span class="n">device</span><span class="o">::</span><span class="n">mojom</span><span class="o">::</span><span class="n">SensorProvider</span><span class="o">&gt;</span> <span class="n">receiver</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sensor_provider_proxy_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sensor_provider_proxy_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">SensorProviderProxyImpl</span><span class="o">&gt;</span><span class="p">(</span> <span class="c1">// [2]</span>
        <span class="n">PermissionControllerImpl</span><span class="o">::</span><span class="n">FromBrowserContext</span><span class="p">(</span>
            <span class="n">GetProcess</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetBrowserContext</span><span class="p">()),</span>
        <span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">sensor_provider_proxy_</span><span class="o">-&gt;</span><span class="n">Bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">receiver</span><span class="p">));</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The <code class="language-plaintext highlighter-rouge">SensorProvider</code> Mojo interface object is a member variable in the <code class="language-plaintext highlighter-rouge">RenderFrameHostImpl</code> class <a href="#code-note-2">[2]</a>. If the <code class="language-plaintext highlighter-rouge">sensor_provider_proxy_</code> has not been initialized yet, it’ll instantiate a <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr"><code class="language-plaintext highlighter-rouge">std::unique_ptr</code></a> for it. So, we can guarantee that <a href="https://source.chromium.org/chromium/chromium/src/+/master:content/browser/generic_sensor/sensor_provider_proxy_impl.cc;l=38;drc=8f5b7ee843864f30c9483a8c64afa0433e2e9b90"><code class="language-plaintext highlighter-rouge">SensorProviderProxyImpl</code></a> object will be destroyed once the RFH object gets destroyed as their lifetimes are tied to each other!</p><p>However, Chromium is a complex code-base and things aren’t always that easy; there are other ways in which Mojo interface objects may be created. For example, one may be instantiated by using <a href="https://source.chromium.org/chromium/chromium/src/+/master:mojo/public/cpp/bindings/self_owned_receiver.h;l=22;drc=9db96f40a036ecfdf6ef4498f622cda70a548126"><code class="language-plaintext highlighter-rouge">Mojo::MakeSelfOwnedReceiver</code></a>. <a href="https://chromium.googlesource.com/chromium/src/+/master/mojo/public/cpp/bindings/README.md">The documentation</a> states: “A self-owned receiver exists as a standalone object which owns its interface implementation and automatically cleans itself up when its bound interface endpoint detects an error.”</p><p>In other words, the lifetime for the Mojo interface object is tied with its mojo connection: so, if the mojo connection stays alive, the Mojo interface object will stay alive as well (more details in <a href="https://source.chromium.org/chromium/chromium/src/+/master:mojo/public/cpp/bindings/strong_binding.h;l=45;drc=9db96f40a036ecfdf6ef4498f622cda70a548126">here</a>). This means both sides of the mojo connection (Browser and Renderer Process) control the object lifetime; this is explained well in <a href="https://googleprojectzero.blogspot.com/2019/04/virtually-unlimited-memory-escaping.html">“Virtually Unlimited Memory: Escaping the Chrome Sandbox”</a> by Mark Brand).</p><p>That also means that we can have a situation where UI thread will destroy the RFH object, and the Mojo connection is still alive (as it is self-owned) and processing mojo messages until the bind detects an error or that it was closed. Thus, if during this time-window the Mojo interface object processes a message that will access the freed RFH object, we will have a Use-After-Free (UAF) issue.</p><p>This is an example of the problem that most of the vulnerabilities linked to in the introduction end up exploiting. It has been exploited by many researchers, explained in other blogposts, like <a href="https://theori.io/research/escaping-chrome-sandbox/">“Escaping the Chrome Sandbox”</a> and in CTFs like <a href="https://ctftime.org/task/11314">PlaidCTF</a>.</p><p>Chromium does have some features to mitigate such problems, and we will go through some examples:</p><ul><li><p><a href="https://source.chromium.org/chromium/chromium/src/+/master:content/public/browser/web_contents_observer.h;l=77;drc=618ce5c74c6749614a9dce25d1aa593a5389176b"><code class="language-plaintext highlighter-rouge">WebContentsObserver</code></a>: If your Mojo interface implementation inherits from this class, you will be provided with a set of callback events (virtual methods) that may be overridden by your implementation. Among these callbacks, we have <code class="language-plaintext highlighter-rouge">RenderFrameDeleted</code>, which gets triggered every time an RFH object gets deleted.</p><p>We can observe its use in <a href="https://source.chromium.org/chromium/chromium/src/+/master:content/browser/installedapp/installed_app_provider_impl.cc;l=69;drc=618ce5c74c6749614a9dce25d1aa593a5389176b"><code class="language-plaintext highlighter-rouge">InstalledAppProviderImpl</code></a>. This class was used to fix the vulnerability described in <a href="https://theori.io/research/escaping-chrome-sandbox/">“Escaping the Chrome Sandbox”</a>.</p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">InstalledAppProviderImpl</span><span class="o">::</span><span class="n">RenderFrameDeleted</span><span class="p">(</span>
    <span class="n">RenderFrameHost</span><span class="o">*</span> <span class="n">render_frame_host</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">render_frame_host_</span> <span class="o">==</span> <span class="n">render_frame_host</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">render_frame_host_</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div></li><li><p><a href="https://source.chromium.org/chromium/chromium/src/+/master:content/public/browser/frame_service_base.h;l=36;drc=618ce5c74c6749614a9dce25d1aa593a5389176b"><code class="language-plaintext highlighter-rouge">FrameServiceBase</code></a>: This class is similar to <code class="language-plaintext highlighter-rouge">WebContentsObserver</code>, however, it implements all callbacks for you and guarantees that the implementation object gets freed as soon as the RFH object that created it gets deleted.</p></li></ul><p>By using one of the mechanisms mentioned above, you can guarantee that the Mojo Interfaces you own won’t have Use-After-Free issues with RFH objects.</p><p>Now that we understand the complexities of Mojo interfaces and RFH, and the problems that can arise from their mismanagement, we can start looking around to see if we can find a vulnerability :).</p><h1 id="enter-smsreceiver">Enter SmsReceiver!</h1><p>Like all normal people do at 4AM, I was using <a href="https://source.chromium.org/chromium">Chromium Code Search</a> to read around Chromium’s source code. While looking around the commit changes for <a href="https://source.chromium.org/chromium/chromium/src/+/master:content/browser/browser_interface_binders.cc;drc=8f5b7ee843864f30c9483a8c64afa0433e2e9b90">browser_interface_binders.cc</a> to check for new Mojo interfaces and other related changes, <code class="language-plaintext highlighter-rouge">SmsService</code> caught my eye. Let’s see how the Mojo interface object is created.</p><p><a id="code-note-3"></a> <a id="code-note-4"></a></p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">RenderFrameHostImpl</span><span class="o">::</span><span class="n">BindSmsReceiverReceiver</span><span class="p">(</span>
    <span class="n">mojo</span><span class="o">::</span><span class="n">PendingReceiver</span><span class="o">&lt;</span><span class="n">blink</span><span class="o">::</span><span class="n">mojom</span><span class="o">::</span><span class="n">SmsReceiver</span><span class="o">&gt;</span> <span class="n">receiver</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">GetParent</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">GetMainFrame</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetLastCommittedOrigin</span><span class="p">().</span><span class="n">IsSameOriginWith</span><span class="p">(</span>
                         <span class="n">GetLastCommittedOrigin</span><span class="p">()))</span> <span class="p">{</span>
    <span class="n">mojo</span><span class="o">::</span><span class="n">ReportBadMessage</span><span class="p">(</span><span class="s">"Must have the same origin as the top-level frame."</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">auto</span><span class="o">*</span> <span class="n">fetcher</span> <span class="o">=</span> <span class="n">SmsFetcher</span><span class="o">::</span><span class="n">Get</span><span class="p">(</span><span class="n">GetProcess</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetBrowserContext</span><span class="p">(),</span> <span class="k">this</span><span class="p">);</span> <span class="c1">// [3]</span>
  <span class="n">SmsService</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">fetcher</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">receiver</span><span class="p">));</span> <span class="c1">// [4]</span>
<span class="p">}</span>
</pre></table></code></div></div><p>First, it’ll call <code class="language-plaintext highlighter-rouge">SmsFetcher::Get</code> with the <code class="language-plaintext highlighter-rouge">BrowserContext</code> and <code class="language-plaintext highlighter-rouge">this</code> (RFH object reference) as arguments <a href="#code-note-3">[3]</a>; we will come back for <code class="language-plaintext highlighter-rouge">SmsFetcher::Get</code> later, but for now, all we need to know is that it’ll return a pointer to an <code class="language-plaintext highlighter-rouge">SmsFetcher</code> object. Afterwards, we will end up calling <a href="https://source.chromium.org/chromium/chromium/src/+/master:content/browser/sms/sms_service.cc;drc=28442cacc3be1a7d05a898aba663025a143095ac?originalUrl=https:%2F%2Fcs.chromium.org%2F"><code class="language-plaintext highlighter-rouge">SmsService::Create</code></a> with the <code class="language-plaintext highlighter-rouge">SmsFetcher</code> object pointer and <code class="language-plaintext highlighter-rouge">this</code> (RFH object reference) as argument <a href="#code-note-4">[4]</a>.</p><p><a id="code-note-5"></a> <a id="code-note-6"></a></p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">// static</span>
<span class="kt">void</span> <span class="n">SmsService</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span>
    <span class="n">SmsFetcher</span><span class="o">*</span> <span class="n">fetcher</span><span class="p">,</span>
    <span class="n">RenderFrameHost</span><span class="o">*</span> <span class="n">host</span><span class="p">,</span>
    <span class="n">mojo</span><span class="o">::</span><span class="n">PendingReceiver</span><span class="o">&lt;</span><span class="n">blink</span><span class="o">::</span><span class="n">mojom</span><span class="o">::</span><span class="n">SmsReceiver</span><span class="o">&gt;</span> <span class="n">receiver</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DCHECK</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

  <span class="c1">// SmsService owns itself. It will self-destruct when a Mojo interface</span>
  <span class="c1">// error occurs, the render frame host is deleted, or the render frame host</span>
  <span class="c1">// navigates to a new document.</span>
  <span class="k">new</span> <span class="n">SmsService</span><span class="p">(</span><span class="n">fetcher</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">receiver</span><span class="p">));</span> <span class="c1">// [5]</span>
<span class="p">}</span>

<span class="n">SmsService</span><span class="o">::</span><span class="n">SmsService</span><span class="p">(</span>
    <span class="n">SmsFetcher</span><span class="o">*</span> <span class="n">fetcher</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">url</span><span class="o">::</span><span class="n">Origin</span><span class="o">&amp;</span> <span class="n">origin</span><span class="p">,</span>
    <span class="n">RenderFrameHost</span><span class="o">*</span> <span class="n">host</span><span class="p">,</span>
    <span class="n">mojo</span><span class="o">::</span><span class="n">PendingReceiver</span><span class="o">&lt;</span><span class="n">blink</span><span class="o">::</span><span class="n">mojom</span><span class="o">::</span><span class="n">SmsReceiver</span><span class="o">&gt;</span> <span class="n">receiver</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">FrameServiceBase</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">receiver</span><span class="p">)),</span> <span class="c1">// [6]</span>
      <span class="n">fetcher_</span><span class="p">(</span><span class="n">fetcher</span><span class="p">),</span>
      <span class="n">origin_</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span> <span class="p">{}</span>
</pre></table></code></div></div><p>As the code-comments explained, the Mojo interface object owns itself <a href="#code-note-5">[5]</a>. It isn’t using <code class="language-plaintext highlighter-rouge">mojo::MakeSelfOwnedReceiver</code>, but <code class="language-plaintext highlighter-rouge">SmsService</code> inherits from <code class="language-plaintext highlighter-rouge">FrameServiceBase</code> <a href="#code-note-6">[6]</a>, which has a similar effect. In the <code class="language-plaintext highlighter-rouge">SmsService</code> constructor we can see it will initialize the <code class="language-plaintext highlighter-rouge">FrameServiceBase</code> <a href="#code-note-6">[6]</a> with our RFH object reference so it can track the RFH object state.</p><p>As we have already learned, <code class="language-plaintext highlighter-rouge">FrameServiceBase</code> will guarantee that the mojo interface object gets deleted as soon as the RFH object gets deleted, therefore, there is no UAF here. Oh well, no bugs here. Let’s move to another mojo interface implementation… wait… Actually, let’s go all the way back to <code class="language-plaintext highlighter-rouge">BindSmsReceiverReceiver</code> function.</p><p>In particular the line below:</p><p><a id="code-note-7"></a></p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">auto</span><span class="o">*</span> <span class="n">fetcher</span> <span class="o">=</span> <span class="n">SmsFetcher</span><span class="o">::</span><span class="n">Get</span><span class="p">(</span><span class="n">GetProcess</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetBrowserContext</span><span class="p">(),</span> <span class="k">this</span><span class="p">);</span> <span class="c1">// [7]</span>
</pre></table></code></div></div><p>As already mentioned, this function will create (or get an already created) <a href="https://source.chromium.org/chromium/chromium/src/+/master:content/browser/sms/sms_fetcher_impl.cc;l=42;drc=28442cacc3be1a7d05a898aba663025a143095ac?originalUrl=https:%2F%2Fcs.chromium.org%2F">SmsFetcher object</a> and return it <a href="#code-note-7">[7]</a>, let’s look further:</p><p><a id="code-note-8"></a> <a id="code-note-9"></a> <a id="code-note-10"></a></p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="n">SmsFetcher</span><span class="o">*</span> <span class="n">SmsFetcher</span><span class="o">::</span><span class="n">Get</span><span class="p">(</span><span class="n">BrowserContext</span><span class="o">*</span> <span class="n">context</span><span class="p">,</span> <span class="n">RenderFrameHost</span><span class="o">*</span> <span class="n">rfh</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">auto</span><span class="o">*</span> <span class="n">stored_fetcher</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">SmsFetcherImpl</span><span class="o">*&gt;</span><span class="p">(</span>
      <span class="n">context</span><span class="o">-&gt;</span><span class="n">GetUserData</span><span class="p">(</span><span class="n">kSmsFetcherImplKeyName</span><span class="p">));</span> <span class="c1">// [8]</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stored_fetcher</span> <span class="o">||</span> <span class="o">!</span><span class="n">stored_fetcher</span><span class="o">-&gt;</span><span class="n">CanReceiveSms</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// [9]</span>
    <span class="k">auto</span> <span class="n">fetcher</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">SmsFetcherImpl</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">SmsProvider</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">rfh</span><span class="p">));</span>
    <span class="n">context</span><span class="o">-&gt;</span><span class="n">SetUserData</span><span class="p">(</span><span class="n">kSmsFetcherImplKeyName</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">fetcher</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">SmsFetcherImpl</span><span class="o">*&gt;</span><span class="p">(</span>
      <span class="n">context</span><span class="o">-&gt;</span><span class="n">GetUserData</span><span class="p">(</span><span class="n">kSmsFetcherImplKeyName</span><span class="p">));</span> <span class="c1">// [10]</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The first thing the code does is check if <code class="language-plaintext highlighter-rouge">BrowserContext</code> has a <code class="language-plaintext highlighter-rouge">SmsFtecherObject</code> stored within it <a href="#code-note-8">[8]</a>, which implies that <code class="language-plaintext highlighter-rouge">SmsFetcher</code> lifetime is tied with <code class="language-plaintext highlighter-rouge">BrowserContext</code> lifetime! If it both exists and can receive SMS message <a href="#code-note-9">[9]</a>, it will just return a reference to it at <a href="#code-note-10">[10]</a>.</p><p>However, if it cannot receive SMS messages or is not created, it will create a new <code class="language-plaintext highlighter-rouge">SmsFetcherImpl</code> object <a href="#code-note-9">[9]</a>. The <code class="language-plaintext highlighter-rouge">SmsFetcherImpl</code> constructor expects an <a href="https://source.chromium.org/chromium/chromium/src/+/master:content/browser/sms/sms_provider.cc;drc=28442cacc3be1a7d05a898aba663025a143095ac?originalUrl=https:%2F%2Fcs.chromium.org%2F">SmsProvider object</a> that is created by calling its Create method with our RFH object as an argument. Now, let’s look at the <code class="language-plaintext highlighter-rouge">SmsProvider::Create</code> method. (Trivia: Ooops, there was another vulnerability around here: <a href="https://crbug.com/1070609">1070609</a>).</p><p><a id="code-note-11"></a></p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c1">// static</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SmsProvider</span><span class="o">&gt;</span> <span class="n">SmsProvider</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">RenderFrameHost</span><span class="o">*</span> <span class="n">rfh</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if defined(OS_ANDROID)
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="o">::</span><span class="n">CommandLine</span><span class="o">::</span><span class="n">ForCurrentProcess</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetSwitchValueASCII</span><span class="p">(</span>
          <span class="n">switches</span><span class="o">::</span><span class="n">kWebOtpBackend</span><span class="p">)</span> <span class="o">==</span>
      <span class="n">switches</span><span class="o">::</span><span class="n">kWebOtpBackendSmsVerification</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">SmsProviderGmsVerification</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">SmsProviderGmsUserConsent</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rfh</span><span class="p">);</span> <span class="c1">// [11]</span>
<span class="cp">#else
</span>  <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="p">}</span>
</pre></table></code></div></div><p>There are two <code class="language-plaintext highlighter-rouge">SmsProvider</code> types:</p><ul><li><code class="language-plaintext highlighter-rouge">SmsProviderGmsVerification</code>: Not interesting for us, as it will not take the RFH as argument anyway.</li><li><a href="https://source.chromium.org/chromium/chromium/src/+/master:content/browser/sms/sms_provider_gms_user_consent.cc;drc=28442cacc3be1a7d05a898aba663025a143095ac;l=22"><code class="language-plaintext highlighter-rouge">SmsProviderGmsUserConsent</code></a>: It’ll receive the RFH raw pointer as an argument for its constructor <a href="#code-note-11">[11]</a>. Looks promising, let’s keep looking.</li></ul><p><a id="code-note-12"></a> <a id="code-note-13"></a></p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="n">SmsProviderGmsUserConsent</span><span class="o">::</span><span class="n">SmsProviderGmsUserConsent</span><span class="p">(</span><span class="n">RenderFrameHost</span><span class="o">*</span> <span class="n">rfh</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">SmsProvider</span><span class="p">(),</span> <span class="n">render_frame_host_</span><span class="p">(</span><span class="n">rfh</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// [12]</span>
  <span class="c1">// This class is constructed a single time whenever the</span>
  <span class="c1">// first web page uses the SMS Retriever API to wait for</span>
  <span class="c1">// SMSes.</span>
  <span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span> <span class="o">=</span> <span class="n">AttachCurrentThread</span><span class="p">();</span>
  <span class="n">j_sms_receiver_</span><span class="p">.</span><span class="n">Reset</span><span class="p">(</span><span class="n">Java_SmsUserConsentReceiver_create</span><span class="p">(</span>
      <span class="n">env</span><span class="p">,</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">intptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">)));</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">SmsProviderGmsUserConsent</span><span class="o">::</span><span class="n">Retrieve</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span> <span class="o">=</span> <span class="n">AttachCurrentThread</span><span class="p">();</span>

  <span class="n">WebContents</span><span class="o">*</span> <span class="n">web_contents</span> <span class="o">=</span>
      <span class="n">WebContents</span><span class="o">::</span><span class="n">FromRenderFrameHost</span><span class="p">(</span><span class="n">render_frame_host_</span><span class="p">);</span> <span class="c1">// [13]</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">web_contents</span> <span class="o">||</span> <span class="o">!</span><span class="n">web_contents</span><span class="o">-&gt;</span><span class="n">GetTopLevelNativeWindow</span><span class="p">())</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="n">Java_SmsUserConsentReceiver_listen</span><span class="p">(</span>
      <span class="n">env</span><span class="p">,</span> <span class="n">j_sms_receiver_</span><span class="p">,</span>
      <span class="n">web_contents</span><span class="o">-&gt;</span><span class="n">GetTopLevelNativeWindow</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetJavaObject</span><span class="p">());</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Oh! So, we will store the raw pointer for the RFH object as a member variable inside the <code class="language-plaintext highlighter-rouge">SmsProviderGmsUserConsent</code> <a href="#code-note-12">[12]</a> class. That looks dangerous. Also we will end up accessing it whenever we call the Retrieve method <a href="#code-note-13">[13]</a>. Unless there is some mechanism that ensures the RFH has not been deleted (spoilers: there aren’t) it may lead to a UAF. Now, to understand better, let’s create an “ownership/reference map”, after creating <code class="language-plaintext highlighter-rouge">SmsFetcherImpl</code> object, we will end up with something similar to:</p><center><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://microsoftedge.github.io/edgevr/assets/img/blog_img/yarfuaf/SmsFetcherImpl.svg" /></center><p>As we all love to study chromium code base, one of the things we have learned by watching <a href="https://www.youtube.com/watch?v=u7berRU9Qys">“Anatomy of the browser 201 (Chrome University 2019)”</a> is that the <code class="language-plaintext highlighter-rouge">BrowserContext</code> is pretty much our current <code class="language-plaintext highlighter-rouge">Profile</code>. This means it’ll stay alive longer than objects like <code class="language-plaintext highlighter-rouge">WebContentsImpl</code> and <code class="language-plaintext highlighter-rouge">RenderFrameHostImpl</code>!</p><p>We also have learned that we won’t always create a new <code class="language-plaintext highlighter-rouge">SmsFetcherImpl</code>. Instead, we will create it once and provide a reference to it every time a new <code class="language-plaintext highlighter-rouge">SmsService</code> is created. This smells like a chance for a UAF as we will keep reusing the same RFH object pointer (inside <code class="language-plaintext highlighter-rouge">SmsProviderGmsUserConsent</code>) for all new <code class="language-plaintext highlighter-rouge">SmsProvider</code> Mojo interface instances.</p><p>Indeed, we will have a problem here, as the first time we create a <code class="language-plaintext highlighter-rouge">SmsProviderGmsUserConsent</code>, it’ll store a reference to the RFH object that created it. However, we know that <code class="language-plaintext highlighter-rouge">SmsFetcherImpl</code> will keep reusing <code class="language-plaintext highlighter-rouge">SmsProviderGmsUserConsent</code> even after the RFH object is deleted, as there aren’t any mechanisms to ensure that RFH object hasn’t been deleted!</p><p>Therefore, if we have a new RFH object that binds to the <code class="language-plaintext highlighter-rouge">SmsService</code> interface, the <code class="language-plaintext highlighter-rouge">SmsService</code> object will store a raw pointer to the <code class="language-plaintext highlighter-rouge">SmsFetcherImpl</code> object containing the <code class="language-plaintext highlighter-rouge">SmsProviderGmsUserConsent</code> which holds a dangling RFH pointer.</p><p>To illustrate it, let’s look at the diagram below.</p><ul><li>Create an iframe and bind to <code class="language-plaintext highlighter-rouge">SmsReceiver</code></li></ul><center><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://microsoftedge.github.io/edgevr/assets/img/blog_img/yarfuaf/iframe_bind_1.svg" /></center><ul><li>Create another iframe and Bind to <code class="language-plaintext highlighter-rouge">SmsReceiver</code></li></ul><center><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://microsoftedge.github.io/edgevr/assets/img/blog_img/yarfuaf/iframe_bind_2.svg" /></center><ul><li><p>Delete the first iframe (aka iframe A), thus, it’s iframe A’s RFH object gets deleted, but we still have a reference to it in <code class="language-plaintext highlighter-rouge">SmsProviderGmsUserConsent</code>.</p></li><li><p>Call receive in <code class="language-plaintext highlighter-rouge">SmsReceiver</code> for iframe B</p></li></ul><center><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://microsoftedge.github.io/edgevr/assets/img/blog_img/yarfuaf/iframe_bind_3.png" /></center><p>As you can see, at the end, iframe B’s <code class="language-plaintext highlighter-rouge">SmsService</code> may end up dereferencing a freed RFH! Unfortunately, <code class="language-plaintext highlighter-rouge">FrameServiceBase</code> cannot save us from this problem, in the end we will have a Use-After-Free issue.</p><p>Now, we have found a cool vulnerability, let’s try to use it to achieve code execution in Browser Process context!</p><h1 id="exploiting-the-issue">Exploiting the Issue</h1><p>At this point we know that <code class="language-plaintext highlighter-rouge">SmsProviderGmsUserConsent::Retrieve</code> will end up using our freed RFH for some operations. Let’s take a look at how exactly it is used:</p><p><a id="code-note-14"></a></p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">SmsProviderGmsUserConsent</span><span class="o">::</span><span class="n">Retrieve</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span> <span class="o">=</span> <span class="n">AttachCurrentThread</span><span class="p">();</span>

  <span class="n">WebContents</span><span class="o">*</span> <span class="n">web_contents</span> <span class="o">=</span>
      <span class="n">WebContents</span><span class="o">::</span><span class="n">FromRenderFrameHost</span><span class="p">(</span><span class="n">render_frame_host_</span><span class="p">);</span> <span class="c1">// [14]</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">web_contents</span> <span class="o">||</span> <span class="o">!</span><span class="n">web_contents</span><span class="o">-&gt;</span><span class="n">GetTopLevelNativeWindow</span><span class="p">())</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="n">Java_SmsUserConsentReceiver_listen</span><span class="p">(</span>
      <span class="n">env</span><span class="p">,</span> <span class="n">j_sms_receiver_</span><span class="p">,</span>
      <span class="n">web_contents</span><span class="o">-&gt;</span><span class="n">GetTopLevelNativeWindow</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetJavaObject</span><span class="p">());</span>
<span class="p">}</span>


</pre></table></code></div></div><p>First, it’ll get a reference to the “freed” RFH and use it as an argument for the function <a href="https://source.chromium.org/chromium/chromium/src/+/master:content/browser/web_contents/web_contents_impl.cc;l=375;drc=28442cacc3be1a7d05a898aba663025a143095ac"><code class="language-plaintext highlighter-rouge">WebContents::FromRenderFrameHost</code></a> <a href="#code-note-14">[14]</a>. Then, it’ll return a pointer to the <code class="language-plaintext highlighter-rouge">WebContentsImpl</code> object. Finally, it’ll check if the <code class="language-plaintext highlighter-rouge">WebContentsImpl</code> isn’t nullptr and execute some Java code, otherwise, it’ll just return early.</p><p>Now, let’s look at the <code class="language-plaintext highlighter-rouge">FromRenderFrameHost</code> implementation:</p><p><a id="code-note-15"></a> <a id="code-note-16"></a></p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">WebContents</span><span class="o">*</span> <span class="n">WebContents</span><span class="o">::</span><span class="n">FromRenderFrameHost</span><span class="p">(</span><span class="n">RenderFrameHost</span><span class="o">*</span> <span class="n">rfh</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rfh</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rfh</span><span class="o">-&gt;</span><span class="n">IsCurrent</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">base</span><span class="o">::</span><span class="n">FeatureList</span><span class="o">::</span><span class="n">IsEnabled</span><span class="p">(</span> <span class="c1">// [15]</span>
			       <span class="n">kCheckWebContentsAccessFromNonCurrentFrame</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// TODO(crbug.com/1059903): return nullptr here eventually.</span>
    <span class="n">base</span><span class="o">::</span><span class="n">debug</span><span class="o">::</span><span class="n">DumpWithoutCrashing</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">RenderFrameHostImpl</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">rfh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">delegate</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetAsWebContents</span><span class="p">();</span> <span class="c1">// [16]</span>

</pre></table></code></div></div><p>There are two function calls here that use the RFH. The first is at <a href="#code-note-15">[15]</a>, and the second at <a href="#code-note-16">[16]</a> where it will read a member object inside RFH and call its <code class="language-plaintext highlighter-rouge">GetAsWebContents</code> function. These method’s declarations look like the following:</p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">virtual</span> <span class="kt">bool</span> <span class="n">IsCurrent</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">virtual</span> <span class="n">WebContents</span><span class="o">*</span> <span class="nf">GetAsWebContents</span><span class="p">();</span>
</pre></table></code></div></div><p>As you can see both methods are declared virtual. As we know, the compiler will end up creating a <a href="https://en.wikipedia.org/wiki/Virtual_method_table">virtual table</a> to handle the dynamic dispatch! So, if we can somehow control the “freed” object, and replace its virtual table with a fake one that we control, we could call an arbitrary function pointer. Once we can call an arbitrary pointer, we can use Returned-Oriented-Programming (ROP) or Jump-Oriented-Programming (JOP) and achieve arbitrary code execution.</p><p>Also, if we can make the <code class="language-plaintext highlighter-rouge">GetAsWebContents</code> return nullptr (0x0), we can smoothly continue the browser execution with no crash. Sounds like a nice plan!</p><p>However, we have a problem here: Address Space Layout Randomization (ASLR). We may have a UAF and we may somehow be able to replace its object virtual table with controlled contents, but we have no idea where .text, .data or heap allocations are as we have no information disclosure vulnerability.</p><p>We did not get so far to give up! Let’s think about it further.</p><h3 id="zygote-to-rescue">Zygote to Rescue!</h3><p>I was using a Pixel 3A android device as target for my exploit and while I was researching a solution for the ASLR problem, I found out that Android has its own way to launch applications. It is using a concept called “Zygote” and there are many articles giving in-depth details of how it works and its <a href="https://serializethoughts.com/2016/05/25/security-implications-of-zygote-process-creation-model">security implications</a>.</p><p>For us, Zygote essentially means that every new spawned process will <a href="https://copperhead.co/blog/aslr-android-zygote/">share the same ASLR base between them</a>, in another words: Processes can end up sharing the same virtual memory mapping between some shared libraries!</p><p>That is perfect, as having a remote code execution exploit (taking over Renderer Process by using either a V8 or Blink vulnerability, for example) may help us to easily defeat ASLR as both Renderer Process and Browser process share the same virtual mapping between shared libraries.</p><h3 id="do-we-really-need-rop-andor-jop">Do we really need ROP and/or JOP?</h3><p>Essentially, once we can replace the “freed” RFH object in memory with attacker-controlled data, we want to make its virtual table to point to a fake virtual table and jump into any arbitrary function or a stack-pivot for ROP. However, ASLR is still a problem for the heap segments as we have no information about its heap layout.</p><p>We can bypass the heap problem by calling another object virtual table that will end up writing the RFH <code class="language-plaintext highlighter-rouge">this</code> pointer onto itself (and being able to read the object memory back into Renderer Process). That should work; however, there is something even better! <a href="https://twitter.com/oldfresher">Guang Gong</a> has presented a nice technique in <a href="https://github.com/secmob/TiYunZong-An-Exploit-Chain-to-Remotely-Root-Modern-Android-Devices/blob/master/us-20-Gong-TiYunZong-An-Exploit-Chain-to-Remotely-Root-Modern-Android-Devices-wp.pdf">“An exploit Chain to Remotely Root Modern Android Devices”</a>. The article explains that the <code class="language-plaintext highlighter-rouge">libllvm-glnext.so</code> (that is present in Pixel 3a) has a function pointer to <code class="language-plaintext highlighter-rouge">system</code> in its <code class="language-plaintext highlighter-rouge">.GOT segment</code>. We can easily replace the RFH virtual table to point into <code class="language-plaintext highlighter-rouge">libllvm-glnext.so .GOT</code> and make a call to <code class="language-plaintext highlighter-rouge">system</code>!</p><center><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://microsoftedge.github.io/edgevr/assets/img/blog_img/yarfuaf/UAF_Exploitation.svg" /></center><p>The beauty here is that the system’s function argument is a pointer to the RFH object (aka this) that we fully control! Now we can call system with arbitrary command in context of Browser Process! Feels back into 90s, right?</p><h3 id="keeping-the-browser-alive-crash--fun">Keeping the Browser alive (CRASH != FUN)</h3><p>Let’s look again at the <code class="language-plaintext highlighter-rouge">WebContents::FromenderFrameHost</code> function but from another perspective, the ARM-assembly perspective:</p><p><a id="code-note-17"></a> <a id="code-note-18"></a></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre>0x0000000000000000:  10 B5          push  {r4, lr}
0x0000000000000002:  98 B1          cbz   r0, #0x2c
0x0000000000000004:  04 46          mov   r4, r0

// R0 = RFH-&gt;vtable
0x0000000000000006:  00 68          ldr   r0, [r0]
// R1 = RFH-&gt;vtable[0xBC/0x4] -- system pointer
0x0000000000000008:  D0 F8 BC 10    ldr.w r1, [r0, #0xbc]
0x000000000000000c:  20 46          mov   r0, r4
// system(R0)
0x000000000000000e:  88 47          blx   r1 // [17]

0x0000000000000010:  30 B9          cbnz  r0, #0x20
0x0000000000000012:  07 48          ldr   r0, [pc, #0x1c]
0x0000000000000014:  78 44          add   r0, pc
0x0000000000000016:  A9 F1 42 EA    blx   #0x1a949c
0x000000000000001a:  08 B1          cbz   r0, #0x20
0x000000000000001c:  A9 F1 06 EE    blx   #0x1a9c2c

// R0 = RFH-&gt;member_7c
0x0000000000000020:  E0 6F          ldr   r0, [r4, #0x7c]
// R1 = RFH-&gt;member_7c-&gt;vtable
0x0000000000000022:  01 68          ldr   r1, [r0]
// R1 = RFH-&gt;member_7c-&gt;vtable[0x64/0x4]
0x0000000000000024:  49 6E          ldr   r1, [r1, #0x64]
0x0000000000000026:  BD E8 10 40    pop.w {r4, lr} // [18]
// return R1(), where R1 is a function that will set R0 (return value) to 0
// it'll make WebContents == nullptr and not crashing the browser :)
0x000000000000002a:  08 47          bx    r1
0x000000000000002c:  00 20          movs  r0, #0
0x000000000000002e:  10 BD          pop   {r4, pc}
</pre></table></code></div></div><p>As you can see, there are two virtual function calls. The first call, <code class="language-plaintext highlighter-rouge">RFH-&gt;vtable_fptr[0x2F]</code> <a href="#code-note-17">[17]</a>, we can use to call system with controlled arguments. However, the second virtual call, <code class="language-plaintext highlighter-rouge">RFH-&gt;member_7C-&gt;vtable_fptr[0x19]</code> <a href="#code-note-18">[18]</a>, is a problem for us. As you already know we have no information disclosure about the heap memory layout, so, we cannot easily fake a <code class="language-plaintext highlighter-rouge">member_7C</code> object.</p><p>So, what is the solution here? Maybe we could just let the browser crash anyway, as we will end up executing the system command before the crash happens… But, let’s be honest, crashing the browser isn’t fun, can we do something else? Yes, <code class="language-plaintext highlighter-rouge">Zygote@libllvm-glnext</code> to the rescue again.</p><p>Do we have such a magic pointer in <code class="language-plaintext highlighter-rouge">libllvm-glnext</code>? Yes! At offset <code class="language-plaintext highlighter-rouge">0x8E4BE8</code> (<code class="language-plaintext highlighter-rouge">.GOT segment</code>) we have exactly what we need, we will end up with the following call chain:</p><center><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://microsoftedge.github.io/edgevr/assets/img/blog_img/yarfuaf/UAF_Exploitation_2.svg" /></center><p>Now, we can both call system and resume execution smoothly without crashing the browser :)</p><h3 id="replacing-the-object">Replacing the Object</h3><p>Alright, at this point we want to replace the object in memory with fully controlled content. What we need here is some heap-spray primitive. We could go and try to find our own, however, let’s not recreate the wheel. We can use the same technique demonstrated by <a href="https://googleprojectzero.blogspot.com/2019/04/virtually-unlimited-memory-escaping.html">“GPZ Virtually Unlimited Memory”</a>, since it still works and fulfills all our needs.</p><p>Now, the next step is to find the size of the RFH object size in memory. This is necessary as we increase the chance to reclaim the memory by spraying payloads of the same size as the RFH object. You can do it by using your favorite disassembler, compiler, debugger, or any other tool. In my case, it was <code class="language-plaintext highlighter-rouge">0x880</code> bytes.</p><p>However, if you heap spray using the technique above, it may work and reclaim the object, but it may also be a bit unstable. Apparently, on Android, at least for the version that I had when I wrote the exploit, the Browser Process will end up using <a href="https://blog.nsogroup.com/a-tale-of-two-mallocs-on-android-libc-allocators-part-2-jemalloc/">jemalloc as the default heap allocator</a>.</p><p>There is <a href="http://phrack.org/issues/68/10.html">enough documentation</a> (that I recommend reading) regarding the allocator internals, thus, I will not go into details here. What is interesting for us is that jemalloc implements thread specific caches. Remember, our target object, the freed RFH, is created and destroyed on <code class="language-plaintext highlighter-rouge">UI thread</code> and the heap-spray technique will happen on <code class="language-plaintext highlighter-rouge">IO thread</code>. Due to this, we may have our allocations happening in different <code class="language-plaintext highlighter-rouge">thread-caches/arenas</code>.</p><p>As we want to be able to reclaim a <code class="language-plaintext highlighter-rouge">freed region</code> (a.k.a our RFH object) from another thread, we need to cause either a <code class="language-plaintext highlighter-rouge">flush event</code> or <code class="language-plaintext highlighter-rouge">hard event</code> that will end up freeing some bins/regions inside a <code class="language-plaintext highlighter-rouge">tcache</code> (each bin has its own tcache, that is a list for the recently freed regions).</p><p>Once a flush or hard event occurs, the region can now be allocated by other threads. This can be accomplished by first freeing our victim RFH object and then allocating multiple iframes and freeing them. Following this you can spray as normal with your heap-spray primitive. In my tests, this seems to have increased the exploit’s reliability.</p><h3 id="putting-it-all-together">Putting It All Together</h3><p>Now, using all the knowledge we have learned, let’s summarize how our exploit works:</p><ul><li>Create a child iframe that will use <code class="language-plaintext highlighter-rouge">MojoJS</code> to create and bind to a <code class="language-plaintext highlighter-rouge">SmsReceiver</code> interface (thus, creating a <code class="language-plaintext highlighter-rouge">SmsProviderGmsUserConsent</code> with a pointer to its RFH). <code class="language-plaintext highlighter-rouge">MojoJS</code> can be enabled by a compromised renderer.</li><li>Send a postMessage from the child iframe to the main frame to tell it the Mojo interface has been created. The main frame can now delete the child iframe with <code class="language-plaintext highlighter-rouge">document.body.removeChild</code>.</li><li>In the main frame, create another <code class="language-plaintext highlighter-rouge">SmsReceiver</code> interface. This instantiation will use the already created <code class="language-plaintext highlighter-rouge">SmsFetcherImpl</code> which has a raw pointer to the <code class="language-plaintext highlighter-rouge">freed</code> RFH object.</li><li>Prepare our heap payload:<ul><li>The first 4 bytes (32 bit architecture) is the virtual table pointer, it’ll be a pointer to <code class="language-plaintext highlighter-rouge">libllvm-glnext.so</code> <code class="language-plaintext highlighter-rouge">.got.plt</code> minus <code class="language-plaintext highlighter-rouge">0xBC</code> (offset for virtual table) so we land in the correct address.</li><li>The next bytes will be our shell command, something of the form “|| (command).” This way it’ll first execute the virtual table address as a “command” and then execute our shell command. For the exploit, I used: <code class="language-plaintext highlighter-rouge">' || (toybox nc -p 4444 -l /bin/sh)')</code>.</li><li>At offset <code class="language-plaintext highlighter-rouge">0x7C</code> of our payload we will have a pointer to the “magic function pointer” in <code class="language-plaintext highlighter-rouge">libllvm-glnext.so</code>, so we can guarantee the <code class="language-plaintext highlighter-rouge">GetAsWebContents</code> virtual method will return the value <code class="language-plaintext highlighter-rouge">0x0</code>, making <code class="language-plaintext highlighter-rouge">SmsProviderGmsUserConsent::Retrieve</code> return early, avoiding a browser crash.</li><li>Spray these bytes using the same technique learned <a href="https://googleprojectzero.blogspot.com/2019/04/virtually-unlimited-memory-escaping.html">here</a>, but use the jemalloc trick described earlier to make it more reliable.</li></ul></li><li>Call <code class="language-plaintext highlighter-rouge">SmsReceiver.receive</code> method and watch the magic!</li></ul><p>You can find the final exploit <a href="https://gist.github.com/ohnull/2cbfa501936a2fff4fd9efa67310cda8">here</a>.</p><h1 id="conclusion">Conclusion</h1><p>At this point you can run shell commands in the context of Browser Process. Due to the Android security model, you may have limited resource access as you are still inside Android’s application sandbox. The next step would be to chain a kernel vulnerability, as described <a href="https://github.com/secmob/TiYunZong-An-Exploit-Chain-to-Remotely-Root-Modern-Android-Devices/blob/master/us-20-Gong-TiYunZong-An-Exploit-Chain-to-Remotely-Root-Modern-Android-Devices-wp.pdf">here</a>, but this is a story for another day.</p><p>I hope you have enjoyed reading and learning a little more about Chromium as much as I have while learning and writing all of it. This issue was a nice exploit exercise and I think it would have been harder to exploit if Zygote didn’t weaken ASLR on Android. Now that we know how the vulnerability works and its pattern, we can write more security documentation, give insight to our developers into how to write Mojo interfaces with no such pattern and proactively find vulnerabilities on our security reviews.</p><p>Furthermore, Google has been working hard to mitigate UAF issues through efforts such as <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1121427">PartitionAlloc everywhere</a>, <a href="https://www.youtube.com/watch?v=ohlxw5kDn-k">MiraclePtr</a> and <a href="https://source.chromium.org/chromium/chromium/src/+/master:base/allocator/partition_allocator/pcscan.h">*Scan</a>. We are looking forward to making contributions and working with them to make these vulnerabilities harder to exploit.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/edgevr/categories/vulnerabilities/'>Vulnerabilities</a>, <a href='/edgevr/categories/exploit/'>Exploit</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/edgevr/tags/android/" class="post-tag no-text-decoration" >Android</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><!-- Post sharing snippet v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Yet another RenderFrameHostImpl UAF - Microsoft Browser Vulnerability Research&url=https://microsoftedge.github.io/edgevr/posts/yet-another-uaf/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Yet another RenderFrameHostImpl UAF - Microsoft Browser Vulnerability Research&u=https://microsoftedge.github.io/edgevr/posts/yet-another-uaf/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Yet another RenderFrameHostImpl UAF - Microsoft Browser Vulnerability Research&url=https://microsoftedge.github.io/edgevr/posts/yet-another-uaf/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://microsoftedge.github.io/edgevr/posts/yet-another-uaf/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><!-- The Pannel on right side (Desktop views) v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><h3 data-toc-skip>Recent Update</h3><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/edgevr/posts/Introducing-Enhanced-Security-for-Microsoft-Edge/">Introducing Enhanced Security for Microsoft Edge</a></li><li><a href="/edgevr/posts/Super-Duper-Secure-Mode/">Super Duper Secure Mode</a></li><li><a href="/edgevr/posts/attacking-the-devtools/">Guest Blog Post - Attacking the DevTools</a></li><li><a href="/edgevr/posts/eliminating-xss-with-trusted-types/">Eliminating XSS from WebUI with Trusted Types</a></li><li><a href="/edgevr/posts/Hacking-Chrome-iOS/">iOS Chromium Overlooked and Underappreciated</a></li></ul></div><div id="access-tags"><h3 data-toc-skip>Trending Tags</h3><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/edgevr/tags/tips/">tips</a> <a class="post-tag" href="/edgevr/tags/site-isolation/">Site Isolation</a> <a class="post-tag" href="/edgevr/tags/jit/">JIT</a> <a class="post-tag" href="/edgevr/tags/ios/">iOS</a> <a class="post-tag" href="/edgevr/tags/fuzzing/">fuzzing</a> <a class="post-tag" href="/edgevr/tags/ui/">UI</a> <a class="post-tag" href="/edgevr/tags/trusted-types/">Trusted Types</a> <a class="post-tag" href="/edgevr/tags/memory-corruption/">Memory Corruption</a> <a class="post-tag" href="/edgevr/tags/headlines/">Headlines</a> <a class="post-tag" href="/edgevr/tags/devtools/">DevTools</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h3 data-toc-skip class="pl-3 pt-2 mb-2">Contents</h3><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <!-- Recommend the other 3 posts according to the tags and categories of the current post, if the number is not enough, use the other latest posts to supplement. v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/edgevr/posts/attacking-the-devtools/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Jul 21, 2021 <i class="unloaded">2021-07-21T09:00:00-07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Guest Blog Post - Attacking the DevTools</h3><div class="text-muted small"><p> In this post, we’ve invited David Erceg, one of the participants in the Edge bug bounty program, to talk about interesting bugs he found in Edge. By sharing this information, we hope more security...</p></div></div></a></div><div class="card"> <a href="/edgevr/posts/Hacking-Chrome-iOS/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Oct 16, 2020 <i class="unloaded">2020-10-16T09:00:00-07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>iOS Chromium Overlooked and Underappreciated</h3><div class="text-muted small"><p> A Bold New Frontier As part of Microsoft’s Edge’s move to using Chromium as the backbone of our browsers, we are updating all our browser product lines, including the iOS version. As security engin...</p></div></div></a></div><div class="card"> <a href="/edgevr/posts/memory-corruption-vulnerabilities-in-edge/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Oct 17 <i class="unloaded">2022-10-17T09:00:00-07:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Guest Blog Post - Memory corruption vulnerabilities in Edge</h3><div class="text-muted small"><p> Introduction Memory corruption issues in the browser process are typically some of the most severe issues in Chromium and browsers that are based off it. Such issues can include use-after-free (UA...</p></div></div></a></div></div></div><!-- Navigation buttons at the bottom of the post. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --><div class="post-navigation d-flex justify-content-between"> <a href="/edgevr/posts/deep-dive-into-site-isolation-part-2/" class="btn btn-outline-primary"><p>Deep Dive into Site Isolation (Part 2)</p></a> <a href="/edgevr/posts/eliminating-xss-with-trusted-types/" class="btn btn-outline-primary"><p>Eliminating XSS from WebUI with Trusted Types</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script> <!-- The Footer v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/MSEdgeDev">Microsoft Corporation</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/">Chirpy</a> theme.</p></div></div></footer></div><!-- The Search results v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/edgevr/tags/tips/">tips</a> <a class="post-tag" href="/edgevr/tags/site-isolation/">Site Isolation</a> <a class="post-tag" href="/edgevr/tags/jit/">JIT</a> <a class="post-tag" href="/edgevr/tags/ios/">iOS</a> <a class="post-tag" href="/edgevr/tags/fuzzing/">fuzzing</a> <a class="post-tag" href="/edgevr/tags/ui/">UI</a> <a class="post-tag" href="/edgevr/tags/trusted-types/">Trusted Types</a> <a class="post-tag" href="/edgevr/tags/memory-corruption/">Memory Corruption</a> <a class="post-tag" href="/edgevr/tags/headlines/">Headlines</a> <a class="post-tag" href="/edgevr/tags/devtools/">DevTools</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <!-- The GA snippet v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', '', 'auto'); ga('send', 'pageview'); </script> <!-- Jekyll Simple Search loader v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/edgevr/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://microsoftedge.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
